import{_ as s,o as e,c as a,Q as n}from"./chunks/framework.a333c6fb.js";const h=JSON.parse('{"title":"处理文件","description":"","frontmatter":{},"headers":[],"relativePath":"etc/gulp/src/file.md","filePath":"etc/gulp/src/file.md","lastUpdated":1738076829000}'),p={name:"etc/gulp/src/file.md"},l=n(`<h1 id="处理文件" tabindex="-1">处理文件 <a class="header-anchor" href="#处理文件" aria-label="Permalink to &quot;处理文件&quot;">​</a></h1><p>gulp 暴露了 <code>src()</code> 和 <code>dest()</code> 方法用于处理计算机上存放的文件。</p><p><code>src()</code> 接受参数，并从文件系统中读取文件然后生成一个 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noreferrer">Node 流（stream）</a>。它将所有匹配的文件读取到内存中并通过流（stream）进行处理。</p><p>由 <code>src()</code> 产生的流（stream）应当从任务（task）中返回并发出异步完成的信号。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">exports.default = function() {</span></span>
<span class="line"><span style="color:#e1e4e8;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#000000;"></span></span>
<span class="line"><span style="color:#000000;">exports.default = function() {</span></span>
<span class="line"><span style="color:#000000;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#000000;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#000000;">}</span></span></code></pre></div><p>流（stream）所提供的主要的 API 是 <code>.pipe()</code> 方法，用于连接转换流（Transform streams）或可写流（Writable streams）。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;">const babel = require(&#39;gulp-babel&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">exports.default = function() {</span></span>
<span class="line"><span style="color:#e1e4e8;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(babel())</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#000000;">const babel = require(&#39;gulp-babel&#39;);</span></span>
<span class="line"><span style="color:#000000;"></span></span>
<span class="line"><span style="color:#000000;">exports.default = function() {</span></span>
<span class="line"><span style="color:#000000;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#000000;">    .pipe(babel())</span></span>
<span class="line"><span style="color:#000000;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#000000;">}</span></span></code></pre></div><p><code>dest()</code> 接受一个输出目录作为参数，并且它还会产生一个 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noreferrer">Node 流（stream）</a>，通常作为终止流（terminator stream）。当它接收到通过管道（pipeline）传输的文件时，它会将文件内容及文件属性写入到指定的目录中。gulp 还提供了 <code>symlink()</code> 方法，其操作方式类似 <code>dest()</code>，但是创建的是链接而不是文件（ 详情请参阅 <a href="https://www.gulpjs.com.cn/docs/api/symlink" target="_blank" rel="noreferrer"><code>symlink()</code></a> ）。</p><p>大多数情况下，利用 <code>.pipe()</code> 方法将插件放置在 <code>src()</code> 和 <code>dest()</code> 之间，并转换流（stream）中的文件。</p><h2 id="向流-stream-中添加文件​" tabindex="-1">向流（stream）中添加文件<a href="https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E5%90%91%E6%B5%81stream%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6" title="Direct link to 向流（stream）中添加文件" target="_blank" rel="noreferrer">​</a> <a class="header-anchor" href="#向流-stream-中添加文件​" aria-label="Permalink to &quot;向流（stream）中添加文件[​](https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E5%90%91%E6%B5%81stream%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6 &quot;Direct link to 向流（stream）中添加文件&quot;)&quot;">​</a></h2><p><code>src()</code> 也可以放在管道（pipeline）的中间，以根据给定的 glob 向流（stream）中添加文件。新加入的文件只对后续的转换可用。如果 <a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#overlapping-globs" target="_blank" rel="noreferrer">glob 匹配的文件与之前的有重复</a>，仍然会再次添加文件。</p><p>这对于在添加普通的 JavaScript 文件之前先转换部分文件的场景很有用，添加新的文件后可以对所有文件统一进行压缩并混淆（uglifying）。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;">const babel = require(&#39;gulp-babel&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;">const uglify = require(&#39;gulp-uglify&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">exports.default = function() {</span></span>
<span class="line"><span style="color:#e1e4e8;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(babel())</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(src(&#39;vendor/*.js&#39;))</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(uglify())</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#000000;">const babel = require(&#39;gulp-babel&#39;);</span></span>
<span class="line"><span style="color:#000000;">const uglify = require(&#39;gulp-uglify&#39;);</span></span>
<span class="line"><span style="color:#000000;"></span></span>
<span class="line"><span style="color:#000000;">exports.default = function() {</span></span>
<span class="line"><span style="color:#000000;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#000000;">    .pipe(babel())</span></span>
<span class="line"><span style="color:#000000;">    .pipe(src(&#39;vendor/*.js&#39;))</span></span>
<span class="line"><span style="color:#000000;">    .pipe(uglify())</span></span>
<span class="line"><span style="color:#000000;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#000000;">}</span></span></code></pre></div><h2 id="分阶段输出​" tabindex="-1">分阶段输出<a href="https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E5%88%86%E9%98%B6%E6%AE%B5%E8%BE%93%E5%87%BA" title="Direct link to 分阶段输出" target="_blank" rel="noreferrer">​</a> <a class="header-anchor" href="#分阶段输出​" aria-label="Permalink to &quot;分阶段输出[​](https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E5%88%86%E9%98%B6%E6%AE%B5%E8%BE%93%E5%87%BA &quot;Direct link to 分阶段输出&quot;)&quot;">​</a></h2><p><code>dest()</code> 可以用在管道（pipeline）中间用于将文件的中间状态写入文件系统。当接收到一个文件时，当前状态的文件将被写入文件系统，文件路径也将被修改以反映输出文件的新位置，然后该文件继续沿着管道（pipeline）传输。</p><p>此功能可用于在同一个管道（pipeline）中创建未压缩（unminified）和已压缩（minified）的文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;">const babel = require(&#39;gulp-babel&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;">const uglify = require(&#39;gulp-uglify&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;">const rename = require(&#39;gulp-rename&#39;);</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">exports.default = function() {</span></span>
<span class="line"><span style="color:#e1e4e8;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(babel())</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(src(&#39;vendor/*.js&#39;))</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(dest(&#39;output/&#39;))</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(uglify())</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(rename({ extname: &#39;.min.js&#39; }))</span></span>
<span class="line"><span style="color:#e1e4e8;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">const { src, dest } = require(&#39;gulp&#39;);</span></span>
<span class="line"><span style="color:#000000;">const babel = require(&#39;gulp-babel&#39;);</span></span>
<span class="line"><span style="color:#000000;">const uglify = require(&#39;gulp-uglify&#39;);</span></span>
<span class="line"><span style="color:#000000;">const rename = require(&#39;gulp-rename&#39;);</span></span>
<span class="line"><span style="color:#000000;"></span></span>
<span class="line"><span style="color:#000000;">exports.default = function() {</span></span>
<span class="line"><span style="color:#000000;">  return src(&#39;src/*.js&#39;)</span></span>
<span class="line"><span style="color:#000000;">    .pipe(babel())</span></span>
<span class="line"><span style="color:#000000;">    .pipe(src(&#39;vendor/*.js&#39;))</span></span>
<span class="line"><span style="color:#000000;">    .pipe(dest(&#39;output/&#39;))</span></span>
<span class="line"><span style="color:#000000;">    .pipe(uglify())</span></span>
<span class="line"><span style="color:#000000;">    .pipe(rename({ extname: &#39;.min.js&#39; }))</span></span>
<span class="line"><span style="color:#000000;">    .pipe(dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#000000;">}</span></span></code></pre></div><h2 id="模式-流动-streaming-、缓冲-buffered-和空-empty-模式​" tabindex="-1">模式：流动（streaming）、缓冲（buffered）和空（empty）模式<a href="https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E6%A8%A1%E5%BC%8F%E6%B5%81%E5%8A%A8streaming%E7%BC%93%E5%86%B2buffered%E5%92%8C%E7%A9%BAempty%E6%A8%A1%E5%BC%8F" title="Direct link to 模式：流动（streaming）、缓冲（buffered）和空（empty）模式" target="_blank" rel="noreferrer">​</a> <a class="header-anchor" href="#模式-流动-streaming-、缓冲-buffered-和空-empty-模式​" aria-label="Permalink to &quot;模式：流动（streaming）、缓冲（buffered）和空（empty）模式[​](https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E6%A8%A1%E5%BC%8F%E6%B5%81%E5%8A%A8streaming%E7%BC%93%E5%86%B2buffered%E5%92%8C%E7%A9%BAempty%E6%A8%A1%E5%BC%8F &quot;Direct link to 模式：流动（streaming）、缓冲（buffered）和空（empty）模式&quot;)&quot;">​</a></h2><p><code>src()</code> 可以工作在三种模式下：缓冲（buffering）、流动（streaming）和空（empty）模式。这些模式可以通过对 <code>src()</code> 的 <code>buffer</code> 和 <code>read</code> <a href="https://www.gulpjs.com.cn/docs/api/src#options" target="_blank" rel="noreferrer">参数</a> 进行设置。</p><ul><li>缓冲（Buffering）模式是默认模式，将文件内容加载内存中。插件通常运行在缓冲（buffering）模式下，并且许多插件不支持流动（streaming）模式。</li><li>流动（Streaming）模式的存在主要用于操作无法放入内存中的大文件，例如巨幅图像或电影。文件内容从文件系统中以小块的方式流式传输，而不是一次性全部加载。如果需要流动（streaming）模式，请查找支持此模式的插件或自己编写。</li><li>空（Empty）模式不包含任何内容，仅在处理文件元数据时有用。</li></ul><h1 id="glob字符串" tabindex="-1">glob字符串 <a class="header-anchor" href="#glob字符串" aria-label="Permalink to &quot;glob字符串&quot;">​</a></h1><p>glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件。</p><hr><p>字符串片段（segment）是指两个分隔符之间的所有字符组成的字符串。在 glob 中，分隔符永远是 <code>/</code> 字符 - 不区分操作系统 - 即便是在采用 <code>\\</code> 作为分隔符的 Windows 操作系统中。在 glob 中，<code>\\</code> 字符被保留作为转义符使用。</p><p>如下， * 被转义了，因此，* 将被作为一个普通字符使用，而不再是通配符了。</p><p>避免使用 Node 的 <code>path</code> 类方法来创建 glob，例如 <code>path.join</code>。在 Windows 中，由于 Node 使用 <code>\\</code> 作为路径分隔符，因此将会产生一个无效的 glob。还要避免使用 <code>__dirname</code> 和 <code>__filename</code> 全局变量，由于同样的原因，<code>process.cwd()</code> 方法也要避免使用。</p><h2 id="特殊字符-一个星号-​" tabindex="-1">特殊字符： * (一个星号)<a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E4%B8%80%E4%B8%AA%E6%98%9F%E5%8F%B7" title="Direct link to 特殊字符： * (一个星号)" target="_blank" rel="noreferrer">​</a> <a class="header-anchor" href="#特殊字符-一个星号-​" aria-label="Permalink to &quot;特殊字符： * (一个星号)[​](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E4%B8%80%E4%B8%AA%E6%98%9F%E5%8F%B7 &quot;Direct link to 特殊字符： * (一个星号)&quot;)&quot;">​</a></h2><p>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用。</p><p>下面这个 glob 能够匹配类似 <code>index.js</code> 的文件，但是不能匹配类似 <code>scripts/index.js</code> 或 <code>scripts/nested/index.js</code> 的文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&#39;*.js&#39;</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">&#39;*.js&#39;</span></span></code></pre></div><h2 id="特殊字符-两个星号-​" tabindex="-1">特殊字符： ** (两个星号)<a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E4%B8%A4%E4%B8%AA%E6%98%9F%E5%8F%B7" title="Direct link to 特殊字符： ** (两个星号)" target="_blank" rel="noreferrer">​</a> <a class="header-anchor" href="#特殊字符-两个星号-​" aria-label="Permalink to &quot;特殊字符： ** (两个星号)[​](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E4%B8%A4%E4%B8%AA%E6%98%9F%E5%8F%B7 &quot;Direct link to 特殊字符： ** (两个星号)&quot;)&quot;">​</a></h2><p>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用。请确保适当地限制带有两个星号的 glob 的使用，以避免匹配大量不必要的目录。</p><p>下面这个 glob 被适当地限制在 <code>scripts/</code> 目录下。它将匹配类似 <code>scripts/index.js</code>、<code>scripts/nested/index.js</code> 和 <code>scripts/nested/twice/index.js</code> 的文件。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&#39;scripts/**/*.js&#39;</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">&#39;scripts/**/*.js&#39;</span></span></code></pre></div><p>在上面的示例中，如果没有 <code>scripts/</code> 这个前缀做限制，<code>node_modules</code> 目录下的所有目录或其他目录也都将被匹配。</p><h2 id="特殊字符-取反-​" tabindex="-1">特殊字符： ! (取反)<a href="https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E5%8F%96%E5%8F%8D" title="Direct link to 特殊字符： ! (取反)" target="_blank" rel="noreferrer">​</a> <a class="header-anchor" href="#特殊字符-取反-​" aria-label="Permalink to &quot;特殊字符： ! (取反)[​](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E5%8F%96%E5%8F%8D &quot;Direct link to 特殊字符： ! (取反)&quot;)&quot;">​</a></h2><p>以 <code>!</code> 字符开头的通配符会对该通配符进行 “取反” 操作，即完全排除匹配到的内容。所有取反的通配符都会应用到每个正向通配符上，这与 Gulp 5 之前的版本有所不同。</p><p>在这里，会遍历 <code>scripts/</code> 目录以查找所有以 <code>.js</code> 结尾的文件，但 <code>scripts/vendor/</code> 目录下的所有文件都会被排除在外。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">[&#39;scripts/**/*.js&#39;, &#39;!scripts/vendor/**&#39;]</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">[&#39;scripts/**/*.js&#39;, &#39;!scripts/vendor/**&#39;]</span></span></code></pre></div><p>取反通配符可以作为一种限制双星号通配符匹配范围的替代方法。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">[&#39;**/*.js&#39;, &#39;!node_modules/**&#39;]</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">[&#39;**/*.js&#39;, &#39;!node_modules/**&#39;]</span></span></code></pre></div><h3 id="有序通配符" tabindex="-1">有序通配符 <a class="header-anchor" href="#有序通配符" aria-label="Permalink to &quot;有序通配符&quot;">​</a></h3><p>Gulp 5 之前的版本支持 “有序通配符”；不过，为了与生态系统中的大多数通配符匹配库保持一致，该功能已被移除。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const order = require(&quot;ordered-read-streams&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">  exports.default = function () {</span></span>
<span class="line"><span style="color:#e1e4e8;">    return order([</span></span>
<span class="line"><span style="color:#e1e4e8;">      gulp.src(&quot;input/jquery/dist/jquery.js&quot;),</span></span>
<span class="line"><span style="color:#e1e4e8;">      gulp.src(&quot;input/detect_swipe/jquery.detect_swipe.js&quot;),</span></span>
<span class="line"><span style="color:#e1e4e8;">    ]).pipe(gulp.dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">const order = require(&quot;ordered-read-streams&quot;);</span></span>
<span class="line"><span style="color:#000000;">  exports.default = function () {</span></span>
<span class="line"><span style="color:#000000;">    return order([</span></span>
<span class="line"><span style="color:#000000;">      gulp.src(&quot;input/jquery/dist/jquery.js&quot;),</span></span>
<span class="line"><span style="color:#000000;">      gulp.src(&quot;input/detect_swipe/jquery.detect_swipe.js&quot;),</span></span>
<span class="line"><span style="color:#000000;">    ]).pipe(gulp.dest(&#39;output/&#39;));</span></span>
<span class="line"><span style="color:#000000;">  }</span></span></code></pre></div><p>如果你需要 “有序通配符” 功能，可以使用 <code>ordered - read - streams</code> 库来合并流：</p><h2 id="匹配重叠-overlapping-globs" tabindex="-1">匹配重叠（Overlapping globs） <a class="header-anchor" href="#匹配重叠-overlapping-globs" aria-label="Permalink to &quot;匹配重叠（Overlapping globs）&quot;">​</a></h2><p>两个或多个 glob 故意或无意匹配了相同的文件就被认为是匹配重叠（overlapping）了。如果在同一个 <code>src()</code> 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 <code>src()</code> 调用时产生的匹配重叠是不会被去重的。</p>`,47),o=[l];function t(c,r,i,d,u,g){return e(),a("div",null,o)}const b=s(p,[["render",t]]);export{h as __pageData,b as default};
