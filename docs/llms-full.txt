---
url: /etc\vitepress\src/build.md
---
# 部署

## 本地构建与测试

1. 可以运行以下命令来构建文档：

```sh
$ npm run docs:build
```

2. 构建文档后，通过运行以下命令可以在本地预览它：

   ```sh
   $ npm run docs:preview
   ```

   `preview` 命令将启动一个本地静态 Web 服务 `http://localhost:4173`，该服务以 `.vitepress/dist` 作为源文件。这是检查生产版本在本地环境中是否正常的一种简单方法。

3. 可以通过传递 `--port` 作为参数来配置服务器的端口。
   ```json
   {
     "scripts": {
       "docs:preview": "vitepress preview docs --port 8080"
     }
   }
   ```

现在 `docs:preview` 方法将会在 `http://localhost:8080` 启动服务。

## 设置public 根目录

// 服务器访问前缀

```javascript
  export default defineConfig({
      title: 'Robinson',
      description: 'Documentations of @taiyuuki/utils',
      base: '/Robinson/', //public根目录
      outDir: "./docsDist",
      lastUpdated: true,
  })
```

## githubPage部署

在项目的 `.github/workflows` 目录中创建一个名为 `deploy.yml` 的文件，其中包含这样的内容：

```yaml
# 构建 VitePress 站点并将其部署到 GitHub Pages 的示例工作流程
#
name: Deploy VitePress site to Pages

on:
  # 在针对 `main` 分支的推送上运行。如果你
  # 使用 `master` 分支作为默认分支，请将其更改为 `master`
  push:
    branches: [main]

  # 允许你从 Actions 选项卡手动运行此工作流程
  workflow_dispatch:

# 设置 GITHUB_TOKEN 的权限，以允许部署到 GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# 只允许同时进行一次部署，跳过正在运行和最新队列之间的运行队列
# 但是，不要取消正在进行的运行，因为我们希望允许这些生产部署完成
concurrency:
  group: pages
  cancel-in-progress: false

jobs:
  # 构建工作
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 如果未启用 lastUpdated，则不需要
      # - uses: pnpm/action-setup@v3 # 如果使用 pnpm，请取消此区域注释
      #   with:
      #     version: 9
      # - uses: oven-sh/setup-bun@v1 # 如果使用 Bun，请取消注释
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm # 或 pnpm / yarn
      - name: Setup Pages
        uses: actions/configure-pages@v4
      - name: Install dependencies
        run: npm ci # 或 pnpm install / yarn install / bun install
      - name: Build with VitePress
        run: npm run docs:build # 或 pnpm docs:build / yarn docs:build / bun run docs:build
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: docs/.vitepress/dist

  # 部署工作
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    needs: build
    runs-on: ubuntu-latest
    name: Deploy
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
```

1. 在存储库设置中的“Pages”菜单项下，选择“Build and deployment > Source > GitHub Actions”。
2. 将更改推送到 `main` 分支并等待 GitHub Action 工作流完成。你应该看到站点部署到 `https://<username>.github.io/[repository]/` 或 `https://<custom-domain>/`，这取决于你的设置。你的站点将在每次推送到 `main` 分支时自动部署。

---

---
url: /etc\gulp\src/file.md
---
# 处理文件

gulp 暴露了 `src()` 和 `dest()` 方法用于处理计算机上存放的文件。

`src()` 接受参数，并从文件系统中读取文件然后生成一个 [Node 流（stream）](https://nodejs.org/api/stream.html)。它将所有匹配的文件读取到内存中并通过流（stream）进行处理。

由 `src()` 产生的流（stream）应当从任务（task）中返回并发出异步完成的信号。

```
const { src, dest } = require('gulp');

exports.default = function() {
  return src('src/*.js')
    .pipe(dest('output/'));
}
```

流（stream）所提供的主要的 API 是 `.pipe()` 方法，用于连接转换流（Transform streams）或可写流（Writable streams）。

```
const { src, dest } = require('gulp');
const babel = require('gulp-babel');

exports.default = function() {
  return src('src/*.js')
    .pipe(babel())
    .pipe(dest('output/'));
}
```

`dest()` 接受一个输出目录作为参数，并且它还会产生一个 [Node 流（stream）](https://nodejs.org/api/stream.html)，通常作为终止流（terminator stream）。当它接收到通过管道（pipeline）传输的文件时，它会将文件内容及文件属性写入到指定的目录中。gulp 还提供了 `symlink()` 方法，其操作方式类似 `dest()`，但是创建的是链接而不是文件（ 详情请参阅 [`symlink()`](https://www.gulpjs.com.cn/docs/api/symlink) ）。

大多数情况下，利用 `.pipe()` 方法将插件放置在 `src()` 和 `dest()` 之间，并转换流（stream）中的文件。

## 向流（stream）中添加文件[​](https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E5%90%91%E6%B5%81stream%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6 "Direct link to 向流（stream）中添加文件")

`src()` 也可以放在管道（pipeline）的中间，以根据给定的 glob 向流（stream）中添加文件。新加入的文件只对后续的转换可用。如果 [glob 匹配的文件与之前的有重复](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#overlapping-globs)，仍然会再次添加文件。

这对于在添加普通的 JavaScript 文件之前先转换部分文件的场景很有用，添加新的文件后可以对所有文件统一进行压缩并混淆（uglifying）。

```
const { src, dest } = require('gulp');
const babel = require('gulp-babel');
const uglify = require('gulp-uglify');

exports.default = function() {
  return src('src/*.js')
    .pipe(babel())
    .pipe(src('vendor/*.js'))
    .pipe(uglify())
    .pipe(dest('output/'));
}
```

## 分阶段输出[​](https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E5%88%86%E9%98%B6%E6%AE%B5%E8%BE%93%E5%87%BA "Direct link to 分阶段输出")

`dest()` 可以用在管道（pipeline）中间用于将文件的中间状态写入文件系统。当接收到一个文件时，当前状态的文件将被写入文件系统，文件路径也将被修改以反映输出文件的新位置，然后该文件继续沿着管道（pipeline）传输。

此功能可用于在同一个管道（pipeline）中创建未压缩（unminified）和已压缩（minified）的文件。

```
const { src, dest } = require('gulp');
const babel = require('gulp-babel');
const uglify = require('gulp-uglify');
const rename = require('gulp-rename');

exports.default = function() {
  return src('src/*.js')
    .pipe(babel())
    .pipe(src('vendor/*.js'))
    .pipe(dest('output/'))
    .pipe(uglify())
    .pipe(rename({ extname: '.min.js' }))
    .pipe(dest('output/'));
}
```

## 模式：流动（streaming）、缓冲（buffered）和空（empty）模式[​](https://www.gulpjs.com.cn/docs/getting-started/working-with-files#%E6%A8%A1%E5%BC%8F%E6%B5%81%E5%8A%A8streaming%E7%BC%93%E5%86%B2buffered%E5%92%8C%E7%A9%BAempty%E6%A8%A1%E5%BC%8F "Direct link to 模式：流动（streaming）、缓冲（buffered）和空（empty）模式")

`src()` 可以工作在三种模式下：缓冲（buffering）、流动（streaming）和空（empty）模式。这些模式可以通过对 `src()` 的 `buffer` 和 `read` [参数](https://www.gulpjs.com.cn/docs/api/src#options) 进行设置。

* 缓冲（Buffering）模式是默认模式，将文件内容加载内存中。插件通常运行在缓冲（buffering）模式下，并且许多插件不支持流动（streaming）模式。
* 流动（Streaming）模式的存在主要用于操作无法放入内存中的大文件，例如巨幅图像或电影。文件内容从文件系统中以小块的方式流式传输，而不是一次性全部加载。如果需要流动（streaming）模式，请查找支持此模式的插件或自己编写。
* 空（Empty）模式不包含任何内容，仅在处理文件元数据时有用。

# glob字符串

glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件。

***

字符串片段（segment）是指两个分隔符之间的所有字符组成的字符串。在 glob 中，分隔符永远是 `/` 字符 - 不区分操作系统 - 即便是在采用 `\` 作为分隔符的 Windows 操作系统中。在 glob 中，`\` 字符被保留作为转义符使用。

如下， \* 被转义了，因此，\* 将被作为一个普通字符使用，而不再是通配符了。

避免使用 Node 的 `path` 类方法来创建 glob，例如 `path.join`。在 Windows 中，由于 Node 使用 `\` 作为路径分隔符，因此将会产生一个无效的 glob。还要避免使用 `__dirname` 和 `__filename` 全局变量，由于同样的原因，`process.cwd()` 方法也要避免使用。

## 特殊字符： \* (一个星号)[​](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E4%B8%80%E4%B8%AA%E6%98%9F%E5%8F%B7 "Direct link to 特殊字符： * (一个星号)")

在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用。

下面这个 glob 能够匹配类似 `index.js` 的文件，但是不能匹配类似 `scripts/index.js` 或 `scripts/nested/index.js` 的文件。

```
'*.js'
```

## 特殊字符： \*\* (两个星号)[​](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E4%B8%A4%E4%B8%AA%E6%98%9F%E5%8F%B7 "Direct link to 特殊字符： ** (两个星号)")

在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用。请确保适当地限制带有两个星号的 glob 的使用，以避免匹配大量不必要的目录。

下面这个 glob 被适当地限制在 `scripts/` 目录下。它将匹配类似 `scripts/index.js`、`scripts/nested/index.js` 和 `scripts/nested/twice/index.js` 的文件。

```
'scripts/**/*.js'
```

在上面的示例中，如果没有 `scripts/` 这个前缀做限制，`node_modules` 目录下的所有目录或其他目录也都将被匹配。

## 特殊字符： ! (取反)[​](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%E5%8F%96%E5%8F%8D "Direct link to 特殊字符： ! (取反)")

以 `!` 字符开头的通配符会对该通配符进行 “取反” 操作，即完全排除匹配到的内容。所有取反的通配符都会应用到每个正向通配符上，这与 Gulp 5 之前的版本有所不同。

在这里，会遍历 `scripts/` 目录以查找所有以 `.js` 结尾的文件，但 `scripts/vendor/` 目录下的所有文件都会被排除在外。

```
['scripts/**/*.js', '!scripts/vendor/**']
```

取反通配符可以作为一种限制双星号通配符匹配范围的替代方法。

```
['**/*.js', '!node_modules/**']
```

### 有序通配符

Gulp 5 之前的版本支持 “有序通配符”；不过，为了与生态系统中的大多数通配符匹配库保持一致，该功能已被移除。

```
const order = require("ordered-read-streams");
  exports.default = function () {
    return order([
      gulp.src("input/jquery/dist/jquery.js"),
      gulp.src("input/detect_swipe/jquery.detect_swipe.js"),
    ]).pipe(gulp.dest('output/'));
  }

```

如果你需要 “有序通配符” 功能，可以使用 `ordered - read - streams` 库来合并流：

## 匹配重叠（Overlapping globs）

两个或多个 glob 故意或无意匹配了相同的文件就被认为是匹配重叠（overlapping）了。如果在同一个 `src()` 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 `src()` 调用时产生的匹配重叠是不会被去重的。

---

---
url: /etc\rollup\src/circularDev.md
---
# 处理循环依赖

。Rollup 通过静态分析来解析模块之间的依赖关系，并在打包过程中自动处理循环依赖。

* **避免无限递归**：虽然 Rollup 能够处理循环依赖，但在编写代码时仍需注意避免无限递归的情况。例如，在上面的示例中，如果 `a` 和 `b` 函数互相调用且没有终止条件，可能会导致栈溢出。
* **模块设计**：在设计模块时，尽量避免循环依赖。虽然 Rollup 能够处理，但循环依赖可能会增加代码的复杂性和维护难度。

---

---
url: /etc\vitepress\src/internation.md
---
# 国际化

要使用内置的 i18n (国际化) 功能，需要创建类似于下面的目录结构：

```
docs/
├─ es/
│  ├─ foo.md
├─ fr/
│  ├─ foo.md
├─ foo.md
```

在viteptess/config.ts中

```javascript
  import { defineConfig } from 'vitepress'

  export default defineConfig({
    // 共享属性和其他顶层内容...

    locales: {
      root: {
        label: 'English',
        lang: 'en'
      },
      fr: {
        label: 'French',
        lang: 'fr', // 可选，将作为 `lang` 属性添加到 `html` 标签中
        link: '/fr/guide' // 默认 /fr/ -- 显示在导航栏翻译菜单上，可以是外部的

        // 其余 locale 特定属性...
      }
    }
  })

```

下面的属性能够被每个 locale 覆盖 (包括 root)：

```javascript

    interface LocaleSpecificConfig<ThemeConfig = any> {
      lang?: string
      dir?: string
      title?: string
      titleTemplate?: string | boolean
      description?: string
      head?: HeadConfig[] // 将与现有的头部条目合并，重复的元标签将自动删除
      themeConfig?: ThemeConfig // 会进行浅层合并，常见内容可放在顶层的 themeConfig 属性中
    }
```

---

---
url: /etc\gulp\src/core.md
---
# 核心概念

## Gulpfile.js

可以理解为入口文件当执行`gulp`命令时会被自动加载

Node 的模块的解析功能允许你将 `gulpfile.js`' 文件替换为同样命名为 `gulpfile.js` 的文件夹，该文件夹中包含了一个名为 `index.js` 的文件，该 `index.js` 文件将被当作 `gulpfile.js` 使用。

## task

task（任务）是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable 类型值的函数。

### 任务类型

任务（tasks）可以是 **public（公开）**  或 **private（私有）**  类型的。

* **公开任务（Public tasks）**  从 gulpfile 中被导出（export），可以通过 `gulp` 命令直接调用。
* **私有任务（Private tasks）**  被设计为在内部使用，通常作为 `series()` 或 `parallel()` 组合的组成部分。

### 组合任务

Gulp 提供了两个强大的组合方法： `series()` 和 `parallel()`，允许将多个独立的任务组合为一个更大的操作。这两个方法都可以接受任意数目的任务（task）函数或已经组合的操作。`series()` 和 `parallel()` 可以互相嵌套至任意深度。

如果需要让任务（task）按顺序执行，请使用 `series()` 方法。

```javascript
// series 顺序执行函数
const { series } = require('gulp');  
  
function transpile(cb) {  
// body omitted  
cb();  
}  
  
function bundle(cb) {  
// body omitted  
cb();  
}  

exports.build = series(transpile, bundle);
```

对于希望以最大并发来运行的任务（tasks），可以使用 `parallel()` 方法将它们组合起来。

```javascript
// 同时执行
const { parallel } = require('gulp');  
  
function javascript(cb) {  
// body omitted  
cb();  
}  
  
function css(cb) {  
// body omitted  
cb();  
}  
  
exports.build = parallel(javascript, css);
```

## 任务（task）完成通知

当从任务（task）中返回 stream、promise、event emitter、child process 或 observable 时，成功或错误值将通知 gulp 是否继续执行或结束。如果任务（task）出错，gulp 将立即结束执行并显示该错误。

当使用 `series()` 组合多个任务（task）时，任何一个任务（task）的错误将导致整个任务组合结束，并且不会进一步执行其他任务。当使用 `parallel()` 组合多个任务（task）时，一个任务的错误将结束整个任务组合的结束，但是其他并行的任务（task）可能会执行完，也可能没有执行完。

### 返回 stream[​](https://www.gulpjs.com.cn/docs/getting-started/async-completion#%E8%BF%94%E5%9B%9E-stream "Direct link to 返回 stream")

```JavaScript
const { src, dest } = require('gulp');

function streamTask() {
  return src('*.js')
    .pipe(dest('output'));
}

exports.default = streamTask;
```

### 返回 promise[​](https://www.gulpjs.com.cn/docs/getting-started/async-completion#%E8%BF%94%E5%9B%9E-promise "Direct link to 返回 promise")

```JavaScript
function promiseTask() {
  return Promise.resolve('the value is ignored');
}

exports.default = promiseTask;
```

### 返回 event emitter[​](https://www.gulpjs.com.cn/docs/getting-started/async-completion#%E8%BF%94%E5%9B%9E-event-emitter "Direct link to 返回 event emitter")

```JavaScript
const { EventEmitter } = require('events');

function eventEmitterTask() {
  const emitter = new EventEmitter();
  // Emit has to happen async otherwise gulp isn't listening yet
  setTimeout(() => emitter.emit('finish'), 250);
  return emitter;
}

exports.default = eventEmitterTask;
```

### 返回 child process[​](https://www.gulpjs.com.cn/docs/getting-started/async-completion#%E8%BF%94%E5%9B%9E-child-process "Direct link to 返回 child process")

```JavaScript
const { exec } = require('child_process');

function childProcessTask() {
  return exec('date');
}

exports.default = childProcessTask;
```

### 返回 observable[​](https://www.gulpjs.com.cn/docs/getting-started/async-completion#%E8%BF%94%E5%9B%9E-observable "Direct link to 返回 observable")

```JavaScript
const { Observable } = require('rxjs');

function observableTask() {
  return Observable.of(1, 2, 3);
}

exports.default = observableTask;
```

### 使用 callback[​](https://www.gulpjs.com.cn/docs/getting-started/async-completion#%E4%BD%BF%E7%94%A8-callback "Direct link to 使用 callback")

如果任务（task）不返回任何内容，则必须使用 callback 来指示任务已完成。在如下示例中，callback 将作为唯一一个名为 `cb()` 的参数传递给你的任务（task）。

```JavaScript
function callbackTask(cb) {
  // `cb()` should be called by some async work
  cb();
}

exports.default = callbackTask;
```

如需通过 callback 把任务（task）中的错误告知 gulp，请将 `Error` 作为 callback 的唯一参数。

```JavaScript
function callbackError(cb) {
  // `cb()` should be called by some async work
  cb(new Error('kaboom'));
}

exports.default = callbackError;
```

然而，你通常会将此 callback 函数传递给另一个 API ，而不是自己调用它。

```JavaScript
const fs = require('fs');

function passingCallback(cb) {
  fs.access('gulpfile.js', cb);
}

exports.default = passingCallback;
```

## 使用 async/await解决异步

如果不使用前面提供到几种方式，你还可以将任务（task）定义为一个 ，它将利用 promise 对你的任务（task）进行包装。这将允许你使用 `await` 处理 promise，并使用其他同步代码。

```
const fs = require('fs');

async function asyncAwaitTask() {
  const { version } = JSON.parse(fs.readFileSync('package.json', 'utf8'));
  console.log(version);
  await Promise.resolve('some result');
}

exports.default = asyncAwaitTask;
```

---

---
url: /etc\rollup\src/core.md
---
# 核心概念

前面我们快速体验了一下rollup的打包流程,这里我们详细讲解一下rollup的核心概念

### input

* input：这是 Rollup 的入口文件路径，通常是一个 JavaScript 文件。Rollup 会从这个文件开始分析依赖关系并打包。

#### 单入口input配置

```JavaScript
export default {
  input: 'src/main.js', // 单个入口文件
  output: {
    file: 'bundle.js',
    format: 'cjs'
  }
};
```

#### 多入口input 配置

```JavaScript
export default {
  input: {
    main: 'src/main.js',
    vendor: 'src/vendor.js'
  },
  output: {
    dir: 'dist',
    format: 'cjs'
  }
};
```

**注意:**

* 路径问题：input 选项中的路径是相对于配置文件所在目录的。如果入口文件位于其他目录，需要正确指定相对路径或绝对路径。

* 动态导入：如果入口文件中使用了动态导入（如 import()），Rollup 会自动处理这些动态导入，并将它们作为单独的块进行打包。注意必须通过 output.dir 选项指定输出目录，而不是使用 out否则也会打成一个js文件

* 多入口打包：当配置多个入口文件时，Rollup 会为每个入口文件生成一个独立的输出文件。注意必须通过 output.dir 选项指定输出目录，而不是使用 out

### output

output：这个选项用于配置输出文件的路径、格式等。file 指定输出文件的路径，format 指定输出模块的格式，如 es（ES 模块）、cjs（CommonJS 模块）、iife（立即执行函数表达式）等。

```JavaScript
export default {
  input: 'src/main.js',
  output: {
    file: 'bundle.js',
    format: 'iife',
    name: 'MyBundle',
    sourcemap: true,
    globals: {
      jquery: '$'
    }
  }
};
```

#### `file`

选项用于指定输出文件的路径和名称。\
例如，file: 'dist/bundle.js' 会将打包后的文件输出到 `dist` 目录下，并命名为 bundle.js。

#### `format`

选项决定了输出模块的格式。常见的格式包括：

iife: 立即执行函数表达式，适用于浏览器环境。\
cjs: CommonJS 格式，适用于 Node.js 环境。\
es: ES 模块格式，适用于现代 JavaScript 环境。\
umd: 通用模块定义，兼容 AMD、CommonJS 和全局变量。

当 format 为 iife 或 umd 时，`name` 选项用于指定全局变量的名称。例如，name: 'MyBundle' 会将打包后的代码挂载到 `window.MyBundle` 上。

#### `sourcemap`

选项用于控制是否生成 sourcemap 文件。sourcemap 文件可以帮助开发者在调试时映射回原始源代码。设置为 `true` 时，Rollup 会生成一个 `.map` 文件。

除了 `output.sourcemap`，Rollup 还提供了其他一些与 Source Map 相关的选项，例如：

* `output.sourcemapFile`：指定生成的 Source Map 文件的名称。
* `output.sourcemapExcludeSources`：是否在 Source Map 中包含源代码内容。

#### `globals`

选项用于指定外部依赖的全局变量名称。例如，如果你在代码中使用了 jquery，并且希望它通过全局变量 `$` 来引用 。

举个例子
假设你正在开发一个浏览器端的 JavaScript 应用，并且你使用了 `lodash` 和 `jquery` 这两个库。你通过 `<script>` 标签在 HTML 文件中引入了这两个库，因此它们在全局环境中已经存在。在这种情况下，你可以使用 `globals` 选项来告诉 Rollup 如何引用这些全局变量。

```JavaScript
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';

export default {
  input: 'src/main.js',
  output: {
    file: 'bundle.js',
    format: 'iife',
    name: 'MyBundle',
    globals: {
      lodash: '_',
      jquery: '$'
    }
  },
  external: ['lodash', 'jquery'],
  plugins: [
    resolve(),
    commonjs()
  ]
};
```

#### `dir`

当输出多个文件时，指定输出目录。这个在分包时候是必须要使用的。
注意,dir和file不能同时出现,会报错的。
在输出文件的开头或结尾添加自定义内容。

```JavaScript
export default {
    input: 'src/main.js',
    output: {
        dir: 'dist',
        format: 'umd',
        name: 'MyBundle',
    }
};
```

#### `exports`

指定模块的导出方式，如 auto、default、named 等。

#### `banner/footer`

在输出文件的开头或结尾添加自定义内容。
这里需要注意@rollup/plugin-terser会把注释删掉,学习这个功能的时候注意要关闭terser

```JavaScript
export default {
    input: 'src/main.js',
    output: {
        file: 'dist/bundle.js',
        format: 'umd',
        name: 'MyBundle',
        banner: "/* AnLijun, Copyright (c) 2025. */"
    }
};
```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/0939d99b06e646cfb96d4695bc5e812e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737859432\&x-orig-sign=%2Fcq%2BE3xjLzmCy2MV0rk0pLPfiXM%3D)

#### `plugins`

Rollup 的插件系统非常强大，可以通过插件扩展 Rollup 的功能。常见的插件包括 resolve（解析模块路径）、commonjs（转换 CommonJS 模块）、babel（使用 Babel 进行代码转换）等。

这个后面重点说

#### `external`

这个选项用于指定哪些模块是外部依赖，不打包进输出文件。通常用于排除第三方库或 Node.js 内置模块。

`external` 选项用于告诉 Rollup 哪些模块不应该被打包到最终的输出文件中。这些模块通常是一些第三方库或 Node.js 内置模块，它们在运行时环境中已经存在，因此不需要被打包。

可以直接字符串数组配置

```
external: ['lodash', 'react']
```

在使用字符串数组时，模块名称必须与 `import` 或 `require` 语句中的名称完全匹配。
也可以使用函数配置

```
external: id => /lodash|react/.test(id)
```

使用函数可以更灵活地控制哪些模块被视为外部依赖，特别是当你需要根据模块路径或名称进行动态判断时。

### `watch`

这个选项用于配置 Rollup 的监听模式，当文件发生变化时自动重新打包。
注意:如果想要启动监听的话 命令为 rollup -c --watch
rollup 配置文件修改的时候不用重启

```JavaScript
export default {
    input: 'src/main.js',
    output: {
        file: 'dist/bundle.js',
        format: 'umd',
        name: 'MyBundle'
    },
    watch: {
        clearScreen: false
    }
};
```

在 Rollup 配置文件中，可以通过 `watch` 选项来启用和配置 watch 模式。以下是一些常用的配置选项：

* `include`：指定要监听的文件或目录，支持 glob 模式。
* `exclude`：指定要排除的文件或目录，支持 glob 模式。
* `chokidar`：如果设置为 `true`，Rollup 会使用 `chokidar` 库来监听文件变化，而不是 Node.js 自带的 `fs.watch`。

***

### 使用场景

Watch 模式非常适合在开发过程中使用，尤其是在以下场景中：

* **快速迭代**：当你在开发过程中频繁修改代码时，watch 模式可以自动重新构建项目，无需手动运行构建命令。
* **调试**：在调试过程中，watch 模式可以确保每次代码修改后都能立即看到效果，从而加快调试速度。
* **热更新**：结合一些开发服务器（如 `rollup-plugin-serve`），watch 模式可以实现热更新功能，即在代码修改后自动刷新浏览器页面。

### 注意事项

* **性能开销**：watch 模式会持续监听文件变化，因此会占用一定的系统资源。在大型项目中，可能会对性能产生一定影响。
* **文件锁定**：在某些操作系统上，文件监听可能会导致文件被锁定，从而影响其他进程对文件的访问。
* **兼容性**：不同操作系统对文件监听的实现方式不同，可能会导致一些兼容性问题。使用 `chokidar` 库可以提高跨平台的兼容性。

通过合理配置和使用 watch 模式，可以显著提高开发效率，减少手动操作，使开发过程更加流畅。

### 插件选项

* **`resolve`**：这个插件用于解析模块路径，确保 Rollup 能够正确找到依赖模块。
* **`commonjs`**：这个插件用于将 CommonJS 模块转换为 ES6 模块，以便 Rollup 能够正确处理。
* **`babel`**：这个插件用于使用 Babel 进行代码转换，通常用于将 ES6+ 代码转换为 ES5 代码。
* **`terser`**：这个插件用于代码压缩，通常用于生产环境。

```JavaScript
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';

export default {
  input: 'src/main.js',
  output: {
    file: 'bundle.js',
    format: 'cjs'
  },
  plugins: [
    resolve(),  // 解析 node_modules 中的模块
    commonjs(), // 将 CommonJS 模块转换为 ES6 模块
    babel({     // 使用 Babel 转换代码
      exclude: 'node_modules/**', // 排除 node_modules 目录
      presets: ['@babel/preset-env']
    })
  ]
};
```

#### 插件的配置

每个插件都可以接受一个配置对象作为参数。例如，`@rollup/plugin-babel` 插件可以配置 `exclude` 选项来排除某些文件或目录，以及 `presets` 选项来指定 Babel 的预设。

#### 插件的顺序

插件的顺序非常重要，因为它们会按照数组中的顺序依次执行。例如，通常需要先使用 `@rollup/plugin-node-resolve` 解析模块，然后再使用 `@rollup/plugin-commonjs` 转换模块格式。

### 高级选项

* **`treeshake`**：这个选项用于配置 Tree-shaking 的行为。Tree-shaking 是 Rollup 的一个重要特性，用于删除未使用的代码。
* **`context`**：这个选项用于指定模块的上下文，通常用于避免全局变量污染。
* **`moduleContext`**：这个选项用于为特定模块指定上下文，通常用于处理模块中的 `this` 指向问题。
* **`onwarn`**：这个选项用于自定义警告处理函数，可以用于过滤或处理 Rollup 发出的警告。

---

---
url: /etc\jest\src/install.md
---
## 三、安装与配置

### 3.1 环境要求

在安装 Jest 之前，确保你的开发环境满足以下要求：

* **Node.js**：Jest 是基于 Node.js 运行的，因此需要安装 Node.js 环境。建议使用 Node.js 的长期支持版本（LTS）。

- **npm 或 yarn**：用于安装 Jest 及其依赖包。

### 3.2 安装方式

* **全局安装**：通过 npm 或 yarn 全局安装 Jest，可以在任何项目中使用 Jest 命令。

```
npm install -g jest
# 或者
yarn global add jest
```

* **项目内安装**：在项目根目录下安装 Jest，将其作为开发依赖项。

```
npm install --save-dev jest
# 或者
yarn add --dev jest
```

### 3.3 配置文件

Jest 的配置文件通常为jest.config.js，位于项目根目录下。以下是一些常见的配置项：

* **testMatch**：指定测试文件的匹配模式，默认值为\["**/**tests**/**/*.js?(x)", "\*\*/?(*.)+(spec|test).js?(x)"]。

- **coveragePathIgnorePatterns**：指定哪些文件不生成测试覆盖率报告，例如\["/node\_modules/"]。

* **moduleNameMapper**：用于模块路径映射，例如将@/映射到项目的src/目录。

```
module.exports = {
    testMatch: ["**/*.test.js"],
    coveragePathIgnorePatterns: ["/node_modules/"],
    moduleNameMapper: {
        "^@/(.*)$": "<rootDir>/src/$1"
    }
};
```

### 3.4 自定义配置

除了上述常见配置项，Jest 还支持许多其他配置选项，如测试环境、测试脚本、模拟函数的配置等。开发者可以根据项目的具体需求进行自定义配置，以满足不同的测试场景。

## 四、基本使用

### 4.1 测试文件命名规则

Jest 默认会查找符合特定命名规则的测试文件，常见的命名规则为\[文件名].test.js或\[文件名].spec.js。例如，要测试math.js文件，可创建math.test.js或math.spec.js。

### 4.2 编写测试用例

* **测试函数**：使用test函数来定义一个测试用例，test函数接受两个参数：测试用例的描述和测试函数。

```javascript
test('adds 1 + 2 to equal 3', () => {
    // 测试逻辑
});
```

* **断言函数**：使用expect函数来进行断言，expect函数接受一个实际值，然后通过调用各种匹配器（如toBe、toEqual等）来判断实际值是否符合预期。

```
function add(a, b) {
    return a + b;
}
test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
});
```

### 4.3 运行测试

在项目根目录下，通过命令行运行测试：

```sh
npm test
# 或者
yarn test
```

如果安装了全局的 Jest，也可以直接运行jest命令。

---

---
url: /etc\jest\src/report.md
---
## 九、测试覆盖率

### 9.1 测试覆盖率的概念与意义

测试覆盖率是指测试代码对被测试代码的覆盖程度，它是衡量测试质量的一个重要指标。较高的测试覆盖率意味着更多的代码被测试到，从而降低了代码中存在未被发现的缺陷的风险。通过分析测试覆盖率报告，开发者可以了解哪些代码没有被充分测试，进而针对性地编写测试用例，提高测试的全面性和有效性。

### 9.2 Jest 的测试覆盖率工具

Jest 内置了测试覆盖率工具，通过--coverage参数可以生成测试覆盖率报告。在运行测试时，添加--coverage参数：

```sh
npm test -- --coverage
# 或者
yarn test -- --coverage
```

Jest 会在项目根目录下生成一个coverage目录，其中包含详细的测试覆盖率报告，包括 HTML 格式和文本格式的报告。

### 9.3 覆盖率报告解读

* **语句覆盖率**：表示被执行的语句占总语句数的比例。

- **分支覆盖率**：表示被执行的分支（如if-else语句、switch语句等）占总分支数的比例。

* **函数覆盖率**：表示被调用的函数占总函数数的比例。

- **行覆盖率**：表示被执行的代码行占总行数的比例。

### 9.4 提高测试覆盖率的方法

* **补充测试用例**：根据覆盖率报告，找出未被覆盖的代码部分，编写相应的测试用例。

- **优化测试策略**：合理设计测试用例，确保覆盖各种可能的输入和场景，避免测试用例的重复和冗余。

* **使用条件覆盖**：对于复杂的条件语句，使用条件覆盖策略，确保每个条件分支都被测试到。

---

---
url: /etc\rollup\src/withTs.md
---
# 集成Ts

1. 安装依赖

```
npm install rollup @rollup/plugin-typescript typescript tslib -D
```

* **`rollup`**：Rollup 的核心库。
* **`@rollup/plugin-typescript`**：Rollup 的 TypeScript 插件，用于处理 TypeScript 文件。
* **`typescript`**：TypeScript 编译器。
* **`tslib`**：TypeScript 运行时库，用于支持一些 TypeScript 特性。

2. 配置rollup

```javascript
// www.javascriptcn.com code example
import typescript from '@rollup/plugin-typescript';

export default {
  input: 'src/main.ts', // 入口文件
  output: {
    file: 'dist/bundle.js', // 输出文件
    format: 'cjs', // 输出格式
  },
  plugins: [
    typescript(), // 使用 TypeScript 插件
  ],
};
```

3. 配置 tsconfig.json
   在项目根目录下创建 `tsconfig.json` 文件，配置 TypeScript 编译选项：

```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "declaration": true
  },
  "include": ["src/**/*"]
}
```

* **`tsconfig.json`**：TypeScript 的配置文件，用于指定编译选项。

  * **`target`**：指定编译后的 JavaScript 版本。
  * **`module`**：指定模块系统。
  * **`strict`**：启用所有严格类型检查选项。
  * **`outDir`**：指定输出目录。
  * **`declaration`**：生成 `.d.ts` 类型声明文件。

---

---
url: /etc\gulp\src/introduce.md
---
![image.png](/assets/gulp.png)

# 介绍

Gulp 是一款基于 Node.js 的自动化构建工具，在前端开发中应用广泛，以下是关于它的详细介绍：

### 特点

* **任务驱动**：Gulp 基于任务流的概念，允许开发者将复杂的构建过程拆分成多个简单的任务，每个任务负责完成一项具体的工作，如文件压缩、代码编译、文件合并等。通过定义不同的任务，并指定它们之间的依赖关系，Gulp 可以按照预定的顺序自动执行这些任务，实现整个项目的自动化构建。
* **流操作**：Gulp 利用 Node.js 的流（Stream）概念来处理文件。它可以将文件以流的形式读取进来，在流的管道中对文件进行各种操作，如转换、过滤、合并等，最后再将处理后的文件以流的形式输出到指定位置。这种基于流的操作方式使得 Gulp 在处理大文件时非常高效，能够减少内存占用，提高构建速度。
* **插件丰富**：Gulp 拥有大量的插件，这些插件可以满足各种不同的构建需求。例如，通过`gulp-sass`插件可以将 Sass 文件编译成 CSS 文件，使用`gulp-uglify`插件可以压缩 JavaScript 代码，`gulp-imagemin`插件用于优化图片等。开发者可以根据项目的具体需求选择合适的插件，轻松扩展 Gulp 的功能。
* **易于使用**：Gulp 的 API 非常简洁，易于学习和使用。开发者只需要在项目中安装 Gulp 及相关插件，然后在`gulpfile.js`文件中定义任务和配置选项，就可以快速搭建起自动化构建流程。而且，Gulp 的命令行工具也很简单，通过在命令行中输入相应的命令就可以执行定义好的任务。

### 工作原理

* **读取文件**：Gulp 首先通过文件系统（FS）模块读取项目中的源文件，这些文件可以是 HTML、CSS、JavaScript、图片等各种类型的资源。
* **转换操作**：读取进来的文件会以流的形式进入 Gulp 的操作管道，在管道中可以通过各种插件对文件进行转换操作。这些操作可以是编译、压缩、合并、语法检查等。
* **输出文件**：经过一系列的转换操作后，文件最终会以流的形式输出到指定的目标位置，通常是项目的发布目录或其他指定的文件夹。在输出过程中，Gulp 会根据配置选项来确定输出文件的名称、路径和格式等。

### 应用场景

* **代码编译**：可以将 TypeScript、CoffeeScript 等编程语言编写的代码编译成浏览器能够直接识别的 JavaScript 代码，也能将 Sass、Less 等预处理器编写的样式代码编译成 CSS。
* **文件压缩**：在项目发布前，Gulp 可以对 JavaScript、CSS、图片等文件进行压缩，减小文件体积，提高网站的加载速度。例如，压缩 JavaScript 文件可以去除不必要的空格、注释等，压缩图片可以降低图片的分辨率、优化图片格式等。
* **代码检查**：利用 Gulp 可以在开发过程中对代码进行语法检查和代码规范检查，如使用 ESLint 对 JavaScript 代码进行语法和风格检查，确保代码的质量和一致性，帮助开发者及时发现和纠正代码中的错误和不规范之处。
* **浏览器自动刷新**：在开发过程中，Gulp 可以实现浏览器自动刷新功能，当代码发生变化时，自动刷新浏览器，实时显示代码的修改效果，提高开发效率。

---

---
url: /etc\rollup\src/introduce.md
---
![image.png](/assets/rollup.png)

# 介绍

## 什么是Rollup

Rollup 是一个 JavaScript 模块打包器，它可以将多个小的 JavaScript 模块打包成一个大的模块，用于在浏览器或者 Node.js 环境中使用。它的主要目标是尽可能高效地构建 JavaScript 库。

## webpack与rollup的区别

与`Webpack`偏向于应用打包的定位不同，`rollup.js`更专注于`Javascript`类库打包。
我们熟知的`Vue`、`React`等诸多知名框架或类库都是通过`rollup.js`进行打包的。所以说学习rollup不是一件重复的类库学习,不仅可以学习怎么搭建自己的函数/组件库,也可能更好的学会[vite](https://cn.vitejs.dev/guide/)可见学好这一个库能达到一箭双雕的目的。

## rollup的优点

1. **Tree Shaking**：Rollup 通过静态分析代码，自动移除未使用的代码（dead code），从而生成更小的打包文件。
2. **ES Module 支持**：Rollup 默认支持 ES Module 语法，能够将多个 ES Module 打包成一个文件。
3. **代码分割**：Rollup 支持代码分割，允许将代码拆分成多个 chunk，按需加载。
4. **插件系统**：Rollup 拥有丰富的插件生态系统，可以通过插件扩展其功能，如处理 CSS、TypeScript 等。
5. **输出格式多样**：Rollup 支持多种输出格式，包括 ES Module、CommonJS、UMD 等，适用于不同的使用场景。
6. **高性能**：Rollup 的打包速度较快，尤其是在处理大型项目时，性能表现优异。

---

---
url: /etc\vitepress\src/introduce.md
---
![image.png](/assets/vitepress.png)

# 介绍

VitePress 是一个[静态站点生成器](https://en.wikipedia.org/wiki/Static_site_generator) (SSG)，专为构建快速、以内容为中心的站点而设计。

**核心架构**

VitePress 的架构精妙地融合了几个关键技术：

* **Vite**：作为现代前端开发和构建工具，Vite 提供了极快的服务器启动和热模块替换（HMR）。
* **Vue.js**：用于创建互动式 UI 和前端动态内容。Vue 的组件系统允许你以模块化的方式构建页面。
* **Markdown**：所有的内容都是用 Markdown 编写的，这使得内容创作变得简单而直观。Markdown 文件可以轻松转换成 HTML，同时支持 Vue 组件，让你可以在文档中嵌入动态内容。

**主要特点**

* **速度与效率**：VitePress 的最大卖点之一是其出色的性能。使用 Vite 作为底层工具，它实现了极快的页面加载和热更新，大大提高了开发效率。
* **SEO 友好**：虽然是一个单页面应用（SPA）生成器，但 VitePress 生成的页面是 SEO 友好的。它在构建时生成静态 HTML，确保了内容的可索引性。
* **静态资源处理**：VitePress 提供了先进的静态资源处理能力，包括图片、样式表和 JavaScript 文件的优化。这意味着你可以轻松管理和部署资源，确保网站的快速加载。
* **易于定制和扩展**：VitePress 的架构设计允许你轻松定制主题和扩展功能。你可以使用 Vue 组件和 Vite 插件来增强你的站点，无论是添加自定义功能还是改进用户界面。

---

---
url: /etc\rollup\src/advance.md
---
# 进阶

一些打包插件列表
[GitHub - rollup/awesome: ⚡️ Delightful Rollup Plugins, Packages, and Resources](https://github.com/rollup/awesome)

## 导入Json (@rollup/plugin-json)

默认情况下rollup.js不支持导入json模块,但是实际上可能我们又需要怎么办。

这里我们可以用插件进行处理。

1. 首先搭建一个基础rollup工程
2. 安装插件 **npm i @rollup/plugin-json -D**
3. 配置插件

```js
export default {
    input:'src/index.js', //函数入口文件地址
    output:{
        file:'./dist/bundle.js', //打包地址
        format:'cjs', //格式化方式(模块化)
    },
    plugins: [json()] // 可以导入使用json数据
}

```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/f81f9d2722d34069ac9096afecf2a858~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=pY9qsPPyjsozZS7pw72AVYtd%2Be4%3D)
4\. 打包并检查打包产物

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/47e0b4cc09414069afd2a9472bb07e53~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=lNi71CKMdJ3MF5ygKzKvMexBtzs%3D)
这里可以看到构建出来的产物中并没有把整个package.json打包进来而是直接打包了version 这一个变量,这就是Rollup 默认支持 的[Tree-Shaking](https://juejin.cn/post/7030727223602905119)。
注意 如果使用的如果是CommonJs规范。由于 CommonJS 模块是动态加载的，Rollup 无法在编译时确定哪些代码会被使用，因此无法对 CommonJS 模块进行 Tree Shaking 优化。

## 代码压缩 (@rollup/plugin-terser)

前面我们把代码已经打包出来了但是这样的代码上面的产物还不够好,一方面额外的空格换行可能引起网络传输量变大,另一方面明文的代码也不够安全。
这里我们可以用插件进行压缩处理。

1. 首先搭建一个基础rollup工程
2. 安装插件 **npm i @rollup/plugin-terser -D**
3. 配置插件

```js
export default {
    input:'src/index.js', //函数入口文件地址
    output:{
        file:'./dist/bundle.js', //打包地址
        format:'cjs', //格式化方式(模块化)
        plugins: [terser()] //对产物进行压缩
    },
    plugins: [json()] // 可以导入使用json数据
}

```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/efec65cb19fc4a5686774fb235cb1843~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=2K24khEKA035pYGNL9Ak8oKH7rQ%3D)
4\. 打包并检查打包产物

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/e4e534ab53a54540a6c82b3d5bc41f51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=JA%2BI5qAAGs%2BrBk6jY9T05VjLYWU%3D)
可以看到这里我们的产物基本上与我们经常看到的npm 库类似了。

terser 的配置项
[GitCode - 全球开发者的开源社区,开源代码托管平台](https://gitcode.com/gh_mirrors/te/terser?utm_source=csdn_github_accelerator)

## 分析打包结果 rollup-plugin-visualizer

`rollup-plugin-visualizer` 是一个用于分析 Rollup 打包结果的插件。它能够生成一个可视化的报告，帮助开发者了解打包后文件的体积分布、模块依赖关系等信息。这对于优化打包体积和性能非常有帮助。
npm i rollup-plugin-visualizer

```JavaScript
import { visualizer } from 'rollup-plugin-visualizer';
export default {
  input: 'src/main.js',
  output: {
    file: 'bundle.js',
    format: 'cjs'
  },
  plugins: [
    visualizer({
      filename: 'stats.html', // 生成的分析文件名称
      open: true, // 是否在生成后自动打开浏览器
      template: 'treemap', // 可视化模板，可选 'sunburst', 'network', 'treemap', 'raw-data'
      gzipSize: true, // 是否显示 gzip 压缩后的大小
      brotliSize: true // 是否显示 brotli 压缩后的大小
    })
  ]
};
```

配置项

* `filename`: 生成的分析文件名称，默认为 `stats.html`。
* `open`: 是否在生成后自动打开浏览器，默认为 `false`。
* `template`: 可视化模板，可选 `'sunburst'`, `'network'`, `'treemap'`, `'raw-data'`，默认为 `'treemap'`。
* `gzipSize`: 是否显示 gzip 压缩后的大小，默认为 `false`。
* `brotliSize`: 是否显示 brotli 压缩后的大小，默认为 `false`。

使用场景

* **优化打包体积**：通过分析打包结果，找出体积较大的模块，进行优化或拆分。
* **模块依赖分析**：了解模块之间的依赖关系，优化模块结构。
* **性能优化**：通过分析 gzip 和 brotli 压缩后的体积，进一步优化加载性能。

注意事项

* 生成的 `stats.html` 文件通常较大，建议在开发环境中使用，避免在生产环境中生成。
* 如果项目使用了代码分割（Code Splitting），插件可以很好地展示各个 chunk 的体积和依赖关系。

## 打包css **rollup-plugin-postcss**

1. 首先搭建一个基础rollup工程
2. 安装插件 **npm i rollup-plugin-postcss -D**
3. 添加配置,并在文件中使用css

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/537bdb01cb124f4b927b8f5c29857ff0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=XOn1efwzAwxiqQdIYb2Ed6t%2BTJk%3D)
4\. 查看构建产物

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/d888f14101ab4fc394dab52aa9ea4578~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=JHXaOPQ9n%2BGt756oADyhcMSQBbM%3D)

* `extract: true`：将 CSS 提取到单独的文件中。如果设置为 `false`，CSS 将被嵌入到 JavaScript 文件中。
* `minimize: true`：压缩 CSS 文件。
* `plugins: []`：指定要使用的 PostCSS 插件。

## 代码分割

* Rollup 默认情况下不会自动分割代码。它主要是将项目中的所有模块打包成一个单一的文件。这种方式在构建小型项目或者库时非常有用，因为它可以保持模块的依赖关系简单，并且生成的文件易于管理和部署。

### 使用import 函数分割代码

1. 首先搭建一个基础rollup工程
2. 增加一个util.js 并使用

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/e0bbf7ba8a7b42cfb81a3ce12afe4437~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=gNSIPeVMTPV%2Fs8EhKXEtroNmwcQ%3D)
3\. 修改配置文件

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/033d8042c7fa4544b13717586c9379b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=hlh%2BikCWV%2BZokUt556eA1q%2BtjGU%3D)
4\. build并查看产物
这里其实就已经分割成两个js了
![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/da950aa35e7d445d841d3d7afe2e7f8a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=OFS2gJHL6PgZaaQUPn9VsGBeZAU%3D)
注意 确保 Rollup 的输出格式设置为 `es` 或 `system`，因为这些格式支持代码分割。

**`@rollup/plugin-commonjs` 和 `@rollup/plugin-node-resolve`**：如果项目中使用了 CommonJS 模块或 Node.js 模块，需要安装并配置这些插件。

## 解析第三方路径以及配置文件扩展名

npm i  @rollup/plugin-node-resolve
rollup 解析第三方模块的路径。它能够自动查找并解析 node\_modules 中的模块，确保 Rollup 能够正确打包这些依赖。

```
import commonjs from '@rollup/plugin-commonjs';
import resolve from '@rollup/plugin-node-resolve';

export default {
  input: 'src/main.js',
  output: {
    dir: 'dist',
    format: 'es',
  },
  plugins: [resolve(), commonjs()],
};
```

```JavaScript
import { nodeResolve } from '@rollup/plugin-node-resolve';

  ...
  plugins: [
    nodeResolve({
      // 配置选项
      moduleDirectories: ['node_modules'], // 指定模块目录
      extensions: ['.js', '.json'], // 解析的文件扩展名
      preferBuiltins: true, // 优先使用Node.js内置模块
      browser: false, // 是否在浏览器环境中使用
      dedupe: ['lodash'], // 去重特定模块
      mainFields: ['module', 'main'], // 指定package.json中的字段顺序
      jail: '/my/project', // 限制模块解析的根目录
      only: ['some-module'], // 只解析指定的模块
      customResolveOptions: {
        // 自定义解析选项
        moduleDirectory: 'my_modules'
      }
    })
  ]
};
```

* 当项目依赖第三方模块时，使用该插件可以确保 Rollup 能够正确解析这些模块的路径。
* 在构建浏览器端应用时，可以通过 `browser` 选项优先使用浏览器兼容的模块版本。
* 在需要去重模块或限制模块解析范围时，可以使用 `dedupe` 和 `jail` 选项。

> **moduleDirectories**: 指定模块查找的目录，默认是 `['node_modules']`。\
> **extensions**: 指定解析的文件扩展名，默认是 `['.js', '.json', '.node']`。\
> **preferBuiltins**: 如果设置为 `true`，插件会优先使用 Node.js 内置模块而不是 `node_modules` 中的模块。\
> **browser**: 如果设置为 `true`，插件会优先使用 `browser` 字段指定的模块版本。\
> **dedupe**: 去重特定模块，避免重复打包。\
> **mainFields**: 指定 `package.json` 中的字段顺序，默认是 `['module', 'main']`。\
> **jail**: 限制模块解析的根目录，防止解析到项目外的模块。\
> **only**: 只解析指定的模块，其他模块将被忽略。\
> **customResolveOptions**: 自定义解析选项，可以指定模块目录等。

注意

* 如果项目中使用了 ES 模块和 CommonJS 模块混合的情况，确保 `mainFields` 配置正确。
* 在浏览器环境中使用时，注意 `browser` 选项的设置，以避免使用不兼容的模块版本。

## babel插件(语法降级)  @rollup/plugin-babel @babel/core @babel/preset-env

1. 安装依赖

```
npm install  @rollup/plugin-babel @babel/core @babel/preset-env -D
```

2\.  添加babel配置文件
在项目根目录下创建一个 `.babelrc` 文件，配置 Babel 的预设：

```
{
  "presets": ["@babel/preset-env"]
}
```

3\.  使用插件

在 `rollup.config.js` 中引入 `@rollup/plugin-babel` 插件，并将其添加到 `plugins` 数组中。`babelHelpers` 选项用于指定 Babel 辅助函数的处理方式，`bundled` 表示将辅助函数打包到输出文件中。`exclude` 选项用于排除 `node_modules` 目录下的文件，避免对第三方库进行不必要的转译。

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/b02abd815126485888a99b13f00cb304~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=u2SYlr6luTJg5pZb%2BlwcCa7GAOw%3D)

> **babelHelpers** |string | 定如何处理 Babel 辅助函数，可选项有 `'bundled'`、`'runtime'`、`'inline'`、`'external'`

当设置为 `'runtime'` 时，会使用 `@babel/plugin-transform-runtime` 来避免重复的辅助函数代码

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            babelHelpers: 'runtime'
        })
    ]
};
```

> **include**  | `string | string[] | RegExp | RegExp[]`。| 指定要包含在 Babel 处理范围内的文件，可使用文件路径、文件路径数组、正则表达式或正则表达式数组。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            include: 'src/**/*.js'
        })
    ]
};
```

> **exclude** | string | string\[] | RegExp | RegExp\[] | 指定要排除在 Babel 处理范围外的文件，可使用文件路径、文件路径数组、正则表达式或正则表达式数组。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({ // 这样可以防止 Babel 处理 `node_modules` 中的文件，避免不必要的处理和潜在的问题。
            exclude: 'node_modules/**'
        })
    ]
};
```

> **extensions** | \[ ]string |  描述：指定要处理的文件扩展名，默认为 `['.js', '.jsx', '.es6', '.es', '.mjs']`。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            extensions: ['.js', '.jsx', '.ts', '.tsx']
        })
    ]
};
```

注意 可将 `.ts` 和 `.tsx` 等扩展名添加到 Babel 的处理范围中

> **presets** | Array<> | Babel 预设，可使用 `@babel/preset-env` 等预设进行不同的转译。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            presets: [['@babel/preset-env', { targets: { node: 'current' } }]]
        })
    ]
};
```

> **plugins** | Array | Babel 插件，可使用 `@babel/plugin-proposal-class-properties` 等插件进行特定的语言特性转译。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            plugins: ['@babel/plugin-proposal-class-properties']
        })
    ]
};
```

> sourceMap |Boolean | 是否生成源映射，默认为 `false`。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            sourceMap: true //源映射可方便在开发过程中进行调试。
        })
    ]
};
```

> **compact** | boolean | 是否压缩输出代码，默认为 `false`。

```javascript
import babel from '@rollup/plugin-babel';
export default {
    plugins: [
        babel({
            compact: true
        })
    ]
};
```

## Cjs 转ESM @rollup/plugin-commonjs

npm i  @rollup/plugin-commonjs

```JavaScript
export default {
  ...
  plugins: [
    commonjs(),
  ],
};
```

**结合其他插件**：通常，`@rollup/plugin-commonjs` 会与其他插件一起使用，例如 `@rollup/plugin-node-resolve` 和 `@rollup/plugin-babel`。`@rollup/plugin-node-resolve` 用于解析 node\_modules 中的模块，而 `@rollup/plugin-babel` 用于使用 Babel 转换代码。

```javascript
import commonjs from '@rollup/plugin-commonjs';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import { babel } from '@rollup/plugin-babel';
export default {
  input: 'src/index.js',
  output: {
    file: 'dist/bundle.js',
    format: 'cjs',
  },
  plugins: [
    nodeResolve(), //路径解析
    commonjs(),    // cjs 转esm
    babel({ babelHelpers: 'bundled' }),// es6+ =>ES5
  ],
};
```

注意

* **顺序问题**：在配置 Rollup 插件时，插件的顺序非常重要。通常，`@rollup/plugin-node-resolve` 应该放在 `@rollup/plugin-commonjs` 之前，因为需要先解析模块路径，然后再进行 CommonJS 转换。
* **动态导入**：如果你在项目中使用动态导入（`import()`），`@rollup/plugin-commonjs` 可能无法正确处理这些动态导入的模块。在这种情况下，你可能需要手动调整配置或使用其他插件来处理这些模块。

## 结合ts @rollup/plugin-typescript

1. 安装依赖
   npm install @rollup/plugin-typescript typescript -D
2. 配置

```JavaScript
import typescript from '@rollup/plugin-typescript';

export default {
  input: 'src/index.ts', // 指定入口文件
  output: {
    file: 'dist/bundle.js', // 输出文件路径
    format: 'cjs' // 输出格式
  },
  plugins: [
    typescript() // 使用 TypeScript 插件
  ]
};
```

3. 配置tsOptions

```JavaScript
typescript({
  tsconfig: './tsconfig.json', // 指定 tsconfig 文件路径
  include: ['src/**/*.ts'], // 包含的文件
  exclude: ['node_modules/**'] // 排除的文件
})
```

## 构建Dts rollup-plugin-dts

1. 安装依赖 npm i rollup-plugin-dts
2. 使用

```JavaScript
// rollup.config.js
import dts from 'rollup-plugin-dts';

export default {
  input: './src/index.d.ts',
  output: [{
    file: './dist/index.d.ts',
    format: 'es'
  }],
  plugins: [dts()]
};
```

## 替换代码  @rollup/plugin-replace

1. 安装依赖 npm i @rollup/plugin-replace
2. 使用

```JavaScript
import replace from '@rollup/plugin-replace';

export default {
  input: 'src/main.js',
  output: {
    file: 'bundle.js',
    format: 'cjs'
  },
  plugins: [
    replace({
      'process.env.NODE_ENV': JSON.stringify('production'),
      __buildDate__: () => JSON.stringify(new Date()),
      __buildVersion__: '1.0.0'
    })
  ]
};

```

在 Rollup 配置文件中，通过 `replace` 函数来配置插件。`replace` 函数接受一个对象作为参数，对象的键值对表示需要替换的内容。

* **键**：表示需要替换的字符串或正则表达式。
* **值**：表示替换后的内容。可以是字符串、函数或对象。

注意

* **字符串替换**：如果替换的内容是字符串，确保使用 `JSON.stringify` 来避免语法错误。
* **函数替换**：如果替换的内容是函数，函数会在打包时执行，返回的值将作为替换内容。
* **正则表达式**：可以使用正则表达式来匹配更复杂的字符串模式。

```JavaScript
import filesize from 'rollup-plugin-filesize';
export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'cjs'
  },
  plugins: [
    filesize()
  ]
};
```

配置项

* `showMinifiedSize`: 是否显示压缩后的大小，默认为 `true`。
* `showGzippedSize`: 是否显示 Gzip 压缩后的大小，默认为 `true`。
* `showBrotliSize`: 是否显示 Brotli 压缩后的大小，默认为 `false`。
*

当你运行 Rollup 打包时，`rollup-plugin-filesize` 插件会在终端输出类似以下的信息：

```
dist/bundle.js: 1.23 KB (gzipped: 456 B)
```

## 打包大小 `rollup-plugin-filesize`

`rollup-plugin-filesize` 是一个 Rollup 插件，用于在打包过程中显示生成的文件大小信息。它可以帮助开发者了解打包后的文件大小，从而优化代码和资源。

1. 安装依赖 npm install rollup-plugin-filesize --save-dev

## copy文件插件  `rollup-plugin-copy`

可以在打包时候将文件进行copy

1. 安装 npm install rollup-plugin-copy -D
2. 配置

```javascript
import copy from 'rollup-plugin-copy';

export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'cjs'
  },
  plugins: [
    copy({
      targets: [
        { src: 'src/assets/*', dest: 'dist/assets' },
        { src: 'src/fonts/*', dest: 'dist/fonts' }
      ]
    })
  ]
};
```

`targets`，它是一个数组，每个元素都是一个对象，包含 `src` 和 `dest` 属性。

* `src`: 指定要复制的文件或文件夹路径，支持 glob 模式。
* `dest`: 指定文件或文件夹复制到的目标路径。

## scss  rollup-plugin-scss

1. 安装依赖 npm install rollup-plugin-scss -D
2. 配置

```javascript
import scss from 'rollup-plugin-scss';

export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'cjs'
  },
  plugins: [
    scss({
      output: 'dist/bundle.css',
      failOnError: true,
      outputStyle: 'compressed'
    })
  ]
};
```

配置项

* **output**: 指定生成的 CSS 文件的输出路径和文件名。例如，`output: 'dist/bundle.css'` 会将生成的 CSS 文件输出到 `dist` 目录下，并命名为 `bundle.css`。
* **failOnError**: 设置为 `true` 时，如果 SCSS 编译过程中出现错误，Rollup 构建会失败。默认为 `false`。
* **outputStyle**: 控制生成的 CSS 文件的压缩方式。例如，`outputStyle: 'compressed'` 会生成压缩后的 CSS 文件。其他可选值包括 `expanded`、`nested` 和 `compact`。

## postCss rollup-plugin-postcs  autoprefixer

rollup-plugin-postcs 可以优雅降级css
autoprefixer 可以帮助我们自动加浏览器前缀

1. 安装依赖 npm install rollup-plugin-postcss autoprefixer -D

```JavaScript
import postcss from 'rollup-plugin-postcss';
export default {
    input: 'src/index.js',
    output: {
        file: 'dist/bundle.js'
    },
    plugins: [
        postcss({
            // 配置选项
            plugins: [
                autoprefixer()
            ]
        })
    ]
};
```

* **extract**：
  * 类型：`boolean | string`。
  * 描述：是否提取 CSS 文件，若为 `true` 会根据输入文件名生成，也可以指定文件名。
  * 示例：
  ```javascript
  postcss({ extract: 'styles.css' })
  ```
* **plugins**：
  * 类型：`Array<Function>`。
  * 描述：PostCSS 插件数组，可添加 `autoprefixer`、`cssnano` 等。
* **modules**：
  * 类型：`boolean`。
  * 描述：是否启用 CSS 模块。
* **process**：
  * 类型：`Function`。
  * 描述：自定义处理函数，接收 `(css, map) => ({ code, map })` 作为参数，用于自定义 CSS 处理。
* **minimize**：
  * 类型：`boolean`。
  * 描述：是否压缩 CSS。
* **sourceMap**：
  * 类型：`boolean`。
  * 描述：是否生成源映射。
* **include**：
  * 类型：`string | RegExp | (string | RegExp)[]`。
  * 描述：包含哪些文件，可使用文件路径、正则表达式或数组。
* **exclude**：
  * 类型：`string | RegExp | (string | RegExp)[]`。
  * 描述：排除哪些文件，可使用文件路径、正则表达式或数组。
* **`plugins`**: 这是一个数组，用于指定要使用的 PostCSS 插件。例如，`autoprefixer` 可以自动为 CSS 添加浏览器前缀。
* **`extract`**: 如果设置为 `true`，插件会将 CSS 提取到一个单独的文件中，而不是将其内联到 JavaScript 文件中。
* **`minimize`**: 如果设置为 `true`，插件会压缩生成的 CSS 文件。

## 处理图片 @rollup/plugin-image

1. 安装依赖  npm i  @rollup/plugin-image -D
2. 进行配置

```javascript
import image from '@rollup/plugin-image';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';

export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'cjs',
  },
  plugins: [
    image(),
    nodeResolve(),
    commonjs(),
  ],
};
```

配置项

* **`image()`** : 这是 `@rollup/plugin-image` 插件的调用，它会自动处理项目中的图片文件。
* **`nodeResolve()`** : 这个插件用于解析模块路径，确保 Rollup 能够正确找到依赖的模块。
* **`commonjs()`** : 这个插件用于将 CommonJS 模块转换为 ES6 模块，以便 Rollup 能够处理。

使用场景

* **小图片**: 对于较小的图片，直接将其转换为 Base64 编码并嵌入到 JavaScript 文件中可以减少 HTTP 请求，提升页面加载速度。
* **大图片**: 对于较大的图片，建议使用 `@rollup/plugin-url` 插件，将图片文件输出到指定目录，并在代码中引用其路径。

npm i @rollup/plugin-url

```
import url from '@rollup/plugin-url';

export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'cjs',
  },
  plugins: [
    url({
      limit: 10 * 1024, // 10KB 以下的文件转换为 Base64
      include: ['**/*.png', '**/*.jpg'], // 只处理 PNG 和 JPG 文件
      emitFiles: true, // 将文件输出到指定目录
    }),
    nodeResolve(),
    commonjs(),
  ],
};
```

---

---
url: /etc\apiExtractor\src/quick.md
---
# 快速上手

注意这里默认已经配置好一个ts项目，这里我会使用tsc用于测试

1. 安装依赖

```
npm install  @microsoft/api-extractor -D
```

2. 创建模板配置文件
   以下命令将创建一个模板文件，其中显示所有设置及其默认值：`api-extractor.json`

```
 npx api-extractor init 
```

然后会多一个api-extractor.json, 这里由于给的json携带注释所以报错了。

如果觉得红色影响阅读
可以在vscode上方搜索 json with Comments,找到检索项后点击红色就消失了

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/088314a4f4fa40378fb9c96585989335~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738676231\&x-orig-sign=FtieBfgMmLIxMZqATPG3XEKxSjM%3D)

这里需要将 mainEntryPointFilePath 改为自己的入口dts

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a9389513480a41539b99d6da0667a7d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738676231\&x-orig-sign=KKF3TorHxHUkVm8dQH%2FSHD5%2Ffkc%3D)

将 tsconfigFilePath 设置为tsconfig.json

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/d33be8841b764b2999b190ee9b40c244~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738676231\&x-orig-sign=cemuKI96XgifW2wWg%2BIDwCI0uLU%3D)

创建一个ect文件夹
3\. 执行打包命令

```
   npx api-extractor run --local --verbose
```

这样就可以使用这个生成的json文件去生成api文档了，这篇不会教学怎么使用这个json生成md文件

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/9c075ad4d0264da192acbfa19c9a5fd2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738676231\&x-orig-sign=tfU%2BqHkqnnFJiptUxs9HzEKy2jA%3D)

---

---
url: /etc\gulp\src/quick.md
---
# 快速上手

```
npm install --global gulp-cli
npm install --save-dev gulp
```

## 创建 gulpfile 文件[​](https://www.gulpjs.com.cn/docs/getting-started/quick-start#%E5%88%9B%E5%BB%BA-gulpfile-%E6%96%87%E4%BB%B6 "Direct link to 创建 gulpfile 文件")

利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件，并在文件中输入以下内容：

```javascript
function defaultTask(cb) {
  // place code for your default task here
  cb();
}

exports.default = defaultTask
```

## 测试

在项目根目录下执行 gulp 命令：

```
gulp
```

如需运行多个任务（task），可以执行 `gulp <task> <othertask>`。

## 输出结果

默认任务（task）将执行，因为任务为空，因此没有实际动作。

---

---
url: /etc\rollup\src/quick.md
---
# 快速上手

## 开发环境与安装

node使用 **v16.14.0**\
rollup 版本 **v4.30.1**

首先全局安装rollup
npm install rollup --global
安装完毕后,这里可以在控制台执行rollup命令
注意: 因为没有传入参数，Rollup 会打印出使用说明。这和运行 `rollup --help`，或者 `rollup -h` 相同。

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/b84dd89495234e7c92ea7a7de56526bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737859432\&x-orig-sign=p0OMnMJYRMN4qXIkooht2ffF7nE%3D)

## rollup基础工程需要的目录结构

注意rollup 支持命令行界面（CLI）操作,但是这样命令会复杂到很难读懂,这里我更推荐使用配置文件式操作,所以这里关于命令的除了必要的都会一笔带过。

```
├── dist # 编译结果
├── package.json
└── src # 源码
    └── index.js
└── rollup.config.mjs # rollup配置文件
```

实际代码关系如下

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/c19ddfbe338049db8858eed453270ada~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737859432\&x-orig-sign=y9Y7Wa7v%2BMm2PLwK9IJPTVYhhKE%3D)

## 打包

此时我们就已经搭建好了一个简单的rollup工程\
使用命令 **rollup -c** 即可对函数进行打包\
怎么样是不是很简单
![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/07586ac7e191489ba62f2d933501f58d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737859432\&x-orig-sign=sLxYfitt0%2F3T6qpFzMqS2Yr%2BduY%3D)

## 修改打包命令

由于我们习惯了webpack 或者其它构建工具的打包方式,这里也是推荐使用package添加一个单一的构建脚本
如

```json
{
	"scripts": {
		"build": "rollup --config"
	}
}
```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/82be9f7b38ca4c7ca89580bd41a3e41f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737859432\&x-orig-sign=6jgAR1eY3OaIcSUZd3cbTg%2BZaaY%3D)
这样你和你的小伙伴就可以使用 npm run build进行打包了

---

---
url: /etc\vitepress\src/router.md
---
# 路由

## 根目录和源目录

### 根目录

项目根目录是 VitePress 将尝试寻找 `.vitepress` 特殊目录的地方。`.vitepress` 目录是 VitePress 配置文件、开发服务器缓存、构建输出和可选主题自定义代码的预留位置。

当从命令行运行 `vitepress dev` 或 `vitepress build` 时，VitePress 将使用当前工作目录作为项目根目录。要将子目录指定为根目录，需要将相对路径传递给命令。例如，如果 VitePress 项目位于 `./docs`，应该运行 `vitepress dev docs`：

```
    .
    ├─ docs                    # 项目根目录
    │  ├─ .vitepress           # 配置目录
    │  ├─ getting-started.md
    │  └─ index.md
    └─ ...
```

```sh
vitepress dev docs
```

这将导致以下源代码到 HTML 的映射：

```
docs/index.md            -->  /index.html (可以通过 / 访问)
docs/getting-started.md  -->  /getting-started.html
```

这通常用于项目中集成一个vitepress 文档

### 源目录

源目录是 Markdown 源文件所在的位置。默认情况下，它与项目根目录相同。但是，可以通过 [`srcDir`](https://vitepress.dev/zh/reference/site-config#srcdir) 配置选项对其进行配置。

`srcDir` 选项是相对于项目根目录解析的。例如，对于 `srcDir: 'src'`，文件结构将如下所示：

```
    .                          # 项目根目录
    ├─ .vitepress              # 配置目录
    └─ src                     # 源目录
       ├─ getting-started.md
       └─ index.md

```

生成的源代码到 HTML 的映射：

```javascript
    src/index.md            -->  //index.html (可以通过 / 访问)
    src/getting-started.md  -->  //getting-started.html
```

## 链接页面

在页面之间链接时，可以使用绝对路径和相对路径。请注意，虽然 `.md` 和 `.html` 扩展名都可以使用，但最佳做法是省略文件扩展名，以便 VitePress 可以根据配置生成最终的 URL。

```
[显示内容](./路径) 
```

### 链接到非 VitePress 页面

如果想链接到站点中不是由 VitePress 生成的页面，需要使用完整的 URL（在新选项卡中打开）或明确指定 target：

```
[Link to pure.html](/pure.html){target="_self"}
```

## 生成简洁的 URL

某些服务器或托管平台 (例如 Netlify、Vercel 或 GitHub Pages) 提供将 `/foo` 之类的 URL 映射到 `/foo.html` (如果存在) 的功能，而无需重定向：

* Netlify 和 GitHub Pages 是默认支持的。
* Vercel 需要在 [vercel.json 中启用 cleanUrls 选项](https://vercel.com/docs/concepts/projects/project-configuration#cleanurls)。

如果可以使用此功能，还可以启用 VitePress 自己的 [`cleanUrls`](https://vitepress.dev/zh/reference/site-config#cleanurls) 配置选项，以便：

* 页面之间的入站链接是在没有 `.html` 扩展名的情况下生成的。
* 如果当前路径以 `.html` 结尾，路由器将执行客户端重定向到无扩展路径。

## 路由重写

可以自定义源目录结构和生成页面之间的映射。当有一个复杂的项目结构时，它很有用。例如，假设有一个包含多个包的 monorepo，并且希望将文档与源文件一起放置，如下所示：

```javascript
    export default {
      rewrites: {
        'packages/pkg-a/src/pkg-a-docs.md': 'pkg-a/index.md',
        'packages/pkg-b/src/pkg-b-docs.md': 'pkg-b/index.md',
        'packages/:pkg/src/(.*)': ':pkg/index.md'
      }
    }
```

重写路径是使用 `path-to-regexp` 包编译的——请参阅其[文档](https://github.com/pillarjs/path-to-regexp#parameters)以获取更多语法。

例如

```JavaScript

  themeConfig: {
    // https://vitepress.dev/reference/default-theme-config
    nav: [
      { text: 'Home', link: '/' },
      { text: 'Examples', link: '/markdown-examples' }
    ],
    sidebar: [
      {
        text: 'Examples',
        items: [
          { text: 'Markdown Examples', link: '/markdown-examples' },
          { text: 'Runtime API Examples', link: '/api-examples' },
          { text: 'Runtime API Examples', link: '/dex.md' },
        ]
      },
    ],
    socialLinks: [
      { icon: 'github', link: 'https://github.com/vuejs/vitepress' }
    ]
  },
  rewrites: {
    'docs/aaa/i.md': 'dex.md'
  },
```

// 其实就是让路由看起来一致

## 路由参数

比如区分不同版本的文档(没看懂官网暂时省略)

---

---
url: /etc\vitepress\src/theme.md
---
# 默认主题

主题的配置都在 vitepress.config.js 的themeConfig中

```js
export default {
  lang: 'en-US',
  title: 'VitePress',
  description: 'Vite & Vue powered static site generator.',

  // 主题相关配置
  themeConfig: {
    logo: '/logo.svg',
    nav: [...],
    sidebar: { ... }
  }
}
```

## i18nRouting[​](https://vitepress.dev/zh/reference/default-theme-config#i18nrouting)

* 类型：`boolean`

将本地语言更改为 `zh` 会将 URL 从 `/foo`（或 `/en/foo/`）更改为 `/zh/foo`。可以通过将 `themeConfig.i18nRouting` 设置为 `false` 来禁用此行为。

## logo

导航栏上显示的 Logo，位于站点标题前。可以接受一个路径字符串，或者一个对象来设置在浅色/深色模式下不同的 Logo。

```ts
export default {
  themeConfig: {
    logo: '/logo.svg'
  }
}
```

```ts
type ThemeableImage =
  | string
  | { src: string; alt?: string }
  | { light: string; dark: string; alt?: string }
```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/8e079877d5dd4bf9a117b8a866458b9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738661916\&x-orig-sign=e7yQnnueyfwVysRyTK3awFCBYNQ%3D)

## siteTitle[​](https://vitepress.dev/zh/reference/default-theme-config#sitetitle)

* 类型：`string | false`

可以自定义此项以替换导航中的默认站点标题 (应用配置中的 `title`)。当设置为 `false` 时，导航中的标题将被禁用。这在当 `logo` 已经包含站点标题文本时很有用。

```ts
export default {
  themeConfig: {
    siteTitle: 'Hello World'
  }
}
```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/6dbf40820869415db3f008c83403b291~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738661916\&x-orig-sign=5OmS2CNdySCpw7wBWIitRP1b3%2FI%3D)

## nav 导航

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/d7e4b159f05043dd80625777854bf865~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738661916\&x-orig-sign=WV4%2B0ImkNoEdXFunTCj8pall2x8%3D)

`text` 是 nav 中显示的实际文本，而 `link` 是单击文本时将导航到的链接。对于链接，将路径设置为不带 `.md` 后缀的实际文件，并且始终以 `/` 开头。

导航链接也可以是下拉菜单。为此，请替换 `link` 选项，设置 `items` 数组。

```js

    export default {
      themeConfig: {
        nav: [
          { text: 'Guide', link: '/guide' },
          {
            text: 'Dropdown Menu',
            items: [
              { text: 'Item A', link: '/item-1' },
              { text: 'Item B', link: '/item-2' },
              { text: 'Item C', link: '/item-3' }
              {
                  // 该部分的标题 
                  text: 'Section A Title', 
                  items: [ 
                      { text: 'Section A Item A', link: '...' }, 
                      { text: 'Section B Item B', link: '...' } 
                  ]
              }
            ]
          }
        ]
      }
    }
```

### 自定义链接的路由匹配状态[​](https://vitepress.dev/zh/reference/default-theme-nav#customize-link-s-active-state)

当前页面位于匹配路径下时，导航菜单项将突出显示。如果想自定义要匹配的路径，请将 `activeMatch` 属性和正则表达式定义为字符串值。

```js

    export default {
      themeConfig: {
        nav: [
          // 当用户位于 `/config/` 路径时，该链接处于激活状态
          {
            text: 'Guide',
            link: '/guide',
            activeMatch: '/config/'
          }
        ]
      }
    }
```

### 自定义链接的“target”和“rel”属性[​](https://vitepress.dev/zh/reference/default-theme-nav#customize-link-s-target-and-rel-attributes)

默认情况下，VitePress 会根据链接是否为外部链接自动判断 `target` 和 `rel` 属性。但如果愿意，也可以自定义它们。

```js

    export default {
      themeConfig: {
        nav: [
          {
            text: 'Merchandise',
            link: 'https://www.thegithubshop.com/',
            target: '_self',
            rel: 'sponsored'
          }
        ]
      }
    }
```

在 HTML 中，`rel`属性是一个用于定义当前文档与链接目标之间关系的属性，它主要用于`<a>`、`<link>`等标签中，以下是其常见用法和取值介绍：

* **在`<a>`标签中的使用**

  * **`rel="noopener"`** ：当链接指向一个新的页面时，使用`noopener`可以防止新页面通过`window.opener`访问当前页面的`window`对象，增强安全性，减少潜在的安全风险。例如：`<a href="https://example.com" rel="noopener">链接文本</a>`。
  * **`rel="noreferrer"`** ：使用`noreferrer`时，浏览器在加载目标页面时不会发送`Referer`头部信息，这可以保护用户的隐私，避免泄露当前页面的来源信息。比如：`<a href="https://another-site.com" rel="noreferrer">另一个链接</a>`。
  * **`rel="nofollow"`** ：告知搜索引擎不要追踪该链接，通常用于防止垃圾链接或者用户生成内容中的链接影响网站的权重和排名。如：`<a href="https://spammy-site.com" rel="nofollow">垃圾链接示例</a>`。
  * **`rel="external"`** ：表示链接指向外部网站，用于向用户和搜索引擎明确链接的目标是在当前网站之外。例如：`<a href="https://outsidesite.com" rel="external">外部链接</a>`。

* **在`<link>`标签中的使用**

  * **`rel="stylesheet"`** ：用于链接外部样式表，告诉浏览器该链接指向的是一个 CSS 文件，用于为当前页面设置样式。例如：`<link rel="stylesheet" href="styles.css">`。
  * **`rel="icon"`** ：用于指定网站的图标，通常是一个小的图像文件，显示在浏览器的标签页、收藏夹等位置。比如：`<link rel="icon" href="favicon.ico">`。
  * **`rel="canonical"`** ：用于指定页面的规范版本，帮助搜索引擎确定页面的主要版本，避免重复内容问题。例如：`<link rel="canonical" href="https://www.example.com/correct-page">`。
  * **`rel="alternate"`** ：用于指定页面的替代版本，比如不同语言版本或不同格式的页面。例如：`<link rel="alternate" hreflang="en-US" href="https://example.com/en-us/page">`表示英语（美国）版本的页面。

* **其他可能的取值和用途**

  * **`rel="prev"`和`rel="next"`** ：用于表示页面之间的导航关系，`prev`表示上一页，`next`表示下一页，常用于分页导航。
  * **`rel="license"`** ：用于链接到网站或文档的版权声明或使用许可页面。
  * **`rel="tag"`** ：用于将当前文档与一个或多个标签相关联，类似于关键词，有助于分类和搜索。

你可以通过使用 `component` 选项在导航栏中包含自定义组件。`component` 键对应的值应为 Vue 组件名，并且必须使用 [Theme.enhanceApp](https://vitepress.dev/zh/guide/custom-theme#theme-interface) 全局注册。

### 自定义组件

```js
export default {
  themeConfig: {
    nav: [
      {
        text: 'My Menu',
        items: [
          {
            component: 'MyCustomComponent',
            // 可选的 props 传递给组件
            props: {
              title: 'My Custom Component'
            }
          }
        ]
      },
      {
        component: 'AnotherCustomComponent'
      }
    ]
  }
}
```

## sidebar

```js
export type Sidebar = SidebarItem[] | SidebarMulti

export interface SidebarMulti {
  [path: string]: SidebarItem[]
}

export type SidebarItem = {
  text?: string //侧边栏项的文本标签
  link?: string //侧边栏项的链接
  items?: SidebarItem[] //侧边栏项的子项
  collapsed?: boolean // 默认不可折叠  `true`，则侧边栏组可折叠并且默认折叠 `false`，则侧边栏组可折叠但默认展开
}

```

## `useSidebar` composable[​](https://vitepress.dev/zh/reference/default-theme-sidebar#usesidebar)

返回侧边栏相关数据。返回的对象具有以下类型：

```ts

    export interface DocSidebar {
      isOpen: Ref<boolean>
      sidebar: ComputedRef<DefaultTheme.SidebarItem[]>
      sidebarGroups: ComputedRef<DefaultTheme.SidebarItem[]>
      hasSidebar: ComputedRef<boolean>
      hasAside: ComputedRef<boolean>
      leftAside: ComputedRef<boolean>
      isSidebarEnabled: ComputedRef<boolean>
      open: () => void
      close: () => void
      toggle: () => void
    }
```

**示例：**

```vue

    <script setup>
    import { useSidebar } from 'vitepress/theme'

    const { hasSidebar } = useSidebar()
    </script>

    <template>
      <div v-if="hasSidebar">Only show when sidebar exists</div>
    </template>
```

## aside[​](https://vitepress.dev/zh/reference/default-theme-config#aside)

* 类型：`boolean | 'left'`
* 默认值：`true`
* 每个页面可以通过 [frontmatter](https://vitepress.dev/zh/reference/frontmatter-config#aside) 覆盖

将此值设置为 `false` 可禁用 aside 容器。\
将此值设置为 `true` 将在页面右侧渲染。\
将此值设置为 `left` 将在页面左侧渲染。

如果想对所有页面禁用它，应该使用 `outline: false`。

## outline[​](https://vitepress.dev/zh/reference/default-theme-config#outline)

* 类型：`Outline | Outline['level'] | false`
* 每个页面可以通过 [frontmatter](https://vitepress.dev/zh/reference/frontmatter-config#outline) 覆盖层级

是否禁用aside

将此值设置为 `false` 可禁止渲染大纲容器。更多详情请参考该接口：

```ts

    interface Outline {
      /**
       * outline 中要显示的标题级别。
       * 单个数字表示只显示该级别的标题。
       * 如果传递的是一个元组，第一个数字是最小级别，第二个数字是最大级别。
       * `'deep'` 与 `[2, 6]` 相同，将显示从 `<h2>` 到 `<h6>` 的所有标题。
       *
       * @default 2
       */
      level?: number | [number, number] | 'deep'

      /**
       * 显示在 outline 上的标题。
       *
       * @default 'On this page'
       */
      label?: string
    }
```

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a8da03c946f24c3e92872ac9169c15d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738661916\&x-orig-sign=XzJASuTc98CF%2FHpuTWAAGqcK%2BNs%3D)

## socialLinks[​](https://vitepress.dev/zh/reference/default-theme-config#sociallinks)

* 类型：`SocialLink[]`

可以定义此选项以在导航栏中展示带有图标的社交帐户链接。

```ts

    export default {
      themeConfig: {
        socialLinks: [
          { icon: 'github', link: 'https://github.com/vuejs/vitepress' },
          { icon: 'twitter', link: '...' },
          // 可以通过将 SVG 作为字符串传递来添加自定义图标：
          {
            icon: {
              svg: '<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Dribbble</title><path d="M12...6.38z"/></svg>'
            },
            link: '...',
            // 也可以为无障碍添加一个自定义标签 (可选但推荐):
            ariaLabel: 'cool link'
          }
        ]
      }
    }
```

```ts

    interface SocialLink {
      icon: string | { svg: string }
      link: string
      ariaLabel?: string
    }
```

## footer[​](https://vitepress.dev/zh/reference/default-theme-config#footer)

* 类型：`Footer`
* 可以通过 [frontmatter](https://vitepress.dev/zh/reference/frontmatter-config#footer) 进行覆盖。

页脚配置。可以添加 message 和 copyright。由于设计原因，仅当页面不包含侧边栏时才会显示页脚。

```ts

    export default {
      themeConfig: {
        footer: {
          message: 'Released under the MIT License.',
          copyright: 'Copyright © 2019-present Evan You'
        }
      }
    }
```

```ts

    export interface Footer {
      message?: string
      copyright?: string
    }
```

## footer

```js
    export interface Footer {
      // 版权前显示的信息
      message?: string

      // 实际的版权文本
      copyright?: string
    }
```

上面的配置也支持 HTML 字符串。所以，例如，如果想配置页脚文本有一些链接，可以调整配置如下：

```ts

    export default {
      themeConfig: {
        footer: {
          message: 'Released under the <a href="https://github.com/vuejs/vitepress/blob/main/LICENSE">MIT License</a>.',
          copyright: 'Copyright © 2019-present <a href="https://github.com/yyx990803">Evan You</a>'
        }
      }
    }
```

WARNING

只有内联元素可以在 `message` 和 `copyright` 中使用，因为它们渲染在 `<p>` 元素中。如果想添加块元素，请考虑使用 [`layout-bottom`](https://vitepress.dev/zh/guide/extending-default-theme#layout-slots) 插槽。

请注意，当[侧边栏](https://vitepress.dev/zh/reference/default-theme-sidebar)可见时，不会显示页脚。

## frontmatter 配置[​](https://vitepress.dev/zh/reference/default-theme-footer#frontmatter-config)

可以使用 frontmatter 上的 `footer` 选项在单独页面上禁用此功能：

```yaml

    ---
    footer: false
    ---
```

## editLink[​](https://vitepress.dev/zh/reference/default-theme-config#editlink)

* 类型：`EditLink`
* 每个页面可以通过 [frontmatter](https://vitepress.dev/zh/reference/frontmatter-config#editlink) 覆盖

编辑链接可让显示链接以编辑 Git 管理服务 (例如 GitHub 或 GitLab) 上的页面。有关详细信息，请参阅[默认主题：编辑链接](https://vitepress.dev/zh/reference/default-theme-edit-link)。

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/5fb475daedad4909b7077c905370de48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1738661916\&x-orig-sign=1c31WTxUD0ntI11iLocpOhjyGCQ%3D)

```ts

    export default {
      themeConfig: {
        editLink: {
          pattern: 'https://github.com/vuejs/vitepress/edit/main/docs/:path',
          text: 'Edit this page on GitHub'
        }
      }
    }
```

```ts

    export interface EditLink {
      pattern: string
      text?: string
    }
```

## lastUpdated[​](https://vitepress.dev/zh/reference/default-theme-config#lastupdated)

* 类型：`LastUpdatedOptions`

允许自定义上次更新的文本和日期格式。

```ts

    export default {
      themeConfig: {
        lastUpdated: {
          text: 'Updated at',
          formatOptions: {
            dateStyle: 'full',
            timeStyle: 'medium'
          }
        }
      }
    }
```

```ts

    export interface LastUpdatedOptions {
      /**
       * @default 'Last updated'
       */
      text?: string

      /**
       * @default
       * { dateStyle: 'short',  timeStyle: 'short' }
       */
      formatOptions?: Intl.DateTimeFormatOptions & { forceLocale?: boolean }
    }
```

## algolia[​](https://vitepress.dev/zh/reference/default-theme-config#algolia)

* 类型：`AlgoliaSearch`

支持使用 [Algolia DocSearch](https://docsearch.algolia.com/docs/what-is-docsearch) 搜索站点文档。在[默认主题：搜索](https://vitepress.dev/zh/reference/default-theme-search) 中了解更多信息。

```ts

    export interface AlgoliaSearchOptions extends DocSearchProps {
      locales?: Record<string, Partial<DocSearchProps>>
    }
```

在[这里](https://github.com/vuejs/vitepress/blob/main/types/docsearch.d.ts)查看完整配置。

## carbonAds[​](https://vitepress.dev/zh/reference/default-theme-config#carbon-ads)

[开源项目广告 |碳广告](https://www.carbonads.net/open-source)

* 类型：`CarbonAdsOptions`

一个配置即可展示 [Carbon Ads](https://www.carbonads.net/)。

```ts

    export default {
      themeConfig: {
        carbonAds: {
          code: 'your-carbon-code',
          placement: 'your-carbon-placement'
        }
      }
    }
```

```ts

    export interface CarbonAdsOptions {
      code: string
      placement: string
    }
```

在 [Default Theme: Carbon Ads](https://vitepress.dev/zh/reference/default-theme-carbon-ads) 中了解更多信息。

## docFooter[​](https://vitepress.dev/zh/reference/default-theme-config#docfooter)

* 类型：`DocFooter`

可用于自定义出现在上一页和下一页链接上方的文本。如果不是用英语编写文档，这很有帮助。也可用于全局禁用上一页/下一页链接。如果想有选择地启用/禁用上一个/下一个链接，可以使用 [frontmatter](https://vitepress.dev/zh/reference/default-theme-prev-next-links)。

```ts

    export default {
      themeConfig: {
        docFooter: {
          prev: '上一页',
          next: '下一页'
        }
      }
    }
```

```ts

    export interface DocFooter {
      prev?: string | false
      next?: string | false
    }
```

## darkModeSwitchLabel[​](https://vitepress.dev/zh/reference/default-theme-config#darkmodeswitchlabel)

* 类型：`string`
* 默认值：`Appearance`

用于自定义深色模式开关标签，该标签仅在移动端视图中显示。

## lightModeSwitchTitle[​](https://vitepress.dev/zh/reference/default-theme-config#lightmodeswitchtitle)

* 类型：`string`
* 默认值：`Switch to light theme`

用于自定义悬停时显示的浅色模式开关标题。

## darkModeSwitchTitle[​](https://vitepress.dev/zh/reference/default-theme-config#darkmodeswitchtitle)

* 类型：`string`
* 默认值：`Switch to dark theme`

用于自定义悬停时显示的深色模式开关标题。

## sidebarMenuLabel[​](https://vitepress.dev/zh/reference/default-theme-config#sidebarmenulabel)

* 类型：`string`
* 默认值：`Menu`

用于自定义侧边栏菜单标签，该标签仅在移动端视图中显示。

## sidebarMenuLabel[​](https://vitepress.dev/zh/reference/default-theme-config#sidebarmenulabel)

* 类型：`string`
* 默认值：`Menu`

用于自定义侧边栏菜单标签，该标签仅在移动端视图中显示。

## returnToTopLabel[​](https://vitepress.dev/zh/reference/default-theme-config#returntotoplabel)

* 类型：`string`
* 默认值：`Return to top`

用于自定义返回顶部按钮的标签，该标签仅在移动端视图中显示。

## langMenuLabel[​](https://vitepress.dev/zh/reference/default-theme-config#langmenulabel)

* 类型：`string`
* 默认值：`Change language`

用于自定义导航栏中语言切换按钮的 aria-label，仅当使用 [i18n](https://vitepress.dev/zh/guide/i18n) 时才使用此选项。

## externalLinkIcon[​](https://vitepress.dev/zh/reference/default-theme-config#externallinkicon)

* 类型：`boolean`
* 默认值：`false`

是否在 markdown 中的外部链接旁显示外部链接图标。

## 主页

### Hero 部分[​](https://vitepress.dev/zh/reference/default-theme-home-page#hero-section)

Hero 部分位于主页顶部。以下是配置 Hero 的方法。

```yaml
---
layout: home

hero:
  name: VitePress
  text: Vite & Vue powered static site generator.
  tagline: Lorem ipsum...
  image:
    src: /logo.png
    alt: VitePress
  actions:
    - theme: brand
      text: Get Started
      link: /guide/what-is-vitepress
    - theme: alt
      text: View on GitHub
      link: https://github.com/vuejs/vitepress
---
```

```ts

    interface Hero {
      // `text` 上方的字符，带有品牌颜色
      // 预计简短，例如产品名称
      name?: string

      // hero 部分的主要文字，
      // 被定义为 `h1` 标签
      text: string

      // `text` 下方的标语
      tagline?: string

      // text 和 tagline 区域旁的图片
      image?: ThemeableImage

      // 主页 hero 部分的操作按钮
      actions?: HeroAction[]
    }

    type ThemeableImage =
      | string
      | { src: string; alt?: string }
      | { light: string; dark: string; alt?: string }

    interface HeroAction {
      // 按钮的颜色主题，默认为 `brand`
      theme?: 'brand' | 'alt'

      // 按钮的标签
      text: string

      // 按钮的目标链接
      link: string

      // 链接的 target 属性
      target?: string

      // 链接的 rel 属性
      rel?: string
    }
```

### 自定义 name 的颜色[​](https://vitepress.dev/zh/reference/default-theme-home-page#customizing-the-name-color)

VitePress 通过 (`--vp-c-brand-1`) 设置 `name` 的颜色。但是，可以通过覆盖 `--vp-home-hero-name-color` 变量来自定义此颜色。

```css

    :root {
      --vp-home-hero-name-color: blue;
    }
```

也可以通过组合 `--vp-home-hero-name-background` 来进一步自定义 `name` 为渐变色。

```css

    :root {
      --vp-home-hero-name-color: transparent;
      --vp-home-hero-name-background: -webkit-linear-gradient(120deg, #bd34fe, #41d1ff);
    }
```

## Features 部分[​](https://vitepress.dev/zh/reference/default-theme-home-page#features-section)

在 Features 部分，可以在 Hero 部分之后列出任意数量的 Feature。可以在 frontmatter 中配置 `features`。

可以为每个 feature 提供一个图标，可以是表情符号或任何类型的图像。当配置的图标是图片（svg, png, jpeg...）时，必须提供合适的宽度和高度的图标；还可以在需要时配置其描述、固有大小以及深色和浅色主题下的不同表现。

```yaml

    ---
    layout: home

    features:
      - icon: 🛠️
        title: Simple and minimal, always
        details: Lorem ipsum...
      - icon:
          src: /cool-feature-icon.svg
        title: Another cool feature
        details: Lorem ipsum...
      - icon:
          dark: /dark-feature-icon.svg
          light: /light-feature-icon.svg
        title: Another cool feature
        details: Lorem ipsum...
    ---
```

```ts

    interface Feature {
      // 在每个 feature 框中显示图标
      icon?: FeatureIcon

      // feature 的标题
      title: string

      // feature 的详情
      details: string

      // 点击 feature 组件时的链接，可以是内部链接，也可以是外部链接。
      //
      //
      // 例如 `guide/reference/default-theme-home-page` 或 `https://example.com`
      link?: string

      // feature 组件内显示的链接文本，最好与 `link` 选项一起使用
      //
      //
      // 例如 `Learn more`, `Visit page` 等
      linkText?: string

      // `link` 选项的链接 rel 属性
      //
      // 例如 `external`
      rel?: string

      // `link` 选项的链接 target 属性
      target?: string
    }

    type FeatureIcon =
      | string
      | { src: string; alt?: string; width?: string; height: string }
      | {
          light: string
          dark: string
          alt?: string
          width?: string
          height: string
        }
```

## 布局[​](https://vitepress.dev/zh/reference/default-theme-layout#layout)

可以通过设置页面 [frontmatter](https://vitepress.dev/zh/reference/frontmatter-config) 选项来选择页面布局。有 3 种布局选项 `doc`、`page` 和 `home`。如果未指定任何内容，则该页面将被视为 `doc` 页面。

`doc` 是默认布局，它将整个 Markdown 内容设置为“documentation”外观。它的工作原理是将整个内容包装在 css `vp-doc` 类中，并将样式应用于它下面的元素。

几乎所有通用元素，例如 `p`, 或 `h2` 都有特殊的样式。因此，请记住，如果在 Markdown 内容中添加任何自定义 HTML，这些内容也会受到这些样式的影响。

它还提供下面列出的文档特定功能。这些功能仅在此布局中启用。

* [编辑链接](https://vitepress.dev/zh/reference/default-theme-edit-link)
* [上下页链接](https://vitepress.dev/zh/reference/default-theme-prev-next-links)
* [大纲](https://vitepress.dev/zh/reference/default-theme-config#outline)
* [Carbon Ads](https://vitepress.dev/zh/reference/default-theme-carbon-ads)

## page 布局[​](https://vitepress.dev/zh/reference/default-theme-layout#page-layout)

`page` 被视为“空白页”。Markdown 仍然会被解析，所有的 [Markdown 扩展](https://vitepress.dev/zh/guide/markdown) 都和 `doc` 布局一样运行，但它没有任何默认样式。

`page` 布局将使可以自行设计所有内容，而不会受 VitePress 主题影响。当想要创建自己的自定义页面时，这很有用。

请注意，即使在此布局中，如果页面具有匹配的侧边栏配置，侧边栏仍会显示。

## home 布局[​](https://vitepress.dev/zh/reference/default-theme-layout#home-layout)

`home` 将生成模板化的“主页”。在此布局中，可以设置额外的选项，例如 `hero` 和 `features` 以进一步自定义内容。请访问[默认主题: 主页](https://vitepress.dev/zh/reference/default-theme-home-page)了解更多详情。

## 无布局[​](https://vitepress.dev/zh/reference/default-theme-layout#no-layout)

如果不想要任何布局，可以通过 frontmatter 传递 `layout: false`。如果想要一个完全可自定义的登录页面（默认情况下没有任何侧边栏、导航栏或页脚），此选项很有用。

## 自定义布局[​](https://vitepress.dev/zh/reference/default-theme-layout#custom-layout)

也可以使用自定义布局：

```md

    ---
    layout: foo
    ---
```

这将在上下文中查找注册名为 `foo` 的组件。例如，可以在 `.vitepress/theme/index.ts`中全局注册组件：

```ts

    import DefaultTheme from 'vitepress/theme'
    import Foo from './Foo.vue'

    export default {
      extends: DefaultTheme,
      enhanceApp({ app }) {
        app.component('foo', Foo)
      }
    }
```

## 徽标

## 用法[​](https://vitepress.dev/zh/reference/default-theme-badge#usage)

可以使用全局组件 `Badge` 。

html

```
### Title <Badge type="info" text="default" />
### Title <Badge type="tip" text="^1.9.0" />
### Title <Badge type="warning" text="beta" />
### Title <Badge type="danger" text="caution" />
```

## 自定义不同类型徽标的背景色[​](https://vitepress.dev/zh/reference/default-theme-badge#customize-type-color)

可以通过覆盖 css 来自定义不同类型 `<Badge />` 的样式。以下是默认值。

```css

    :root {
      --vp-badge-info-border: transparent;
      --vp-badge-info-text: var(--vp-c-text-2);
      --vp-badge-info-bg: var(--vp-c-default-soft);

      --vp-badge-tip-border: transparent;
      --vp-badge-tip-text: var(--vp-c-brand-1);
      --vp-badge-tip-bg: var(--vp-c-brand-soft);

      --vp-badge-warning-border: transparent;
      --vp-badge-warning-text: var(--vp-c-warning-1);
      --vp-badge-warning-bg: var(--vp-c-warning-soft);

      --vp-badge-danger-border: transparent;
      --vp-badge-danger-text: var(--vp-c-danger-1);
      --vp-badge-danger-bg: var(--vp-c-danger-soft);
    }
```

## `<Badge>`[​](https://vitepress.dev/zh/reference/default-theme-badge#badge-1)

`<Badge>` 组件接受以下属性：

```ts

    interface Props {
      // 当传递 `<slot>` 时，该值将被忽略
      text?: string

      // 默认为 `tip`.
      type?: 'info' | 'tip' | 'warning' | 'danger'
    }
```

## 团队页

## 在页面中显示团队成员[​](https://vitepress.dev/zh/reference/default-theme-team-page#show-team-members-in-a-page)

你可以在任何页面上使用从 `vitepress/theme` 暴露出的公共组件 `<VPTeamMembers>` 显示团队成员。

html

```
<script setup>
import { VPTeamMembers } from 'vitepress/theme'

const members = [
  {
    avatar: 'https://www.github.com/yyx990803.png',
    name: 'Evan You',
    title: 'Creator',
    links: [
      { icon: 'github', link: 'https://github.com/yyx990803' },
      { icon: 'twitter', link: 'https://twitter.com/youyuxi' }
    ]
  },
  ...
]
</script>

# Our Team

Say hello to our awesome team.

<VPTeamMembers size="small" :members="members" />
```

## 最后更新于[​](https://vitepress.dev/zh/reference/default-theme-last-updated#site-level-config)

```js

    export default {
      lastUpdated: true
    }
```

---

---
url: /etc\gulp\src/usePlugin.md
---
# 使用插件

Gulp 插件实质上是 [Node 转换流（Transform Streams）](https://github.com/rvagg/through2)，它封装了通过管道（pipeline）转换文件的常见功能，通常是使用 `.pipe()` 方法并放在 `src()` 和 `dest()` 之间。他们可以更改经过流（stream）的每个文件的文件名、元数据或文件内容。

托管在 npm 上的插件 - 标记有 "gulpplugin" 和 "gulpfriendly" 关键词 - 可以在 [插件搜索页面](https://gulpjs.com/plugins/) 上浏览和搜索。

每个插件应当只完成必要的工作，因此你可以把它们像构建块一样连接在一起。获得想要的结果可能需要把一组插件组合在一起使用。

```
const { src, dest } = require('gulp');
const uglify = require('gulp-uglify');
const rename = require('gulp-rename');

exports.default = function() {
  return src('src/*.js')
    // gulp-uglify 插件并不改变文件名
    .pipe(uglify())
    // 因此使用 gulp-rename 插件修改文件的扩展名
    .pipe(rename({ extname: '.min.js' }))
    .pipe(dest('output/'));
}
```

## 是否需要插件？[​](https://www.gulpjs.com.cn/docs/getting-started/using-plugins#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%8F%92%E4%BB%B6 "Direct link to 是否需要插件？")

并非 gulp 中的一切都需要用插件来完成。虽然它们是一种快速上手的方法，但许多操作都应当通过使用独立的功能模块或库来实现。

```JavaScript
const { rollup } = require('rollup');

// Rollup 提供了基于 promise 的 API，在 `async` 任务（task）中工作的很好
exports.default = async function() {
  const bundle = await rollup({
    input: 'src/index.js'
  });

  return bundle.write({
    file: 'output/bundle.js',
    format: 'iife'
  });
}
```

插件应当总是用来转换文件的。其他操作都应该使用（非插件的） Node 模块或库来实现。

```JavaScript
const del = require('delete');

exports.default = function(cb) {
  // 直接使用 `delete` 模块，避免使用 gulp-rimraf 插件
  del(['output/*.js'], cb);
}
```

## 条件插件[​](https://www.gulpjs.com.cn/docs/getting-started/using-plugins#%E6%9D%A1%E4%BB%B6%E6%8F%92%E4%BB%B6 "Direct link to 条件插件")

因为插件的操作不应该针对特定文件类型，因此你可能需要使用像 [gulp-if](https://www.npmjs.com/package/gulp-if) 之类的插件来完成转换某些文件的操作。

```JavaScript
const { src, dest } = require('gulp');
const gulpif = require('gulp-if');
const uglify = require('gulp-uglify');

function isJavaScript(file) {
  // 判断文件的扩展名是否是 '.js'
  return file.extname === '.js';
}

exports.default = function() {
  // 在同一个管道（pipeline）上处理 JavaScript 和 CSS 文件
  return src(['src/*.js', 'src/*.css'])
    // 只对 JavaScript 文件应用 gulp-uglify 插件
    .pipe(gulpif(isJavaScript, uglify()))
    .pipe(dest('output/'));
}
```

## 内联插件（Inline plugins）[​](https://www.gulpjs.com.cn/docs/getting-started/using-plugins#%E5%86%85%E8%81%94%E6%8F%92%E4%BB%B6inline-plugins "Direct link to 内联插件（Inline plugins）")

内联插件是一次性的转换流（Transform Streams），你可以通过在 gulpfile 文件直接书写需要的功能。

在两种情况下，创建内联插件很有用：

* 避免自己创建并维护插件。
* 避免 fork 一个已经存在的插件并添加自己所需的功能。

```JavaScript
const { src, dest } = require('gulp');
const uglify = require('uglify-js');
const through2 = require('through2');

exports.default = function() {
  return src('src/*.js')
    // 创建一个内联插件，从而避免使用 gulp-uglify 插件
    .pipe(through2.obj(function(file, _, cb) {
      if (file.isBuffer()) {
        const code = uglify.minify(file.contents.toString())
        file.contents = Buffer.from(code.code)
      }
      cb(null, file);
    }))
    .pipe(dest('output/'));
}
```

# 文件监控

gulp api 中的 `watch()` 方法利用文件系统的监控程序（file system watcher）将 [globs](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs) 与 [任务（task）](https://www.gulpjs.com.cn/docs/getting-started/creating-tasks) 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 [异步完成](https://www.gulpjs.com.cn/docs/getting-started/async-completion) 信号，它将永远不会再次运行了。

此 API 的默认设置是基于通常的使用场景的，而且提供了内置的延迟和排队机制。

```
const { watch, series } = require('gulp');

function clean(cb) {
  // body omitted
  cb();
}

function javascript(cb) {
  // body omitted
  cb();
}

function css(cb) {
  // body omitted
  cb();
}

exports.default = function() {
  // 你可以使用单个任务
  watch('src/*.css', css);
  // 也可以组合多个任务
  watch('src/*.js', series(clean, javascript));
};
```

## 警告：避免同步任务[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E8%AD%A6%E5%91%8A%E9%81%BF%E5%85%8D%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1 "Direct link to 警告：避免同步任务")

就像注册到任务系统中的任务（task）一样，与文件监控程序关联的任务（task）不能是同步任务（synchronous taks）。如果你将同步任务（task）关联到监控程序，则无法确定任务（task）的完成情况，任务（task）将不会再次运行（假定当前正在运行）。

由于文件监控程序会让你的 Node 进程保持持续运行，因此不会有错误或警告产生。由于进程没有退出，因此无法确定任务（task）是否已经完成还是运行了很久很久了。

## 可监控的事件[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E5%8F%AF%E7%9B%91%E6%8E%A7%E7%9A%84%E4%BA%8B%E4%BB%B6 "Direct link to 可监控的事件")

默认情况下，只要创建、更改或删除文件，文件监控程序就会执行关联的任务（task）。 如果你需要使用不同的事件，你可以在调用 `watch()` 方法时通过 `events` 参数进行指定。可用的事件有 `'add'`、`'addDir'`、`'change'`、`'unlink'`、`'unlinkDir'`、`'ready'`、`'error'`。此外，还有一个 `'all'` 事件，它表示除 `'ready'` 和 `'error'` 之外的所有事件。

```
const { watch } = require('gulp');

exports.default = function() {
  // 所有事件都将被监控
  watch('src/*.js', { events: 'all' }, function(cb) {
    // body omitted
    cb();
  });
};
```

## 初次执行[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E5%88%9D%E6%AC%A1%E6%89%A7%E8%A1%8C "Direct link to 初次执行")

调用 `watch()` 之后，关联的任务（task）是不会被立即执行的，而是要等到第一次文件修之后才执行。

如需在第一次文件修改之前执行，也就是调用 `watch()` 之后立即执行，请将 `ignoreInitial` 参数设置为 `false`。

```
const { watch } = require('gulp');

exports.default = function() {
  // 任务将在启动时执行
  watch('src/*.js', { ignoreInitial: false }, function(cb) {
    // body omitted
    cb();
  });
};
```

## 队列[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E9%98%9F%E5%88%97 "Direct link to 队列")

`watch()` 方法能够保证当前执行的任务（task）不会再次并发执行。当文件监控程序关联的任务（task）正在运行时又有文件被修改了，那么所关联任务的这次新的执行将被放到执行队列中等待，直到上一次关联任务执行完之后才能运行。每一次文件修改只产生一次关联任务的执行并放入队列中。

如需禁止队列，请将 `queue` 参数设置为 `false`。

```
const { watch } = require('gulp');

exports.default = function() {
  // 每次文件修改之后关联任务都将（并发）执行
  watch('src/*.js', { queue: false }, function(cb) {
    // body omitted
    cb();
  });
};
```

## 延迟[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E5%BB%B6%E8%BF%9F "Direct link to 延迟")

文件更改之后，只有经过 200 毫秒的延迟之后，文件监控程序所关联的任务（task）才会被执行。这是为了避免在同使更改许多文件时（例如查找和替换操作）过早启动任务（taks）的执行。

如需调整延迟时间，请为 `delay` 参数设置一个正整数。

```
const { watch } = require('gulp');

exports.default = function() {
  // 文件第一次修改之后要等待 500 毫秒才执行关联的任务
  watch('src/*.js', { delay: 500 }, function(cb) {
    // body omitted
    cb();
  });
};
```

## 使用监控程序实例[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E4%BD%BF%E7%94%A8%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B "Direct link to 使用监控程序实例")

你可能不会使用到此功能，但是如果你需要对被修改的文件进行完全的掌控 （例如访问文件路径或元数据）请使用从 `watch()` 返回的 [chokidar](https://www.npmjs.com/package/chokidar) 实例。

**注意：**  返回的 chokidar 实例没有队列、延迟和异步完成（async completion）这些功能。

## 可选的依赖项[​](https://www.gulpjs.com.cn/docs/getting-started/watching-files#%E5%8F%AF%E9%80%89%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9 "Direct link to 可选的依赖项")

Gulp 有一个名为 [fsevents](https://www.npmjs.com/package/fsevents) 的可选依赖项，他是一个特定于 Mac 系统的文件监控程序。如果你看到安装 fsevents 时出现的警告信息 -  *"npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents"*  - 这并不是什么问题，忽略即可。 如果跳过 fsevents 的安装，将使用一个备用文件监控程序，后续在 gulpfile 中产生的任何错误都将与此警告无关。

---

---
url: /etc\rollup\src/use.md
---
# 使用缓存

缓存可以显著提高构建速度，特别是在开发环境中。

```javascript
import { rollup } from 'rollup';

const inputOptions = {
  input: 'src/main.js',
  cache: true, // 启用缓存
};

const outputOptions = {
  file: 'bundle.js',
  format: 'cjs',
};

async function build() {
  const bundle = await rollup(inputOptions);
  await bundle.write(outputOptions);
}

build();
```

Rollup 的缓存机制是指在构建过程中，Rollup 会将模块的解析结果（如依赖关系）和转换结果（如通过插件处理后的代码）存储在内存中。这样，在后续的构建过程中，如果模块没有发生变化，Rollup 可以直接使用缓存中的结果，而不需要重新解析和转换模块。

### 缓存的作用

1. **提高构建速度**：缓存可以显著减少重复的解析和转换工作，特别是在大型项目中，构建速度的提升会非常明显。
2. **减少资源消耗**：由于缓存减少了重复工作，因此也减少了 CPU 和内存的消耗。

### 缓存的局限性

1. **内存占用**：缓存存储在内存中，因此在构建大型项目时，可能会占用较多的内存。
2. **缓存失效**：如果模块发生了变化（如文件内容修改），Rollup 会自动使缓存失效，并重新解析和转换该模块。

### 手动管理缓存

在某些情况下，你可能需要手动管理缓存。例如，你可以通过 `rollup.rollup` 方法的返回值来获取当前的缓存对象，并在后续构建中复用这个缓存对象：

```javascript
// www.javascriptcn.com code example
async function build() {
  const bundle = await rollup(inputOptions);
  const { cache } = bundle; // 获取缓存对象
  await bundle.write(outputOptions);

  // 在后续构建中复用缓存
  const inputOptionsWithCache = {
    ...inputOptions,
    cache, // 复用缓存
  };

  const bundle2 = await rollup(inputOptionsWithCache);
  await bundle2.write(outputOptions);
}
```

通过这种方式，你可以在多个构建任务之间共享缓存，进一步提高构建效率。

---

---
url: /etc\rollup\src/dev.md
---
# 手动开发一个插件

```JavaScript
export default function (options) {

    return {
        name: 'replace-plugin',
        transform (code, id) {
            if (options.target && options.replacement) {
                return code.replace(new RegExp(options.target, 'g'), options.replacement);
            }
            return null;
        }
    }
}
```

注意如果报错 \`\[!] RollupError: Node tried to load your configuration file as CommonJS even though it is likely an ES module. To resolve this, change the extension of your configuration to ".mjs", set "type": "module" in your package.json file or pass the "--bundleConfigAsCjs" flag.

Original error: Cannot use import statement outside a module\`

可以加package.json 里添加 "type" :"module" 就可以解决

![image.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/6da6bf5ae96c4fdda971a8d064bb4988~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6J5Yip5ZCbX0FuTGlqdW4=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjUwMjk2MDY4NjA0MDI4NiJ9\&rk3s=f64ab15b\&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018\&x-orig-expires=1737871278\&x-orig-sign=c7IFw104m4OHKO80acfog1U8v3E%3D)

---

---
url: /etc\vitepress\src/search.md
---
# 搜索

得益于 [minisearch](https://github.com/lucaong/minisearch/)，VitePress 支持使用浏览器内索引进行模糊全文搜索。要启用此功能，只需在 `.vitepress/config.ts` 文件中将 `themeConfig.search.provider` 选项设置为 `'local'` 即可：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'local'
        }
      }
    })
```

或者，你可以使用 [Algolia DocSearch](https://vitepress.dev/zh/reference/default-theme-search#algolia-search) 或一些社区插件，例如：<https://www.npmjs.com/package/vitepress-plugin-search> 或者 <https://www.npmjs.com/package/vitepress-plugin-pagefind>。

### i18n[​](https://vitepress.dev/zh/reference/default-theme-search#local-search-i18n)

你可以使用这样的配置来使用多语言搜索：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'local',
          options: {
            locales: {
              zh: {
                translations: {
                  button: {
                    buttonText: '搜索文档',
                    buttonAriaLabel: '搜索文档'
                  },
                  modal: {
                    noResultsText: '无法找到相关结果',
                    resetButtonTitle: '清除查询条件',
                    footer: {
                      selectText: '选择',
                      navigateText: '切换'
                    }
                  }
                }
              }
            }
          }
        }
      }
    })
```

### MiniSearch 配置项[​](https://vitepress.dev/zh/reference/default-theme-search#mini-search-options)

你可以像这样配置 MiniSearch ：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'local',
          options: {
            miniSearch: {
              /**
               * @type {Pick<import('minisearch').Options, 'extractField' | 'tokenize' | 'processTerm'>}
               */
              options: {
                /* ... */
              },
              /**
               * @type {import('minisearch').SearchOptions}
               * @default
               * { fuzzy: 0.2, prefix: true, boost: { title: 4, text: 2, titles: 1 } }
               */
              searchOptions: {
                /* ... */
              }
            }
          }
        }
      }
    })
```

参阅 [MiniSearch 文档](https://lucaong.github.io/minisearch/classes/MiniSearch.MiniSearch.html)了解更多信息。

### 自定义渲染内容[​](https://vitepress.dev/zh/reference/default-theme-search#custom-content-renderer)

可以在索引之前自定义用于渲染 Markdown 内容的函数：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'local',
          options: {
            /**
             * @param {string} src
             * @param {import('vitepress').MarkdownEnv} env
             * @param {import('markdown-it-async')} md
             */
            async _render(src, env, md) {
              // 返回 html 字符串
            }
          }
        }
      }
    })
```

该函数将从客户端站点数据中剥离，因此你可以在其中使用 Node.js API。

#### 示例：从搜索中排除页面[​](https://vitepress.dev/zh/reference/default-theme-search#example-excluding-pages-from-search)

你可以通过将 `search: false` 添加到页面的 `frontmatter` 来从搜索中排除页面。或者：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'local',
          options: {
            async _render(src, env, md) {
              const html = await md.renderAsync(src, env)
              if (env.frontmatter?.search === false) return ''
              if (env.relativePath.startsWith('some/path')) return ''
              return html
            }
          }
        }
      }
    })
```

注意

如果提供了自定义的 `_render` 函数，你需要自己处理 `search: false` 的 frontmatter。此外，在调用 `md.renderAsync` 之前，`env` 对象不会完全填充，因此对可选 `env` 属性 (如 `frontmatter`) 的任何检查都应该在此之后完成。

#### 示例：转换内容——添加锚点[​](https://vitepress.dev/zh/reference/default-theme-search#example-transforming-content-adding-anchors)

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'local',
          options: {
            async _render(src, env, md) {
              const html = await md.renderAsync(src, env)
              if (env.frontmatter?.title)
                return await md.renderAsync(`# ${env.frontmatter.title}`) + html
              return html
            }
          }
        }
      }
    })
```

## Algolia Search[​](https://vitepress.dev/zh/reference/default-theme-search#algolia-search)

VitePress 支持使用 [Algolia DocSearch](https://docsearch.algolia.com/docs/what-is-docsearch) 搜索文档站点。请参阅他们的入门指南。在你的 `.vitepress/config.ts` 中，你至少需要提供以下内容才能使其正常工作：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'algolia',
          options: {
            appId: '...',
            apiKey: '...',
            indexName: '...'
          }
        }
      }
    })
```

### i18n[​](https://vitepress.dev/zh/reference/default-theme-search#algolia-search-i18n)

你可以使用这样的配置来使用多语言搜索：

```ts

    import { defineConfig } from 'vitepress'

    export default defineConfig({
      themeConfig: {
        search: {
          provider: 'algolia',
          options: {
            appId: '...',
            apiKey: '...',
            indexName: '...',
            locales: {
              zh: {
                placeholder: '搜索文档',
                translations: {
                  button: {
                    buttonText: '搜索文档',
                    buttonAriaLabel: '搜索文档'
                  },
                  modal: {
                    searchBox: {
                      resetButtonTitle: '清除查询条件',
                      resetButtonAriaLabel: '清除查询条件',
                      cancelButtonText: '取消',
                      cancelButtonAriaLabel: '取消'
                    },
                    startScreen: {
                      recentSearchesTitle: '搜索历史',
                      noRecentSearchesText: '没有搜索历史',
                      saveRecentSearchButtonTitle: '保存至搜索历史',
                      removeRecentSearchButtonTitle: '从搜索历史中移除',
                      favoriteSearchesTitle: '收藏',
                      removeFavoriteSearchButtonTitle: '从收藏中移除'
                    },
                    errorScreen: {
                      titleText: '无法获取结果',
                      helpText: '你可能需要检查你的网络连接'
                    },
                    footer: {
                      selectText: '选择',
                      navigateText: '切换',
                      closeText: '关闭',
                      searchByText: '搜索提供者'
                    },
                    noResultsScreen: {
                      noResultsText: '无法找到相关结果',
                      suggestedQueryText: '你可以尝试查询',
                      reportMissingResultsText: '你认为该查询应该有结果？',
                      reportMissingResultsLinkText: '点击反馈'
                    }
                  }
                }
              }
            }
          }
        }
      }
    })
```

[这些选项](https://github.com/vuejs/vitepress/blob/main/types/docsearch.d.ts)可以被覆盖。请参阅 Algolia 官方文档以了解更多信息。

### 爬虫配置[​](https://vitepress.dev/zh/reference/default-theme-search#crawler-config)

以下是基于此站点使用的示例配置：

```ts

    new Crawler({
      appId: '...',
      apiKey: '...',
      rateLimit: 8,
      startUrls: ['https://vitepress.dev/'],
      renderJavaScript: false,
      sitemaps: [],
      exclusionPatterns: [],
      ignoreCanonicalTo: false,
      discoveryPatterns: ['https://vitepress.dev/**'],
      schedule: 'at 05:10 on Saturday',
      actions: [
        {
          indexName: 'vitepress',
          pathsToMatch: ['https://vitepress.dev/**'],
          recordExtractor: ({ $, helpers }) => {
            return helpers.docsearch({
              recordProps: {
                lvl1: '.content h1',
                content: '.content p, .content li',
                lvl0: {
                  selectors: 'section.has-active div h2',
                  defaultValue: 'Documentation'
                },
                lvl2: '.content h2',
                lvl3: '.content h3',
                lvl4: '.content h4',
                lvl5: '.content h5'
              },
              indexHeadings: true
            })
          }
        }
      ],
      initialIndexSettings: {
        vitepress: {
          attributesForFaceting: ['type', 'lang'],
          attributesToRetrieve: ['hierarchy', 'content', 'anchor', 'url'],
          attributesToHighlight: ['hierarchy', 'hierarchy_camel', 'content'],
          attributesToSnippet: ['content:10'],
          camelCaseAttributes: ['hierarchy', 'hierarchy_radio', 'content'],
          searchableAttributes: [
            'unordered(hierarchy_radio_camel.lvl0)',
            'unordered(hierarchy_radio.lvl0)',
            'unordered(hierarchy_radio_camel.lvl1)',
            'unordered(hierarchy_radio.lvl1)',
            'unordered(hierarchy_radio_camel.lvl2)',
            'unordered(hierarchy_radio.lvl2)',
            'unordered(hierarchy_radio_camel.lvl3)',
            'unordered(hierarchy_radio.lvl3)',
            'unordered(hierarchy_radio_camel.lvl4)',
            'unordered(hierarchy_radio.lvl4)',
            'unordered(hierarchy_radio_camel.lvl5)',
            'unordered(hierarchy_radio.lvl5)',
            'unordered(hierarchy_radio_camel.lvl6)',
            'unordered(hierarchy_radio.lvl6)',
            'unordered(hierarchy_camel.lvl0)',
            'unordered(hierarchy.lvl0)',
            'unordered(hierarchy_camel.lvl1)',
            'unordered(hierarchy.lvl1)',
            'unordered(hierarchy_camel.lvl2)',
            'unordered(hierarchy.lvl2)',
            'unordered(hierarchy_camel.lvl3)',
            'unordered(hierarchy.lvl3)',
            'unordered(hierarchy_camel.lvl4)',
            'unordered(hierarchy.lvl4)',
            'unordered(hierarchy_camel.lvl5)',
            'unordered(hierarchy.lvl5)',
            'unordered(hierarchy_camel.lvl6)',
            'unordered(hierarchy.lvl6)',
            'content'
          ],
          distinct: true,
          attributeForDistinct: 'url',
          customRanking: [
            'desc(weight.pageRank)',
            'desc(weight.level)',
            'asc(weight.position)'
          ],
          ranking: [
            'words',
            'filters',
            'typo',
            'attribute',
            'proximity',
            'exact',
            'custom'
          ],
          highlightPreTag: '<span class="algolia-docsearch-suggestion--highlight">',
          highlightPostTag: '</span>',
          minWordSizefor1Typo: 3,
          minWordSizefor2Typos: 7,
          allowTyposOnNumericTokens: false,
          minProximity: 1,
          ignorePlurals: true,
          advancedSyntax: true,
          attributeCriteriaComputedByMinProximity: true,
          removeWordsIfNoResults: 'allOptional'
        }
      }
    })

```

---

---
url: /etc\vitepress\src/withVue.md
---
# 在md使用vue

## 模板语法

:::v-pre
{{ 1 + 1 }}
:::

## `<script>` 和 `<style>`[​](https://vitepress.dev/zh/guide/using-vue#script-and-style)

Markdown 文件中的根级 `<script>` 和 `<style>` 标签与 Vue SFC 中的一样，包括 `<script setup>`、`<style module>` 等。这里的主要区别是没有 `<template>` 标签：所有其他根级内容都是 Markdown。另请注意，所有标签都应放在 frontmatter **之后**:

```vue
---
hello: world
---
<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>

## Markdown Content

The count is: {{ count }}

<button :class="$style.button" @click="count++">Increment</button>

<style module>
.button {
  color: red;
  font-weight: bold;
}
</style>

```

可以通过使用 `v-pre` 指令将它们包裹在 `<span>` 或其他元素中来转义 Vue 插值

This {{ will be displayed as-is }}

也可以将整个段落包装在 `v-pre` 自定义容器中：

```md
    ::: v-pre
        {{ This will be displayed as-is }}
    :::
```

## 使用 CSS 预处理器[​](https://vitepress.dev/zh/guide/using-vue#using-css-pre-processors)

VitePress [内置支持](https://cn.vitejs.dev/guide/features.html#css-pre-processors) CSS 预处理器：`.scss`、`.sass`、.`less`、`.styl` 和 `.stylus` 文件。无需为它们安装 Vite 专用插件，但必须安装相应的预处理器：

```sh
    npm install -D sass
    npm install -D less
    npm install -D stylus
```

然后可以在 Markdown 和主题组件中使用以下内容：

```vue
    <style lang="sass">
    .title  
      font-size: 20px
    </style>
```

---

---
url: /etc\rollup\src/scope.md
---
# 作用域提升

作用域提升（Scope Hoisting）是一种优化技术，它通过将模块中的代码尽可能地合并到一个作用域中，从而减少闭包的数量和模块之间的依赖关系。这种优化可以减少打包后的文件大小，并提高代码的执行效率。

Rollup 通过静态分析模块的依赖关系，将模块中的代码尽可能地合并到一个作用域中。具体来说，Rollup 会分析模块的导入和导出语句，并将这些语句替换为直接的变量引用，从而减少闭包的数量。

* **模块格式**：作用域提升主要适用于 ES 模块（ESM），因为 ES 模块的导入和导出是静态的，便于 Rollup 进行静态分析。
* **CommonJS 模块**：如果项目中使用了 CommonJS 模块，需要使用 `@rollup/plugin-commonjs` 插件将其转换为 ES 模块。
* **动态导入**：作用域提升不适用于动态导入（`import()`），因为动态导入的模块在运行时才会加载，Rollup 无法在打包时进行静态分析。

通过以上配置和注意事项，Rollup 可以有效地进行作用域提升，优化打包后的代码。

---

---
url: /etc/report.md
---
# All files

95.44% Statements 398/417

94.07% Branches 254/270

94.91% Functions 112/118

95.44% Lines 377/395

Press *n* or *j* to go to the next uncovered block, *b*, *p* or *k* for the previous block.
Filter:

|File|Statements|Branches|Functions|Lines|
|---|---|---|---|---|
|\[array/src]||100%|13/13|100%|7/7|100%|5/5|100%|10/10|
|\[boolean/src]||100%|1/1|100%|0/0|100%|1/1|100%|1/1|
|\[color/src]||98.46%|64/65|95.91%|47/49|100%|12/12|98.43%|63/64|
|\[common/src]||98.18%|54/55|95.65%|44/46|100%|10/10|98.11%|52/53|
|\[function/src]||95.49%|106/111|97.1%|67/69|96.15%|25/26|95.09%|97/102|
|\[math/src]||100%|5/5|100%|3/3|100%|1/1|100%|5/5|
|\[number/src]||93.75%|15/16|100%|7/7|85.71%|6/7|93.33%|14/15|
|\[object/src]||100%|13/13|100%|13/13|100%|7/7|100%|12/12|
|\[string/src]||97.72%|43/44|96.77%|30/31|100%|10/10|97.56%|40/41|
|\[symbol/src]||100%|1/1|100%|2/2|100%|1/1|100%|1/1|
|\[web/src]||89.24%|83/93|79.06%|34/43|89.47%|34/38|90.1%|82/91|

Code coverage generated by [istanbul](https://istanbul.js.org/) at 2025-01-28T03:10:58.096Z

---

---
url: /etc\apiExtractor\src/introduce.md
---
# api-extractor.json的配置

## 入口和项目相关配置

* `mainEntryPointFilePath`：

  * 这是一个必需的配置项，指定了 API Extractor 开始分析的主要入口文件的路径。例如

```
"mainEntryPointFilePath": "src/index.ts"
```

`projectFolder`：

* 通常设置为 `"."`，表示项目所在的根目录。例如：

```
"projectFolder": "."
```

## 文档相关配置

`docModel`：

* `enabled`：

  * 一个布尔值，当设置为 `true` 时，API Extractor 会生成文档模型。
    启用此选项后，可为后续生成文档提供基础信息，方便后续将文档模型转换为各种格式的文档，如 Markdown 或 HTML。

例如：

```
"docModel": {
    "enabled": true
}
```

`tsdocMetadata`：

* `enabled`：
  * 同样是一个布尔值，设置为 `true` 时，会启用 TSDoc 元数据的处理和存储。 TSDoc 是一种文档注释格式，启用该选项有助于更好地管理文档注释信息。

例如：

```
"tsdocMetadata": {
    "enabled": false
}
```

## DTS 文件生成和处理配置

`dtsRollup`：

* `enabled`：

  * 布尔值，设置为 `true` 时，将进行 DTS 文件的合并和整理操作。例如：

```
"dtsRollup": {
    "enabled": true,
    "untrimmedFilePath": "dist/api-untrimmed.d.ts",
    "trimmedFilePath": "dist/api.d.ts"
}
```

* `untrimmedFilePath`
  * 指定未处理的 DTS 文件的输出路径，其中包含了所有导出的 API 信息，包括可能的内部实现细节，方便调试和分析。

* `trimmedFilePath`
  * 指定处理后的 DTS 文件的输出路径，该文件仅包含公共 API，经过优化和裁剪，符合公共 API 的标准。

* `publicTrimmedFilePath`
  \--   可以指定另一个路径，存储仅包含公共 API 的 DTS 文件，

例如：

```
"publicTrimmedFilePath": "dist/public-api.d.ts"
```

## **类型检查和 API 分析配置**

`apiReport`：

* `enabled`：

  * 当设置为 `true` 时，会生成 API 报告，有助于检查 API 的一致性和问题。例如：

```
"apiReport": {
    "enabled": true,
    "reportFolder": "reports/api" //-   指定存储 API 报告的文件夹路径，方便查看和分析报告结果。
}
```

* `validationRules`
  * 可以配置各种验证规则，例如：

```
"validationRules": {
    "missingReleaseTags": false, // 当设置为 `false` 时，不强制要求 API 元素具有发布标签。
    "exportedInternals": false //当设置为 `false` 时，不允许导出内部元素作为公共 API。
}
```

## **编译器选项配置**

* `compilerOptions`：

  * 可以设置类似于 `tsconfig.json` 中的编译器选项，例如：

```
"compilerOptions": {
    "baseUrl": ".",//定义模块解析的基础 URL，帮助 API Extractor 正确解析模块引用
    "paths": {
        "my-library/*": ["src/my-library/*"] //-   自定义模块解析路径，方便处理项目中自定义的模块别名。
    }
}
```

## **打包和外部引用配置**

* `bundledPackages`：

  * 可以指定需要打包在一起的包，例如

```
"bundledPackages": ["my-library-package"] //当处理多个包时，可将某些包作为一个整体进行处理。
```

* `externalJsonFile`：

  * 可指定一个外部 JSON 文件，其中包含外部引用的信息，例如：

```
"externalJsonFile": "config/external.json" //有助于处理项目中的外部依赖和引用，确保 API 提取时的准确性。
```

-`unresolvedTypes`：

```
-   可以定义如何处理未解析的类型，例如：
```

```
"unresolvedTypes": {
   "ignore": ["SomeUnresolvedType"] //允许开发者指定哪些未解析的类型可以被忽略，避免分析过程中的错误或警告。
}
```

## 其它配置

* `toolVersion`：

  * 可以指定 API Extractor 工具的版本，确保使用特定版本的工具进行分析。例如：

```
"toolVersion": "1.0.0"
```

* extensions
  * 可以添加自定义的扩展配置，以扩展 API Extractor 的功能，例如：

```
"extensions": [
    {
        "name": "my-extension",
        "parameters": {}
    }
]
```

* `apiJsonFilePath`：

  * 指定生成 API 信息的 JSON 文件的存储路径，例如：

```
"apiJsonFilePath": "reports/api/api.json"
```

* `apiVersion`：

  * 可以设置 API 的版本信息，例如：

```
"apiVersion": "1.0.0" //方便进行版本管理和发布流程中的 API 对比。
```

# 常用api-extractor配置

```json
{
    // 指定配置文件的 JSON 模式，有助于编辑器进行语法检查和智能提示
    "$schema": "https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json",

    // 主入口点的 TypeScript 声明文件路径，通常是编译后的 .d.ts 文件
    // api-extractor 将从此文件开始分析整个项目的 API
    "mainEntryPointFilePath": "./dist/index.d.ts",

    // 项目根文件夹的路径，默认为配置文件所在的文件夹
    // 该配置用于解析相对路径
    "projectFolder": "./",

    // 是否跳过 TypeScript 的库检查，设置为 true 可加快编译速度，但可能会忽略一些类型错误
    "skipLibCheck": false,

    // 是否启用循环引用检测
    // 循环引用可能会导致文档生成和 API 分析出现问题，建议保持开启
    "enableCircularReferenceDetection": true,

    // API 报告文件的输出文件夹路径
    "reportFolder": "./etc",

    // API 报告文件的名称，该文件记录了 API 的变化
    "reportFileName": "MyLibrary.api.md",

    // API 报告相关配置
    "apiReport": {
        // 是否启用 API 报告功能
        // 启用后会生成一个记录 API 变化的报告文件
        "enabled": false
    },

    // 文档模型相关配置
    "docModel": {
        // 是否启用文档模型生成
        // 启用后会生成一个中间文档模型，供 api-documenter 等工具使用
        "enabled": true
    },

    // TSDoc 元数据相关配置
    "tsdocMetadata": {
        // 是否启用 TSDoc 元数据生成
        // 启用后会生成 TSDoc 元数据文件，用于跨项目的文档链接等功能
        "enabled": true
    },

    // DTS 汇总文件相关配置
    "dtsRollup": {
        // 是否启用 DTS 汇总文件生成
        // 汇总文件将项目中的多个 .d.ts 文件合并为一个
        "enabled": true,
        // 未修剪的 DTS 汇总文件路径，包含所有 API 信息
        "untrimmedFilePath": "./dist/my-library.d.ts",
        // 包含 beta 版本 API 的修剪后 DTS 汇总文件路径
        "betaTrimmedFilePath": "./dist/my-library.beta.d.ts",
        // 仅包含公共 API 的修剪后 DTS 汇总文件路径
        "publicTrimmedFilePath": "./dist/my-library.public.d.ts"
    },

    // 消息报告相关配置
    "messages": {
        // api-extractor 消息报告配置
        "extractorMessageReporting": {
            // 默认消息的日志级别，可设置为 "verbose"、"info"、"warning"、"error" 或 "none"
            "default": {
                "logLevel": "warning"
            },
            // 针对特定错误代码 "ae-missing-release-tag" 的日志级别设置
            // 这里将缺少发布标签的错误设置为错误级别，会中断构建过程
            "ae-missing-release-tag": {
                "logLevel": "error"
            }
        },
        // TSDoc 消息报告配置
        "tsdocMessageReporting": {
            // 默认 TSDoc 消息的日志级别
            "default": {
                "logLevel": "warning"
            }
        }
    },

    // 是否启用测试模式，测试模式下输出会有所不同，主要用于开发和调试
    "testMode": false,

    // 是否跳过错误检查，设置为 true 会忽略一些 API 提取过程中的错误
    "skipErrorChecking": false,

    // TypeScript 编译器文件夹的路径
    // 如果需要使用特定版本的 TypeScript 编译器，可以指定该路径
    "typescriptCompilerFolder": "",

    // 编译器相关配置
    "compiler": {
        // 覆盖 TypeScript 编译器的配置
        // 这里可以设置一些额外的 TypeScript 编译选项
        "overrideTsconfig": {
            "compilerOptions": {
                // 启用严格的空值检查
                "strictNullChecks": true
            }
        }
    },

    // TSDoc 元数据文件的输出路径
    "tsdocMetadataFilePath": "./temp/tsdoc-metadata.json",

    // 换行符类型，可设置为 "os"（使用操作系统默认换行符）、"crlf" 或 "lf"
    "newlineKind": "os",

    // 本地化相关配置
    "localization": {
        // 输出文件夹路径，用于存放本地化后的文档文件
        "outputFolder": "./docs/localized"
    }
}
```

---

---
url: /etc\gulp\src/other.md
---
# Apis

## src()

创建一个流，用于从文件系统读取 [Vinyl](https://www.gulpjs.com.cn/docs/api/concepts#vinyl) 对象。

\*\*注：\*\*BOMs(字节顺序标记)在 UTF-8 中没有任何作用，除非使用 `removeBOM` 选项禁用，否则 `src()` 将从读取的 UTF-8 文件中删除BOMs。

### 用法[​](https://www.gulpjs.com.cn/docs/api/src#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { src, dest } = require('gulp');

function copy() {
  return src('input/*.js')
    .pipe(dest('output/'));
}

exports.copy = copy;
```

### 函数原型[​](https://www.gulpjs.com.cn/docs/api/src#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
src(globs, [options])
```

#### 参数[​](https://www.gulpjs.com.cn/docs/api/src#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数      | 类型           | 描述                                                                          |
| ------- | ------------ | --------------------------------------------------------------------------- |
| globs   | string array | 用于监视文件系统中匹配文件的 [Globs](https://www.gulpjs.com.cn/docs/api/concepts#globs) 。 |
| options | object       | 在下面的 [选项](https://www.gulpjs.com.cn/docs/api/src#options) 中详细说明。            |

#### 返回值[​](https://www.gulpjs.com.cn/docs/api/src#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个可以在管道的开始或中间使用的流，用于根据给定的 globs 添加文件。

#### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/src#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当 `globs` 参数只能匹配一个文件(如 `foo/bar.js`)而且没有找到匹配时，会抛出一个错误，提示 "File not found with singular glob"。若要抑制此错误，请将 `allowEmpty` 选项设置为 `true`。

当在 `globs` 中给出一个无效的 glob 时，抛出一个错误，并显示 "Invalid glob argument"。

#### 选项[​](https://www.gulpjs.com.cn/docs/api/src#%E9%80%89%E9%A1%B9 "Direct link to 选项")

**对于接受函数的选项，传递的函数将与每个 Vinyl 对象一起调用，并且必须返回另一个列出类型的值。**

| 名称              | 类型                      | 默认值             | 描述                                                                                                                                                                                                                                                                  |
| --------------- | ----------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| encoding        | string boolean          | "utf8"          | 当为假时，文件内容将被视为二进制数据。当为字符串时，该字符串将用作文本编码。                                                                                                                                                                  |
| buffer          | boolean function        | true            | 如果为 true，文件内容将被缓冲到内存中。如果为 false，Vinyl 对象的`contents`属性将是一个暂停的流。对于大文件，可能无法缓冲其内容。**注意**：插件可能不支持对流式内容的处理。     |
| read            | boolean function        | true            | 如果为 false，文件将不会被读取，并且其对应的 Vinyl 对象也无法通过 `.dest()` 方法写入磁盘。.                                                                                                                                                                |
| since           | date timestamp function |                 | 设置此值后，仅为自指定时间以来修改过的文件创建 Vinyl 对象。                                                                                                                                                                           |
| removeBOM       | boolean function        | true            | 若为 true，则从 UTF - 8 编码的文件中移除字节顺序标记（BOM）。若为 false，则忽略字节顺序标记。                                                                                                                                                                       |
| sourcemaps      | boolean function        | false           | 如果为 true，会在创建的 Vinyl 对象上启用源映射支持。加载内联源映射并解析外部源映射链接。                                          |
| resolveSymlinks | boolean function        | true            | 若为 `true`，则会递归地将符号链接解析为其目标文件。若为 `false`，则会保留符号链接，并将 Vinyl 对象的 `symlink` 属性设置为原始文件的路径。                                                                                 |
| cwd             | string                  | `process.cwd()` | 该目录将与任何相对路径相结合，以形成绝对路径。对于绝对路径，此设置会被忽略。使用此选项可避免使用 `path.join()` 来组合通配符模式。该选项会直接传递给 `glob-stream`。    |
| base            | string                  |                 | 显式设置所创建的 Vinyl 对象上的 `base` 属性。具体细节见 “API 概念” 部分。此选项会直接传递给 `glob-stream`。                           |
| cwdbase         | boolean                 | false           |如果为 `true`，则 `cwd`（当前工作目录）和 `base` 选项应保持一致。此选项会直接传递给 `glob-stream`。                                                                                                                      |
| root            | string                  |                 | 通配符模式所基于的根路径。此选项会直接传递给 `glob-stream`。                                                                                                                       |
| allowEmpty      | boolean                 | false           | 若为 `false`，对于那些只能匹配单个文件的通配符模式（例如 `foo/bar.js`），如果未找到匹配文件，将会抛出错误。若为 `true`，则会抑制通配符匹配失败的情况。此选项会直接传递给 `glob-stream`。     |
| uniqueBy        | string function         | `'path'`        | 通过比较字符串属性名或函数的返回结果，从流中移除重复项。注意：使用函数时，该函数会接收流中的数据（包含 `cwd`、`base`、`path` 属性的对象）。                             |
| dot             | boolean                 | false           | 如果为 `true`，则会将通配符模式与点文件（如 `.gitignore`）进行匹配。此选项会直接传递给 `anymatch`。                                                                                                               |
| nounique        | boolean                 | false           | 若为 `false`，则会防止结果集中出现重复文件。此选项会直接传递给 `anymatch`。                                                                                                             |
| debug           | boolean                 | false           |如果为 `true`，调试信息将被记录到命令行。此选项会直接传递给 `anymatch`。                                                                                                          |
| nobrace         | boolean                 | false           | 如果为 `true`，则避免展开花括号集合，例如 `{a,b}` 或 `{1..3}`。此选项会直接传递给 `anymatch`。                                                                                                            |
| noglobstar      | boolean                 | false           | 如果为 `true`，则将双星号通配符字符（`**`）视为单星号通配符字符（`*`）。此选项会直接传递给 `anymatch`。                                                                                               |
| noext           | boolean                 | false           | 如果为 `true`，则避免匹配扩展通配符模式，例如 `+(ab)`。此选项会直接传递给 `anymatch`。                                                         |
| nocase          | boolean                 | false           | 如果为 `true`，则进行不区分大小写的匹配。注意：在不区分大小写的文件系统中，非通配符模式默认会进行不区分大小写的匹配。此选项会直接传递给 `anymatch`。                                          |
| matchBase       | boolean                 | false           | 如果为 `true` 且通配符模式中不包含任何 `/` 字符，则会遍历所有目录并匹配该通配符模式。例如，`*.js` 会被视为等同于 `**/*.js`。此选项会直接传递给 `anymatch`。             |
| ignore          | string array            |                 | 用于从匹配结果中排除的通配符模式。此选项会与取反后的 `globs` 相结合。**注意**：无论其他设置如何，这些通配符模式始终会针对点文件（以点开头的文件）进行匹配。*此选项会直接传递给 [anymatch](https://github.com/micromatch/anymatch)。* |

### 资源映射（Sourcemaps）[​](https://www.gulpjs.com.cn/docs/api/src#%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84sourcemaps "Direct link to 资源映射（Sourcemaps）")

对资源映射（Sourcemap ）的支持已内置到 `src()` 和 `dest()` 中了，但是默认情况下是禁用的。开启此功能能够生成内联或外联的资源映射（Sourcemap）。

内联资源映射（sourcemaps）：

```
const { src, dest } = require('gulp');
const uglify = require('gulp-uglify');

src('input/**/*.js', { sourcemaps: true })
  .pipe(uglify())
  .pipe(dest('output/', { sourcemaps: true }));
```

外部资源映射：

```
const { src, dest } = require('gulp');
const uglify = require('gulp-uglify');

src('input/**/*.js', { sourcemaps: true })
  .pipe(uglify())
  .pipe(dest('output/', { sourcemaps: '.' }));
```

# dest()

创建一个用于将 [Vinyl](https://www.gulpjs.com.cn/docs/api/concepts#vinyl) 对象写入到文件系统的流。

## 用法[​](https://www.gulpjs.com.cn/docs/api/dest#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { src, dest } = require('gulp');

function copy() {
  return src('input/*.js')
    .pipe(dest('output/'));
}

exports.copy = copy;
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/dest#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
dest(directory, [options])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/dest#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数                 | 类型              | 描述                                                                      |
| ------------------ | --------------- | ----------------------------------------------------------------------- |
| directory **（必须）** | string function | 文件将被写入的输出目录的路径。如果使用了函数，则每个 Vinyl 对象都会调用该函数，并且必须返回字符串形式的目录路径。            |
| options            | object          | 详情见下文 [选项](https://www.gulpjs.com.cn/docs/api/dest#%E9%80%89%E9%A1%B9)。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/dest#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个可以在管道的中间或末尾使用的流，用于在文件系统上创建文件。

每当 Vinyl 对象通过流被传递时，它将内容和其他细节写到给定目录下的文件系统。如果 Vinyl 对象具有 `symlink` 属性，将创建符号链接（symbolic link）而不是写入内容。创建文件后，将[更新其元数据](https://www.gulpjs.com.cn/docs/api/dest#metadata-updates)以匹配 Vinyl 对象。

在文件系统上创建文件时，Vinyl 对象将被修改。

* `cwd`、`base` 和 `path` 属性将被更新以匹配创建的文件。
* `stat` 属性将被更新，以匹配文件系统上的文件。
* 如果 `contents` 属性是一个流，它将被重置，以便可以再次读取。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/dest#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当目录为空字符串时，将抛出一个错误，并提示 "Invalid dest() folder argument. Please specify a non-empty string or a function."（无效的 dest() 文件夹参数。请指定非空字符串或函数。）

当目录不是字符串或函数时，将抛出一个错误，并提示 "Invalid dest() folder argument. Please specify a non-empty string or a function."

当 `directory` 是一个返回空字符串或 `undefined` 的函数时，将发出一条错误消息 “Invalid output folder”。

### 选项[​](https://www.gulpjs.com.cn/docs/api/dest#%E9%80%89%E9%A1%B9 "Direct link to 选项")

**对于接受函数的选项，传递的函数将与每个 Vinyl 对象一起调用，并且必须返回另一个列出类型的值。**

| 名称               | 类型                      | 默认值                      | 注解                                                                                                                                                            |
| ---------------- | ----------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cwd              | string function         | `process.cwd()`          | 此目录可以与任何相对路径合并为绝对路径。如果是绝对路径，则忽略。该参数旨在避免通过 `directory` 和 `path.join()` 生成输出目录的路径的麻烦。                                                                           |
| mode             | number function         | Vinyl 对象的 `stat.mode` 属性 | 创建文件时使用的模式。如果没有设置，并且缺少 `stat.mode`，则使用 process' 模式。                                                                                                           |
| dirMode          | number function         |                          | 创建目录时使用的模式。如果没有设置，将使用当前进程的模式。                                                                                                                                 |
| overwrite        | boolean function        | true                     | 如果为 true，则覆盖相同路径的现有文件。                                                                                                                                        |
| append           | boolean function        | false                    | 如果为 true，则将内容添加到文件末尾，而不是替换现有内容。                                                                                                                               |
| sourcemaps       | boolean string function | false                    | 如果为 true，则将内联 sourcemaps 写入输出文件。 如果指定一个 `string` 类型的路径，则在给定的路径出写入外部 [sourcemaps](https://www.gulpjs.com.cn/docs/api/dest#sourcemaps) 。                        |
| relativeSymlinks | boolean function        | false                    | 如果为 false，则创建的任何符号链接都将是绝对路径的。 **注意**：如果正在创建的是 junction，则将被忽略，因为他们必须是绝对路径。                                                                                     |
| useJunctions     | boolean function        | true                     | 此选项仅用适用于 Windows，在其他操作系统中将被忽略。当设置为 true 时，则将目录符号链接创建为 junction。详情请参见下面的 [Windows 上的符号链接](https://www.gulpjs.com.cn/docs/api/dest#symbolic-links-on-windows) 。 |

## 元数据更新[​](https://www.gulpjs.com.cn/docs/api/dest#%E5%85%83%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0 "Direct link to 元数据更新")

每当 `dest()` 流创建一个文件时，就会将 Vinyl 对象的 `mode`、`mtime` 和 `atime` 与创建的文件进行比较。如果它们不同，创建的文件将被更新以反映 Vinyl 对象的元数据。如果这些属性相同，或者 gulp 没有更改的权限，则会跳过该尝试。

在不支持 Node 的 `process.getuid()`或 `process.geteuid()` 方法的 Windows 或其他操作系统上禁用此功能。这是因为Windows通过使用 `fs.fchmod()` 和 \`fs.futimes() 会产生意想不到的结果。

**注意**: `fs.futimes()` 在内部将 `mtime` 和 `atime` 时间戳转换为秒。这种除以 1000 的方法可能会导致 32 位操作系统的精度有所下降。

## Sourcemaps[​](https://www.gulpjs.com.cn/docs/api/dest#sourcemaps "Direct link to Sourcemaps")

Sourcemap 支持直接构建到 `src()` 和 `dest()` 中，但默认情况下是禁用的。使其能够生成内联或外部 sourcemaps。

内联 sourcemaps:

```
const { src, dest } = require('gulp');
const uglify = require('gulp-uglify');

src('input/**/*.js', { sourcemaps: true })
  .pipe(uglify())
  .pipe(dest('output/', { sourcemaps: true }));
```

外部 sourcemaps:

```
const { src, dest } = require('gulp');
const uglify = require('gulp-uglify');

src('input/**/*.js', { sourcemaps: true })
  .pipe(uglify())
  .pipe(dest('output/', { sourcemaps: '.' }));
```

## Windows 上的符号链接[​](https://www.gulpjs.com.cn/docs/api/dest#windows-%E4%B8%8A%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5 "Direct link to Windows 上的符号链接")

在 Windows 上创建符号链接时，`type` 参数被传递给 Node 的 `fs.symlink()` 方法，该方法指定被链接的目标的类型。链接类型设置为:

* `'file'`，当目标是一个常规文件时
* `'junction'`， 当目标是一个目录时
* `'dir'`， 当目标是一个目录并且用户禁用了 `useJunctions` 选项时

如果试图创建 dangling (指向不存在的目标)链接，则无法自动确定链接类型。在这些情况下，根据 dangling 链接是通过 `symlink()` 创建的还是通过 `dest()` 创建的，行为会有所不同。

对于通过 `symlink()` 创建的 dangling 链接，传入的 Vinyl 对象表示目标，因此其 stats 将确定所需的链接类型。如果 `isDirectory()` 返回 false，则创建一个 `'file'` 链接，否则根据 `useJunctions` 选项的值创建一个 `'junction'` 或 `'dir'` 链接。

对于通过 `dest()` 创建的 dangling 链接，传入的 Vinyl 对象表示链接——通常通过 `src(..., { resolveSymlinks: false })` 从磁盘加载。在这种情况下，无法合理地确定链接类型，默认使用 `'file'`。如果正在创建指向目录的 dangling 链接，这可能会导致意外行为。**避免这种情况。**

# symlink()

创建一个流（stream），用于连接 [Vinyl](https://www.gulpjs.com.cn/docs/api/concepts#vinyl) 对象到文件系统。

## 用法[​](https://www.gulpjs.com.cn/docs/api/symlink#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { src, symlink } = require('gulp');

function link() {
  return src('input/*.js')
    .pipe(symlink('output/'));
}

exports.link = link;
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/symlink#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
symlink(directory, [options])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/symlink#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数                       | 类型              | 描述                                                                                                                                                                                        |
| ------------------------ | --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| directory **(required)** | string function | The path of the output directory where symbolic links will be created. If a function is used, the function will be called with each Vinyl object and must return a string directory path. |
| options                  | object          | Detailed in [Options](https://www.gulpjs.com.cn/docs/api/symlink#options) below.                                                                                                          |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/symlink#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

A stream that can be used in the middle or at the end of a pipeline to create symbolic links on the file system. Whenever a Vinyl object is passed through the stream, it creates a symbolic link to the original file on the file system at the given directory.

Whenever a symbolic link is created on the file system, the Vinyl object will be modified.

* The `cwd`, `base`, and `path` properties will be updated to match the created symbolic link.
* The `stat` property will be updated to match the symbolic link on the file system.
* The `contents` property will be set to `null`.
* The `symlink` property will be added or replaced with original path.

**Note:**  On Windows, directory links are created using junctions by default. The `useJunctions` option disables this behavior.

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/symlink#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

When `directory` is an empty string, throws an error with the message, "Invalid symlink() folder argument. Please specify a non-empty string or a function."

When `directory` is not a string or function, throws an error with the message, "Invalid symlink() folder argument. Please specify a non-empty string or a function."

When `directory` is a function that returns an empty string or `undefined`, emits an error with the message, "Invalid output folder".

### 选项[​](https://www.gulpjs.com.cn/docs/api/symlink#%E9%80%89%E9%A1%B9 "Direct link to 选项")

**对于接受函数的选项，传递的函数将与每个 Vinyl 对象一起调用，并且必须返回另一个列出类型的值。**

| name             | type             | default         | note                                                                                                                                                                                                                                          |
| ---------------- | ---------------- | --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cwd              | string function  | `process.cwd()` | The directory that will be combined with any relative path to form an absolute path. Is ignored for absolute paths. Use to avoid combining `directory` with `path.join()`.                                                                    |
| dirMode          | number function  |                 | The mode used when creating directories. If not set, the process' mode will be used.                                                                                                                                                          |
| overwrite        | boolean function | true            | When true, overwrites existing files with the same path.                                                                                                                                                                                      |
| relativeSymlinks | boolean function | false           | When false, any symbolic links created will be absolute. **Note**: Ignored if a junction is being created, as they must be absolute.                                                                                                          |
| useJunctions     | boolean function | true            | This option is only relevant on Windows and ignored elsewhere. When true, creates directory symbolic link as a junction. Detailed in [Symbolic links on Windows](https://www.gulpjs.com.cn/docs/api/symlink#symbolic-links-on-windows) below. |

## Symbolic links on Windows[​](https://www.gulpjs.com.cn/docs/api/symlink#symbolic-links-on-windows "Direct link to Symbolic links on Windows")

When creating symbolic links on Windows, a `type` argument is passed to Node's `fs.symlink()` method which specifies the type of target being linked. The link type is set to:

* `'file'` when the target is a regular file
* `'junction'` when the target is a directory
* `'dir'` when the target is a directory and the user disables the `useJunctions` option

If you try to create a dangling (pointing to a non-existent target) link, the link type can't be determined automatically. In these cases, behavior will vary depending on whether the dangling link is being created via `symlink()` or via `dest()`.

For dangling links created via `symlink()`, the incoming Vinyl object represents the target, so its stats will determine the desired link type. If `isDirectory()` returns false then a `'file'` link is created, otherwise a `'junction'` or `'dir'` link is created depending on the value of the `useJunctions` option.

For dangling links created via `dest()`, the incoming Vinyl object represents the link - typically loaded from disk via `src(..., { resolveSymlinks: false })`. In this case, the link type can't be reasonably determined and defaults to using `'file'`. This may cause unexpected behavior when creating a dangling link to a directory. **Avoid this scenario.**

# lastRun()

检索在当前运行进程中成功完成任务的最后一次时间。最有用的后续任务运行时，监视程序正在运行。当监视程序正在运行时，对于后续的任务运行最有用。

当与 `src()` 组合时，通过跳过自上次成功完成任务以来没有更 改的文件，使增量构建能够加快执行时间。

## 用法[​](https://www.gulpjs.com.cn/docs/api/lastrun#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { src, dest, lastRun, watch } = require('gulp');
const imagemin = require('gulp-imagemin');

function images() {
  return src('src/images/**/*.jpg', { since: lastRun(images) })
    .pipe(imagemin())
    .pipe(dest('build/img/'));
}

exports.default = function() {
  watch('src/images/**/*.jpg', images);
};
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/lastrun#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
lastRun(task, [precision])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/lastrun#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数                  | 类型              | 描述                                                                                                                                        |
| ------------------- | --------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| task **(required)** | function string | 已注册任务的任务函数或字符串别名。                                                                                                                         |
| precision           | number          | 默认值： Node v0.10 版本中是 `1000`，在 Node v0.12+ 版本中是 `0` 。在下面的 [时间戳精度](https://www.gulpjs.com.cn/docs/api/lastrun#timestamp-precision) 章中有详细说明。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/lastrun#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个时间戳（以毫秒为单位），表示任务的最后完成时间。如果任务尚未运行或已经失败，则返回 `undefined`。

为了避免缓存无效状态（invalid state），因此，如果任务出错，则返回值为 `undefined`。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/lastrun#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当传入的参数值不是字符串或函数时，会抛出一个错误，并显示错误信息 "Only functions can check lastRun"。

当对不可扩展的函进行数调或 Node 不支持 WeakMap 时，会抛出一个错误，并显示错误信息 "Only extensible functions can check lastRun"。

## 时间戳精度[​](https://www.gulpjs.com.cn/docs/api/lastrun#%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E5%BA%A6 "Direct link to 时间戳精度")

虽然时间戳的精度有合理的默认值，但仍然可以通过 `precision` 参数对其进行舍入。如果你所使用文件系统或 Node 版本对文件的时间属性精度不高的话，则很有用。

* `lastRun(someTask)` 返回 1426000001111
* `lastRun(someTask, 100)` 返回 1426000001100
* `lastRun(someTask, 1000)` 返回 1426000001000

文件的 [mtime stat](https://www.gulpjs.com.cn/docs/api/concepts#file-system-stats) 精度会由于 node 版本和/或所用的文件系统而出现误差。

| 平台                        | 精度     |
| ------------------------- | ------ |
| Node v0.10                | 1000ms |
| Node v0.12+               | 1ms    |
| FAT32 file system         | 2000ms |
| HFS+ or Ext3 file systems | 1000ms |
| NTFS using Node v0.10     | 1s     |
| NTFS using Node 0.12+     | 100ms  |
| Ext4 using Node v0.10     | 1000ms |
| Ext4 using Node 0.12+     | 1ms |

# series()

将任务函数和/或组合操作组合成更大的操作，这些操作将按顺序依次执行。对于使用 `series()` 和 `parallel()` 组合操作的嵌套深度没有强制限制。

## 用法[​](https://www.gulpjs.com.cn/docs/api/series#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { series } = require('gulp');

function javascript(cb) {
  // body omitted
  cb();
}

function css(cb) {
  // body omitted
  cb();
}

exports.build = series(javascript, css);
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/series#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
series(...tasks)
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/series#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数                   | 类型              | 描述                                                |
| -------------------- | --------------- | ------------------------------------------------- |
| tasks **(required)** | function string | 任意数量的任务函数都可以作为单独的参数传递。如果您以前注册过任务，可以使用字符串，但不建议这样做。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/series#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个组合操作，它将注册为任务或嵌套在其他 `series` 和/或 `parallel` 组合中。

当执行组合操作时，所有任务将按顺序运行。如果一个任务中发生错误，则不会运行后续任务。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/series#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当没有传递任何任务时，抛出一个错误，并提示 "One or more tasks should be combined using series or parallel"。（一个或多个应该使用 series 或 parallel 组合的任务”。）

当传递无效的任务或未注册的任务时，将抛出一个错误，显示 "Task never defined"（任务从未定义）。

## 向前引用（Forward references）[​](https://www.gulpjs.com.cn/docs/api/series#%E5%90%91%E5%89%8D%E5%BC%95%E7%94%A8forward-references "Direct link to 向前引用（Forward references）")

向前引用是指使用尚未注册的字符串引用组合任务。在旧版本中，这是一种常见的实践，但是为了实现更快的任务运行时间和促进使用命名函数，删除了该特性。

在较新的版本中，如果尝试使用向前引用，将会得到一个错误，消息为 “Task never defined”。当您尝试为您的任务注册*和*按字符串组合任务使用 `exports` 时，可能会遇到这种情况。在这种情况下，使用命名函数而不是字符串引用。

在迁移期间，您可能需要使用 [forward reference registry](https://github.com/gulpjs/undertaker-forward-reference)。这将为每个任务引用添加一个额外的闭包，并显著降低构建速度。**不要太长时间依赖这个修复程序**。

## 避免重复任务[​](https://www.gulpjs.com.cn/docs/api/series#%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E4%BB%BB%E5%8A%A1 "Direct link to 避免重复任务")

当运行组合操作时，每个任务将在每次提供时执行。

在两个不同的组合中引用的 `clean` 任务将运行两次，将导致不期望的结果。因此，建议在最终组合中指定 `clean` 任务。

If you have code like this:

```
// This is INCORRECT
const { series, parallel } = require('gulp');

const clean = function(cb) {
  // body omitted
  cb();
};

const css = series(clean, function(cb) {
  // body omitted
  cb();
});

const javascript = series(clean, function(cb) {
  // body omitted
  cb();
});

exports.build = parallel(css, javascript);
```

可转换为：

```
const { series, parallel } = require('gulp');

function clean(cb) {
  // body omitted
  cb();
}

function css(cb) {
  // body omitted
  cb();
}

function javascript(cb) {
  // body omitted
  cb();
}

exports.build = series(clean, parallel(css, javascript));
```

# parallel()

将任务功能和/或组合操作组合成同时执行的较大操作。对于使用 `series()` 和 `parallel()` 进行嵌套组合的深度没有强制限制。

## 用法[​](https://www.gulpjs.com.cn/docs/api/parallel#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { parallel } = require('gulp');

function javascript(cb) {
  // body omitted
  cb();
}

function css(cb) {
  // body omitted
  cb();
}

exports.build = parallel(javascript, css);
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/parallel#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
parallel(...tasks)
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/parallel#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数                   | 类型              | 注解                                                |
| -------------------- | --------------- | ------------------------------------------------- |
| tasks **(required)** | function string | 任意数量的任务函数都可以作为单独的参数传递。如果您以前注册过任务，可以使用字符串，但不建议这样做。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/parallel#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个组合操作，它将注册为任务或嵌套在其他 `series` 和/或 `parallel` 组合中。

当执行组合操作时，所有任务将以最大并发性运行。如果一个任务发生错误，其他任务可能不确定地完成，也可能不完成。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/parallel#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当没有传递任何任务时，抛出一个错误，并提示 "One or more tasks should be combined using series or parallel"。（一个或多个应该使用 series 或 parallel 组合的任务”。）

当传递无效的任务或未注册的任务时，将抛出一个错误，显示 "Task never defined"（任务从未定义）。

## 向前引用（Forward references）[​](https://www.gulpjs.com.cn/docs/api/parallel#%E5%90%91%E5%89%8D%E5%BC%95%E7%94%A8forward-references "Direct link to 向前引用（Forward references）")

向前引用是指使用尚未注册的字符串引用组合任务。在旧版本中，这是一种常见的实践，但是为了实现更快的任务运行时间和促进使用命名函数，删除了该特性。

在较新的版本中，如果尝试使用向前引用，将会得到一个错误，消息为 “Task never defined”。当您尝试为您的任务注册*和*按字符串组合任务使用 `exports` 时，可能会遇到这种情况。在这种情况下，使用命名函数而不是字符串引用。

在迁移期间，您可能需要使用 [forward reference registry](https://github.com/gulpjs/undertaker-forward-reference)。这将为每个任务引用添加一个额外的闭包，并显著降低构建速度。**不要太长时间依赖这个修复程序**。

## 避免重复任务[​](https://www.gulpjs.com.cn/docs/api/parallel#%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E4%BB%BB%E5%8A%A1 "Direct link to 避免重复任务")

当一个组合操作执行时，每个任务（task）的每次调用都将被执行。

在两个不同的组合中引用的 `clean` 任务将运行两次，将导致不期望的结果。因此，建议在最终的组合中指定 `clean` 任务。

如果你有如下代码：

```
// This is INCORRECT
const { series, parallel } = require('gulp');

const clean = function(cb) {
  // body omitted
  cb();
};

const css = series(clean, function(cb) {
  // body omitted
  cb();
});

const javascript = series(clean, function(cb) {
  // body omitted
  cb();
});

exports.build = parallel(css, javascript);
```

可转换为：

```
const { series, parallel } = require('gulp');

function clean(cb) {
  // body omitted
  cb();
}

function css(cb) {
  // body omitted
  cb();
}

function javascript(cb) {
  // body omitted
  cb();
}

exports.build = series(clean, parallel(css, javascript));
```

# watch()

监听 globs 并在发生更改时运行任务。任务与任务系统的其余部分被统一处理。

## 用法[​](https://www.gulpjs.com.cn/docs/api/watch#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { watch } = require('gulp');

watch(['input/*.js', '!input/something.js'], function(cb) {
  // body omitted
  cb();
});
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/watch#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
watch(globs, [options], [task])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/watch#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数                   | 类型              | 描述                                                                                                 |
| -------------------- | --------------- | -------------------------------------------------------------------------------------------------- |
| globs **(required)** | string array    | 监听文件系统中匹配 [Globs](https://www.gulpjs.com.cn/docs/api/concepts#globs) 的文件。                          |
| options              | object          | 详情参见下文 [选项](https://www.gulpjs.com.cn/docs/api/watch#options) 。                                    |
| task                 | function string | 一个 [任务函数](https://www.gulpjs.com.cn/docs/api/concepts#tasks) 或由 `series()` 和 `parallel()` 生成的组合任务。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/watch#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

[chokidar](https://www.gulpjs.com.cn/docs/api/watch#chokidar-instance) 的一个实例，用于对监听设置进行细粒度控制。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/watch#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当以 `globs` 形式传递非字符串或带有任何非字符串的数组时，将抛出一个错误，并提示 "Non-string provided as watch path"。

当字符串或数组作为 `task` 传递时，会抛出一个错误，提示 "watch task has to be a function (optionally generated by using gulp.parallel or gulp.series)"（ watch 任务必须是一个函数(可以选择使用 gulp.parallel 或 gulp.series 生成))。

### 选项[​](https://www.gulpjs.com.cn/docs/api/watch#%E9%80%89%E9%A1%B9 "Direct link to 选项")

| 名称                     | 类型                           | 默认值                           | 描述                                                                                                                                                                                                                                                                                                     |
| ---------------------- | ---------------------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ignoreInitial          | boolean                      | true                          | false，则在实例化过程中调用该任务，以发现文件路径。用于在启动期间触发任务。 **注意:**  这个选项被传递给 [chokidar](https://github.com/paulmillr/chokidar)，但默认为 `true` 而不是 `false`。                                                                                                                                                                  |
| delay                  | number                       | 200                           | 文件更改和任务执行之间的毫秒延迟。允许在执行任务之前等待许多更改，例如查找和替换许多文件。                                                                                                                                                                                                                                                          |
| queue                  | boolean                      | true                          | 当为 true 且任务已经运行时，任何文件更改都将对单个任务执行进行排队。避免长时间运行的任务重叠。                                                                                                                                                                                                                                                     |
| events                 | string array                 | \[ 'add', 'change', 'unlink' ] | 正在监听的事件，以触发任务执行。可以是 `'add'`、`'addDir'`、`'change'`、`'unlink'`、`'unlinkDir'`, `'ready'`、和/或 `'error'`。 另外 `'all'` 也是可用的，它表示除 `'ready'` 和 `'error'` 之外的所有事件。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                               |
| persistent             | boolean                      | true                          | 如果为 false，监听器将不会保持 Node 进程的运行。不建议禁用此选项。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                                                 |
| ignored                | array string RegExp function |                               | Defines globs to be ignored. If a function is provided, it will be called twice per path - once with just the path, then with the path and the `fs.Stats` object of that file. *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                          |
| followSymlinks         | boolean                      | true                          | 如果为 true，对符号链接和链接的文件的更改都将触发事件。如果为 false，则只有对符号链接的更改才触发事件。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                               |
| cwd                    | string                       |                               | 将与任何相对路径相结合以形成绝对路径的目录。对于绝对路径忽略。用于避免将 `globs` 与 `path.join()` 组合使用。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                      |
| disableGlobbing        | boolean                      | false                         | 如果为 true，所有 `globs` 都被视为字面路径名称，即使它们具有特殊字符。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                                              |
| usePolling             | boolean                      | false                         | 当为 false 时，监听器将使用 `fs.watch()`（或 Mac 上的 [fsevents](https://github.com/strongloop/fsevents)）(或[fsevents](https://github.com/strongloop/fsevents))进行监听。如果为 true，则使用 `fs.watchFile()` 轮询代替——这是通过网络或其他非标准情况成功监听文件所必需的。覆盖 `useFsEvents` 默认值。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).* |
| interval               | number                       | 100                           | 与 `usePolling: true` 配套使用。表示文件系统轮询的间隔。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                                                  |
| binaryInterval         | number                       | 300                           | 与 `usePolling: true` 配套使用。表示文件系统轮询二进制文件的间隔。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                                             |
| useFsEvents            | boolean                      | true                          | 如果为 true 且 fsevents 可用， 则使用 fsevents 进行监听。如果显式设置为 true，则替代 `usePolling` 选项。如果设置为 false，则自动将 `usePolling` 设置为 true。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                      |
| alwaysStat             | boolean                      | false                         | 如果为 true，总是调用 `fs.stat()` 对已更改的文件——将减慢文件监听器。只有在直接使用chokidar 实例时，`fs.Stat` 的对象才可用。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                       |
| depth                  | number                       |                               | 指示将监听多少级嵌套目录。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                                                                           |
| awaitWriteFinish       | boolean                      | false                         | 不要使用这个选项，而是使用 `delay`。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                                                                  |
| ignorePermissionErrors | boolean                      | false                         | 设置为 true 以监听没有读取权限的文件。然而，如果由于 EPERM 或 EACCES 错误导致监听失败，则会自动跳过。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                                                                                           |
| atomic                 | number                       | 100                           | 只有在 `useFsEvents` 和 `usePolling` 为 false 时才激活。自动过滤掉一些编辑器从 "atomic writes" 中产生的工件。如果文件在删除后的指定毫秒内重新添加，则会发出一个更改事件(而不是取消链接然后添加)。 *此选项被直接传递给 [chokidar](https://github.com/paulmillr/chokidar).*                                                                                                            |

## Chokidar 实例[​](https://www.gulpjs.com.cn/docs/api/watch#chokidar-%E5%AE%9E%E4%BE%8B "Direct link to Chokidar 实例")

`watch()` 方法返回 [chokidar](https://github.com/paulmillr/chokidar) 的底层实例，提供对监听设置的细粒度控制。最常用来注册提供更改文件的 `path` 或 `stats` 的单个事件处理程序。

**当直接使用 chokidar 实例时，您将无法访问任务系统集成，包括异步完成、队列和延迟**

```
const { watch } = require('gulp');

const watcher = watch(['input/*.js']);

watcher.on('change', function(path, stats) {
  console.log(`File ${path} was changed`);
});

watcher.on('add', function(path, stats) {
  console.log(`File ${path} was added`);
});

watcher.on('unlink', function(path, stats) {
  console.log(`File ${path} was removed`);
});

watcher.close();
```

`watcher.on(eventName, eventHandler)`

注册 `eventHandler` 函数，当指定的事件发生时调用该函数。

| 参数           | 类型       | 描述                                                                                               |
| ------------ | -------- | ------------------------------------------------------------------------------------------------ |
| eventName    | string   | 可以观察到的事件有 `'add'`、`'addDir'`、`'change'`、`'unlink'`、`'unlinkDir'`、`'ready'`、`'error'`、 或 `'all'`. |
| eventHandler | function | 当指定的事件发生时调用的函数。参数详见下表。                                                                           |

| 参数    | 类型     | 描述                                                                                                                                            |
| ----- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------- |
| path  | string | 已更改的文件的路径。如果设置了 `cwd` 选项，则是通过删除 `cwd` 的相对路径。                                                                                                  |
| stats | object | 一个 [fs.Stat](https://www.gulpjs.com.cn/docs/api/concepts#file-system-stats) 对象，但可以是 `undefined`。如果 `alwaysStat` 选项被设置为 `true`，`stats` 将始终被提供。 |

`watcher.close()`

关闭文件监听器。一旦关闭，就不会再发出任何事件。

`watcher.add(globs)`

向已经运行的监听器实例添加额外的 globs。

| 参数    | 类型           | 描述            |
| ----- | ------------ | ------------- |
| globs | string array | 额外需要监听的 glob。 |

`watcher.unwatch(globs)`

删除正在被监听的 globs，而监视程序继续使用剩余的路径。

| 参数    | 类型           | 描述         |
| ----- | ------------ | ---------- |
| globs | string array | 要删除的 glob。|

# task()

**提醒**: 这个API不再是推荐的模式了 - [export your tasks](https://www.gulpjs.com.cn/docs/getting-started/creating-tasks)。因此就不翻译了！

在任务系统中定义任务。然后可以从命令行和 `series()`、`parallel()` 和 `lastRun()` api 访问该任务。

## Usage[​](https://www.gulpjs.com.cn/docs/api/task#usage "Direct link to Usage")

Register a named function as a task:

```
const { task } = require('gulp');

function build(cb) {
  // body omitted
  cb();
}

task(build);
```

Register an anonymous function as a task:

```
const { task } = require('gulp');

task('build', function(cb) {
  // body omitted
  cb();
});
```

Retrieve a task that has been registered previously:

```
const { task } = require('gulp');

task('build', function(cb) {
  // body omitted
  cb();
});

const build = task('build');
```

## Signature[​](https://www.gulpjs.com.cn/docs/api/task#signature "Direct link to Signature")

```
task([taskName], taskFunction)
```

### Parameters[​](https://www.gulpjs.com.cn/docs/api/task#parameters "Direct link to Parameters")

If the `taskName` is not provided, the task will be referenced by the `name` property of a named function or a user-defined `displayName` property. The `taskName` parameter must be used for anonymous functions missing a `displayName` property.

Since any registered task can be run from the command line, avoid using spaces in task names.

| parameter                   | type     | note                                                                                                                                                                                                                                                                                                 |
| --------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| taskName                    | string   | An alias for the task function within the task system. Not needed when using named functions for `taskFunction`.                                                                                                                                                                                     |
| taskFunction **(required)** | function | A [task function](https://www.gulpjs.com.cn/docs/api/concepts#tasks) or composed task - generated by `series()` and `parallel()`. Ideally a named function. [Task metadata](https://www.gulpjs.com.cn/docs/api/task#task-metadata) can be attached to provide extra information to the command line. |

### Returns[​](https://www.gulpjs.com.cn/docs/api/task#returns "Direct link to Returns")

When registering a task, nothing is returned.

When retrieving a task, a wrapped task (not the original function) registered as `taskName` will be returned. The wrapped task has an `unwrap()` method that will return the original function.

### Errors[​](https://www.gulpjs.com.cn/docs/api/task#errors "Direct link to Errors")

When registering a task where `taskName` is missing and `taskFunction` is anonymous, will throw an error with the message, "Task name must be specified".

## Task metadata[​](https://www.gulpjs.com.cn/docs/api/task#task-metadata "Direct link to Task metadata")

| property    | type   | note                                                                                                                                                                                                                                |
| ----------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name        | string | A special property of named functions. Used to register the task. **Note:**  [`name`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) is not writable; it cannot be set or changed. |
| displayName | string | When attached to a `taskFunction` creates an alias for the task. If using characters that aren't allowed in function names, use this property.                                                                                      |
| description | string | When attached to a `taskFunction` provides a description to be printed by the command line when listing tasks.                                                                                                                      |
| flags       | object | When attached to a `taskFunction` provides flags to be printed by the command line when listing tasks. The keys of the object represent the flags and the values are their descriptions.                                            |

```
const { task } = require('gulp');

const clean = function(cb) {
  // body omitted
  cb();
};
clean.displayName = 'clean:all';

task(clean);

function build(cb) {
  // body omitted
  cb();
}
build.description = 'Build the project';
build.flags = { '-e': 'An example flag' };

task(build);
```

# registry()

允许将自定义的注册表插入到任务系统中，以便提供共享任务或增强功能。

**注意：**  只有用 `task()` 方法注册的任务才会进入自定义注册表中。直接传递给 `series()` 或 `parallel()` 的任务函数（task functions）不会进入自定义任务注册表 - 如果你需要自定义注册表的行为，请通过字符串引用的方式将任务（task）组合在一起。

分配新注册表时，将传输当前注册表中的每个任务，并将用新注册表替换当前注册表。这允许按顺序添加多个自定义注册表。

有关详细信息，请参考 [创建自定义注册表](https://www.gulpjs.com.cn/docs/advanced/creating-custom-registries) 。

## 用法[​](https://www.gulpjs.com.cn/docs/api/registry#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const { registry, task, series } = require('gulp');
const FwdRef = require('undertaker-forward-reference');

registry(FwdRef());

task('default', series('forward-ref'));

task('forward-ref', function(cb) {
  // body omitted
  cb();
});
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/registry#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
registry([registryInstance])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/registry#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数               | 类型     | 注解               |
| ---------------- | ------ | ---------------- |
| registryInstance | object | 自定义注册表的实例(而不是类)。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/registry#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

如果传递了 `registryInstance`，则不会返回任何内容。如果没有传递参数，则返回当前注册表实例。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/registry#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

#### 参数错误[​](https://www.gulpjs.com.cn/docs/api/registry#%E5%8F%82%E6%95%B0%E9%94%99%E8%AF%AF "Direct link to 参数错误")

当构造函数（而不是实例）作为 `registryInstance` 传递时，将抛出一个错误（error），并且提示信息如下：

> Custom registries must be instantiated, but it looks like you passed a constructor.（自定义注册表必须实例化，但看起来你传递的是一个构造函数啊，亲！）

#### 缺少 `get` 方法[​](https://www.gulpjs.com.cn/docs/api/registry#%E7%BC%BA%E5%B0%91-get-%E6%96%B9%E6%B3%95 "Direct link to 缺少-get-方法")

当一个没有 `get` 方法的注册表作为 `registryInstance` 传递时，将抛出一个错误（error），并且提示信息如下：

> Custom registry must have `get` function.（自定义注册表必须具备 `get` 函数。）

#### 缺少 `set` 方法[​](https://www.gulpjs.com.cn/docs/api/registry#%E7%BC%BA%E5%B0%91-set-%E6%96%B9%E6%B3%95 "Direct link to 缺少-set-方法")

当一个没有 `set` 方法的注册表作为 `registryInstance` 传递时，将抛出一个错误（error），并且提示信息如下：

> Custom registry must have `set` function.（自定义注册表必须具有 `set` 函数。）

#### 缺少 `init` 方法[​](https://www.gulpjs.com.cn/docs/api/registry#%E7%BC%BA%E5%B0%91-init-%E6%96%B9%E6%B3%95 "Direct link to 缺少-init-方法")

当一个没有 `init` 方法的注册表作为 `registryInstance` 传递时，将抛出一个错误（error），并且提示信息如下：

> Custom registry must have `init` function"（自定义注册表必须具有 `init` 函数。）

#### 缺少 `tasks` 方法[​](https://www.gulpjs.com.cn/docs/api/registry#%E7%BC%BA%E5%B0%91-tasks-%E6%96%B9%E6%B3%95 "Direct link to 缺少-tasks-方法")

当一个没有 `tasks` 方法的注册表作为 `registryInstance` 传递时，将抛出一个错误（error），并且提示信息如下：

> Custom registry must have `tasks` function.（自定义注册表必须具有 `tasks` 函数。）

# tree()

获取当前任务依赖关系树——在极少数情况下需要它。

通常，gulp 使用者不会使用 `tree()`，但它是公开的，因此 CLI 可以显示在 gulpfile 中定义的任务的依赖关系图。

## 用法[​](https://www.gulpjs.com.cn/docs/api/tree#%E7%94%A8%E6%B3%95 "Direct link to 用法")

Example gulpfile:

```

const { series, parallel } = require('gulp');

function one(cb) {
  // body omitted
  cb();
}

function two(cb) {
  // body omitted
  cb();
}

function three(cb) {
  // body omitted
  cb();
}

const four = series(one, two);

const five = series(four,
  parallel(three, function(cb) {
    // Body omitted
    cb();
  })
);

module.exports = { one, two, three, four, five };
```

`tree()` 的输出:

```
{
  label: 'Tasks',
  nodes: [ 'one', 'two', 'three', 'four', 'five' ]
}
```

`tree({ deep: true })` 的输出:

```
{
  label: "Tasks",
  nodes: [
    {
      label: "one",
      type: "task",
      nodes: []
    },
    {
      label: "two",
      type: "task",
      nodes: []
    },
    {
      label: "three",
      type: "task",
      nodes: []
    },
    {
      label: "four",
      type: "task",
      nodes: [
        {
          label: "<series>",
          type: "function",
          branch: true,
          nodes: [
            {
              label: "one",
              type: "function",
              nodes: []
            },
            {
              label: "two",
              type: "function",
              nodes: []
            }
          ]
        }
      ]
    },
    {
      label: "five",
      type: "task",
      nodes: [
        {
          label: "<series>",
          type: "function",
          branch: true,
          nodes: [
            {
              label: "<series>",
              type: "function",
              branch: true,
              nodes: [
                {
                  label: "one",
                  type: "function",
                  nodes: []
                },
                {
                  label: "two",
                  type: "function",
                  nodes: []
                }
              ]
            },
            {
              label: "<parallel>",
              type: "function",
              branch: true,
              nodes: [
                {
                  label: "three",
                  type: "function",
                  nodes: []
                },
                {
                  label: "<anonymous>",
                  type: "function",
                  nodes: []
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/tree#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
tree([options])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/tree#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数      | 类型     | 描述                                                             |
| ------- | ------ | -------------------------------------------------------------- |
| options | object | 详情请见下文 [选项](https://www.gulpjs.com.cn/docs/api/tree#options) 。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/tree#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个详细描述已注册的任务树的对象——包含具有 `'label'` 和 `'nodes'` 属性的嵌套对象(与 [archy](https://www.npmjs.com/package/archy) 兼容)。

每个对象可能有一个 `type` 属性，用于确定节点是 `task` 还是 `function`。

每个对象可能有一个 `branch` 属性，当 `true` 时，该属性指示节点是使用 `series()` 还是 `parallel()` 创建的。

### 选项[​](https://www.gulpjs.com.cn/docs/api/tree#%E9%80%89%E9%A1%B9 "Direct link to 选项")

| name | type    | default | note                                |
| ---- | ------- | ------- | ----------------------------------- |
| deep | boolean | false   | 如果为 true，则返回整个树。如果为 false，则只返回顶级任务。

# Vinyl

虚拟的文件格式。当 `src()` 读取文件时，将生成一个 Vinyl 对象来表示文件——包括路径、内容和其他元数据。

Vinyl 对象可以使用[插件](https://www.gulpjs.com.cn/docs/getting-started/using-plugins)进行转换。还可以使用 `dest()` 将它们持久化到文件系统。

当创建您自己的 Vinyl 对象时——而不是使用 `src()` 生成——使用外部 `vinyl` 模块，如下面的用法所示。

## 用法[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const Vinyl = require('vinyl');

const file = new Vinyl({
  cwd: '/',
  base: '/test/',
  path: '/test/file.js',
  contents: new Buffer('var x = 123')
});

file.relative === 'file.js';

file.dirname === '/test';
file.dirname = '/specs';
file.path === '/specs/file.js';

file.basename === 'file.js';
file.basename = 'file.txt';
file.path === '/specs/file.txt';

file.stem === 'file';
file.stem = 'foo';
file.path === '/specs/foo.txt';
file.extname === '.txt';
file.extname = '.js';
file.path === '/specs/foo.js';
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
new Vinyl([options])
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数      | 类型     | 描述                                                              |
| ------- | ------ | --------------------------------------------------------------- |
| options | object | 详情请参加下文 [选项](https://www.gulpjs.com.cn/docs/api/vinyl#options)。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

返回一个 Vinyl 类的实例，表示一个单独的虚拟文件，详见下面的 [Vinyl 实例](https://www.gulpjs.com.cn/docs/api/vinyl#vinyl-instance)。

### 可能出现的错误[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF "Direct link to 可能出现的错误")

当传递的任何选项都不符合表中定义的[实例属性定义](https://www.gulpjs.com.cn/docs/api/vinyl#instance-properties)(如 `path` 被设置为一个数字)时抛出错误。

### 选项[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E9%80%89%E9%A1%B9 "Direct link to 选项")

| 名称       | 类型                           | 默认住             | 注                                                                                                                                                                                                                                              |
| -------- | ---------------------------- | --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cwd      | string                       | `process.cwd()` | 此目录用于推导相对路径。该目录路径将被 [规范化（normalized）](https://www.gulpjs.com.cn/docs/api/vinyl#normalization-and-concatenation) 并删除结尾的目录分隔符。                                                                                                                   |
| base     | string                       |                 | 用于计算 `relative` 实例属性。 如果没有设置，则回退到 `cwd` 的值。通常设置为 [glob base](https://www.gulpjs.com.cn/docs/api/concepts#glob-base)。该路径将被 [规范化（normalized）](https://www.gulpjs.com.cn/docs/api/vinyl#normalization-and-concatenation) 并删除结尾的目录分隔符。             |
| path     | string                       |                 | 完整的绝对文件路径。该路径将被 [规范化（normalized）](https://www.gulpjs.com.cn/docs/api/vinyl#normalization-and-concatenation) 并删除结尾的目录分隔符。                                                                                                                       |
| history  | array                        | `[ ]`           | 此路径数组用于预先填充 Vinyl 实例的 `history` 属性。通常是从先前的 Vinyl 对象衍生处新的 Vinyl 对象。通过同时传递了 `path` 和 `history` 参数，则将`path` 附加到 `history` 后面。数组中的每个条目都将被 [规范化（normalized）](https://www.gulpjs.com.cn/docs/api/vinyl#normalization-and-concatenation) 并删除结尾的目录分隔符。 |
| stat     | object                       |                 | 一个 `fs.Stats` 实例，通常是对文件调用 `fs.stat()` 的结果。用于确定 Vinyl 对象是否表示一个目录或符号链接。                                                                                                                                                                          |
| contents | ReadableStream Buffer `null` | `null`          | 文件的内容。如果 `contents` 是一个 ReadableStream，它将被包装进一个 [cloneable-readable](https://github.com/mcollina/cloneable-readable) 流(stream                                                                                                                  |
| )中。      |                              |                 |                                                                                                                                                                                                                                                |

`options` 上的任何其他属性都将直接分配给 Vinyl 实例。

```
const Vinyl = require('vinyl');

const file = new Vinyl({ foo: 'bar' });
file.foo === 'bar';
```

## Vinyl 实例[​](https://www.gulpjs.com.cn/docs/api/vinyl#vinyl-%E5%AE%9E%E4%BE%8B "Direct link to Vinyl 实例")

每个 Vinyl 对象实例都具有访问和/或修改虚拟文件信息的属性和方法。

### 实例属性[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7 "Direct link to 实例属性")

所有内部管理的路径——除了 `contents` 和 `stat` 之外的任何实例属性——都被规范化，并删除了末尾分隔符。有关更多信息，请参见[规范化和连接](https://www.gulpjs.com.cn/docs/api/vinyl#normalization-and-concatenation)。

| 属性       | 类型                           | 描述                                                                                                                                                                                               | 抛出错误                                         |
| -------- | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| contents | ReadableStream Buffer `null` | 获取和设置虚拟文件的内容。如果将其设置为 ReadableStream，它将被包装在一个 [cloneable-readable](https://github.com/mcollina/cloneable-readable) 流（stream）中。                                                                    | 如果设置为 ReadableStream、Buffer 或 `null` 之外的任何值。 |
| stat     | object                       | 获取或设置 [`fs.Stats`](https://www.gulpjs.com.cn/docs/api/concepts#file-system-stats) 的实例。当确定 Vinyl 对象是否表示目录或符号链接时使用。                                                                                |                                              |
| cwd      | string                       | 获取并设置当前工作目录。用于推导相对路径。                                                                                                                                                                            | 如果设置为空字符串或任何非字符串值。                           |
| base     | string                       | 获取和设置起始目录（base directory）。用于计算实例的 `relative` 属性。在由 `src()` 生成的 Vinyl 对象上，将设置为 [glob base](https://www.gulpjs.com.cn/docs/api/concepts#glob-base)。如果设置为 `null` 或 `undefined`，则会用实例属性 `cwd` 的值来代替。 | 如果设置为空字符串或任何非字符串值(`null` 或 `undefined` 除外)。  |
| path     | string                       | 获取和设置完整的绝对文件路径。设置为与当前 `path` 不同的值会将新路径附加到 `history` 实例属性中。                                                                                                                                       | 如果设置为任何非字符串值。                                |
| history  | array                        | 已分配的 Vinyl 对象的所有 `path` 值的数组。第一个元素是原始路径，最后一个元素是当前路径。此属性及其包含元素应被视为只读，仅通过设置 `path` 实例属性间接更改。                                                                                                       |                                              |
| relative | string                       | 获取 `base` 和 `path` 实例属性之间的相对路径段。                                                                                                                                                                 | 如果设置为任何值。如果在 `path` 不可用时访问。                  |
| dirname  | string                       | 获取和设置 `path` 实例属性的目录。                                                                                                                                                                            | 如果在 `path` 不可用时访问。                           |
| stem     | string                       | 获取和设置 `path` 实例属性的不带扩展名的文件名。                                                                                                                                                                     | 如果在 `path` 不可用时访问。                           |
| extname  | string                       | 获取和设置 `path` 实例属性的扩展名。                                                                                                                                                                           | 如果在 `path` 不可用时访问。                           |
| basename | string                       | 获取和设置 `path` 实例属性的文件名(`stem + extname`)。                                                                                                                                                         | 如果在 `path` 不可用时访问。                           |
| symlink  | string                       | 获取和设置符号链接的引用路径。                                                                                                                                                                                  | 如果设置为任何非字符串值。                                |

### 实例方法[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95 "Direct link to 实例方法")

| 方法                 | 返回值类型   | 返回值                                                                                                                                                                                                 |
| ------------------ | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `isBuffer()`       | boolean | 如果 `contents` 实例属性是一个 Buffer，则返回 true。                                                                                                                                                              |
| `isStream()`       | boolean | 如果 `contents` 实例属性是一个 Stream，则返回 true。                                                                                                                                                              |
| `isNull()`         | boolean | 如果 `contents` 实例属性为 `null`，则返回 true。                                                                                                                                                                |
| `isDirectory()`    | boolean | 如果实例表示一个目录，则返回 true。当 `isNull()` 返回 true，`stat` 实例属性是一个对象，并且 `stat.isDirectory()` 返回 true 时，实例被认为是一个目录。这假设 Vinyl 对象是用一个有效的（或适当模拟的） `fs.Stats` 对象构造的。                                                |
| `isSymbolic()`     | boolean | 如果实例表示符号链接，则返回 true。 当 `isNull()` 返回 true，`stat` 实例属性是一个对象，并且 `stat.isSymbolicLink()` 返回 true 时， 实例被认为是 symbolic。 这假设 Vinyl 对象是用一个有效的（或适当模拟的） `fs.Stats` 对象构造的。                                     |
| `clone([options])` | object  | A new Vinyl object with all properties cloned. 一个使用所有属性克隆出的新的 Vinyl 对象。 默认情况下，自定义属性是深拷贝。如果 `deep` 选项为 false，自定义属性将被浅拷贝。如果 `contents` 选项设置为 fasle 并且 `contents` 属性是一个 Buffer，那么这个 Buffer 将被复用，而不是克隆。 |
| `inspect()`        | string  | 返回 Vinyl 对象的格式化说明。由 Node 的 console.log 自动调用。                                                                                                                                                        |

## 路径规范化和连接[​](https://www.gulpjs.com.cn/docs/api/vinyl#%E8%B7%AF%E5%BE%84%E8%A7%84%E8%8C%83%E5%8C%96%E5%92%8C%E8%BF%9E%E6%8E%A5 "Direct link to 路径规范化和连接")

所有路径属性都由它们的 setter 进行规范化。使用 `/` 连接路径，而不是使用 `path.join()`，这样就可以在所有平台上正确地进行规范化。永远不要使用 ` 连接。（ ` 是 POSIX 系统上的一个有效文件名字符。）

```
const file = new File();
file.path = '/' + 'test' + '/' + 'foo.bar';

console.log(file.path);
// posix => /test/foo.bar
// win32 => \test\foo.bar
```

# Vinyl.isVinyl()

检测一个对象（object）是否是一个 Vinyl 实例。不要使用 `instanceof` 方法。

**注意**：此方法使用了 Vinyl 的一个内部属性，而这个属性在老版本的 Vinyl 中是不存在的，如果你使用的恰好时老版本，则会得到一个 fasle 结果。

## 用法[​](https://www.gulpjs.com.cn/docs/api/vinyl-isvinyl#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const Vinyl = require('vinyl');

const file = new Vinyl();
const notAFile = {};

Vinyl.isVinyl(file) === true;
Vinyl.isVinyl(notAFile) === false;
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/vinyl-isvinyl#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
Vinyl.isVinyl(file);
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/vinyl-isvinyl#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数   | 类型     | 注解      |
| ---- | ------ | ------- |
| file | object | 需要检查的对象 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/vinyl-isvinyl#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

如果 `file` 对象是 Vinyl 实例则返回 true。

# Vinyl.isCustomProp()

确定一个属性是否由 Vinyl 在内部进行管理。Vinyl 在构造函数中设置值或在 `clone()` 实例方法中复制属性时使用。

这种方法在扩展 Vinyl 类时很有用。详情参见下文：[扩展 Vinyl](https://www.gulpjs.com.cn/docs/api/vinyl-iscustomprop#extending-vinyl)。

## 用法[​](https://www.gulpjs.com.cn/docs/api/vinyl-iscustomprop#%E7%94%A8%E6%B3%95 "Direct link to 用法")

```
const Vinyl = require('vinyl');

Vinyl.isCustomProp('sourceMap') === true;
Vinyl.isCustomProp('path') === false;
```

## 函数原型[​](https://www.gulpjs.com.cn/docs/api/vinyl-iscustomprop#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B "Direct link to 函数原型")

```
Vinyl.isCustomProp(property)
```

### 参数[​](https://www.gulpjs.com.cn/docs/api/vinyl-iscustomprop#%E5%8F%82%E6%95%B0 "Direct link to 参数")

| 参数       | 类型     | 注解       |
| -------- | ------ | -------- |
| property | string | 要检查的属性名。 |

### 返回值[​](https://www.gulpjs.com.cn/docs/api/vinyl-iscustomprop#%E8%BF%94%E5%9B%9E%E5%80%BC "Direct link to 返回值")

如果属性不是内部管理的，则为 True。

## 扩展 Vinyl[​](https://www.gulpjs.com.cn/docs/api/vinyl-iscustomprop#%E6%89%A9%E5%B1%95-vinyl "Direct link to 扩展 Vinyl")

当在内部管理自定义属性时，必须扩展静态 `isCustomProp` 方法，并在查询其中一个自定义属性时返回 false。

```
const Vinyl = require('vinyl');

const builtInProps = ['foo', '_foo'];

class SuperFile extends Vinyl {
  constructor(options) {
    super(options);
    this._foo = 'example internal read-only value';
  }

  get foo() {
    return this._foo;
  }

  static isCustomProp(name) {
    return super.isCustomProp(name) && builtInProps.indexOf(name) === -1;
  }
}
```

在上面的例子中，`foo` 和 `_foo` 在克隆或将 `options` 传递给 `new SuperFile(options)` 时不会分配给新对象。

如果您的自定义属性或逻辑在克隆期间需要特殊处理，请在扩展 Vinyl 时覆盖 `clone` 方法。

---

---
url: /etc\vitepress\src/mdLang.md
---
# Markdown语法与扩展

## markdown

### 标题

| Markdown语法               | HTML                       | 预览效果                   |
| ------------------------ | -------------------------- | ---------------------- |
| `# Heading level 1`      | `<h1>Heading level 1</h1>` | # Heading level 1      |
| `## Heading level 2`     | `<h2>Heading level 2</h2>` | ## Heading level 2     |
| `### Heading level 3`    | `<h3>Heading level 3</h3>` | ### Heading level 3    |
| `#### Heading level 4`   | `<h4>Heading level 4</h4>` | #### Heading level 4   |
| `##### Heading level 5`  | `<h5>Heading level 5</h5>` | ##### Heading level 5  |
| `###### Heading level 6` | `<h6>Heading level 6</h6>` | ###### Heading level 6 |

### 换行

在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行html br 标签。

### 强调语法

#### 粗体

| Markdown语法                   | HTML                                      | 预览效果                   |
| ---------------------------- | ----------------------------------------- | -------------------------- |
| `I just love **bold text**.` | `I just love <strong>bold text</strong>.` | I just love **bold text**. |
| `I just love __bold text__.` | `I just love <strong>bold text</strong>.` | I just love **bold text**. |
| `Love**is**bold`             | `Love<strong>is</strong>bold`             | Love**is**bold             |

#### 斜体

| Markdown语法                             | HTML                                          | 预览效果                                 |
| -------------------------------------- | --------------------------------------------- | ------------------------------------ |
| `Italicized text is the *cat's meow*.` | `Italicized text is the <em>cat's meow</em>.` | Italicized text is the *cat’s meow*. |
| `Italicized text is the _cat's meow_.` | `Italicized text is the <em>cat's meow</em>.` | Italicized text is the *cat’s meow*. |
| `A*cat*meow`                           | `A<em>cat</em>meow`                           | A*cat*meow                           |

### 引用语法

:::v-pre
\> 这是一段引用
:::

> 这是一段引用

### 列表语法

#### 有序列表

| Markdown语法                                                  | HTML                                                                                           | 预览效果                                                                           |
| ----------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| 1. First item 2. Second item 3. Third item 4. Fourth item |  First item Second item Third item Fourth item  | 1.  First item 2.  Second item 3.  Third item 4.  Fourth item |

#### 无序列表

| Markdown语法                                              | HTML                                                                                           |
| ------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| - First item - Second item - Third item - Fourth item |  First item Second item Third item Fourth item  |

```
First item
Second item
Third item
Fourth item
```

注意 有序无序列表可以相互之间嵌套

### 代码语法

| Markdown语法                                    | HTML                                               | 预览效果                                  |
| --------------------------------------------- | -------------------------------------------------- | ------------------------------------- |
| Use code in your Markdown file. | Use code in your Markdown file. | Use code in your Markdown file. |

### 分隔线

:::v-pre
\--- 或 \*\*\*
:::

***

***

### 链接语法

:::v-pre
[文字](url)
[link](https://www.example.com/my%20great%20page)
:::

### 图片语法

:::v-pre
[![沙漠中的岩石图片](https://www.example.com/assets/img/shiprock.jpg "Shiprock")](https://markdown.com.cn)
:::

### 其他

如 html 标签

## 扩展

### frontmatter语法

任何包含YAMLfront matter 块的文件都将是 由 Jekyll 作为特殊文件处理。前言必须是第一件事 ，并且必须采用在三短划线 线。下面是一个基本示例

```yaml
    --- 
      layout: post 
      title: Blogging Like a Hacker 
    ---
```

可以通过 Vue 表达式中的 `$frontmatter` 全局变量访问 frontmatter 数据：

:::v-pre
{{ $frontmatter.title }}
:::

#### title

类型: `string`

页面的标题。它与config.title 相同，并且覆盖站点级配置。

```yaml
  ---
      title: VitePress
  ---
```

#### titleTemplate

类型：string / boolean
标题的后缀。它与 [config.titleTemplate](https://vitepress.dev/zh/reference/site-config#titletemplate) 相同，它会覆盖站点级别的配置。

```yaml
  ---
      title: VitePress
      titleTemplate: Vite & Vue powered static site generator
  ---
```

#### description[​](https://vitepress.dev/zh/reference/frontmatter-config#description)

类型：`string`

页面的描述。它与 [config.description](https://vitepress.dev/zh/reference/site-config#description) 相同，它会覆盖站点级别的配置。

```yaml
  ---
  description: VitePress
  ---
```

#### head[​](https://vitepress.dev/zh/reference/frontmatter-config#head)

类型：`HeadConfig[]`

指定要为当前页面注入的额外 head 标签。将附加在站点级配置注入的头部标签之后。

```yaml
---
head:
  - - meta
    - name: description
      content: hello
  - - meta
    - name: keywords
      content: super duper SEO
---
```

```ts
type HeadConfig =
  | [string, Record<string, string>]
  | [string, Record<string, string>, string]
```

#### 仅默认主题[​](https://vitepress.dev/zh/reference/frontmatter-config#default-theme-only)

以下 frontmatter 选项仅在使用默认主题时适用。

##### layout[​](https://vitepress.dev/zh/reference/frontmatter-config#layout)

类型：`doc | home | page`
默认值：`doc`

指定页面的布局。

`doc`——它将默认文档样式应用于 markdown 内容。
`home`——“主页”的特殊布局。可以添加额外的选项，例如 `hero` 和 `features`，以快速创建漂亮的落地页。
`page`——表现类似于 `doc`，但它不对内容应用任何样式。当想创建一个完全自定义的页面时很有用。

yaml

```
---
layout: doc
---
```

##### hero home page only[​](https://vitepress.dev/zh/reference/frontmatter-config#hero)

当 `layout` 设置为 `home` 时，定义主页 hero 部分的内容。更多详细信息：[默认主题：主页](https://vitepress.dev/zh/reference/default-theme-home-page)。

##### features home page only[​](https://vitepress.dev/zh/reference/frontmatter-config#features)

定义当`layout` 设置为 `home` 时要在 features 部分中显示的项目。更多详细信息：[默认主题：主页](https://vitepress.dev/zh/reference/default-theme-home-page)。

#### navbar[​](https://vitepress.dev/zh/reference/frontmatter-config#navbar)

类型：`boolean`
默认值：`true`

是否显示[导航栏](https://vitepress.dev/zh/reference/default-theme-nav)。

yaml

```
---
navbar: false
---
```

#### sidebar[​](https://vitepress.dev/zh/reference/frontmatter-config#sidebar)

类型：`boolean`
默认值：`true`

是否显示 [侧边栏](https://vitepress.dev/zh/reference/default-theme-sidebar).

yaml

```
---
sidebar: false
---
```

#### aside[​](https://vitepress.dev/zh/reference/frontmatter-config#aside)

类型：`boolean | 'left'`
默认值：`true`

定义侧边栏组件在 `doc` 布局中的位置。

将此值设置为 `false` 可禁用侧边栏容器。\
将此值设置为 `true` 会将侧边栏渲染到右侧。\
将此值设置为 `left` 会将侧边栏渲染到左侧。

yaml

```
---
aside: false
---
```

#### outline[​](https://vitepress.dev/zh/reference/frontmatter-config#outline)

类型：`number | [number, number] | 'deep' | false`
默认值：`2`

大纲中显示的标题级别。它与 [config.themeConfig.outline.level](https://vitepress.dev/zh/reference/default-theme-config#outline) 相同，它会覆盖站点级的配置。

#### lastUpdated[​](https://vitepress.dev/zh/reference/frontmatter-config#lastupdated)

类型：`boolean | Date`
默认值：`true`

是否在当前页面的页脚中显示[最后更新时间](https://vitepress.dev/zh/reference/default-theme-last-updated)的文本。如果指定了日期时间，则会显示该日期时间而不是上次 git 修改的时间戳。

```yaml
---
lastUpdated: false
---
```

#### editLink[​](https://vitepress.dev/zh/reference/frontmatter-config#editlink)

类型：`boolean`
默认值：`true`

是否在当前页的页脚显示[编辑链接](https://vitepress.dev/zh/reference/default-theme-edit-link)。

```yaml
---
editLink: false
---
```

#### footer[​](https://vitepress.dev/zh/reference/frontmatter-config#footer)

类型：`boolean`
默认值：`true`

是否显示[页脚](https://vitepress.dev/zh/reference/default-theme-footer)。

```yaml
---
footer: false
---
```

#### pageClass[​](https://vitepress.dev/zh/reference/frontmatter-config#pageclass)

类型：`string`

将额外的类名称添加到特定页面。

```yaml
---
pageClass: custom-page-class
---
```

然后可以在 `.vitepress/theme/custom.css` 文件中自定义该特定页面的样式：

```css
.custom-page-class {
  /* 特定页面的样式 */
}
```

VitePress 也支持 JSON 格式的 frontmatter，以花括号开始和结束：

json

```
---
{
  "title": "Blogging Like a Hacker",
  "editLink": true
}
---
```

### GitHub 风格的表格[​](https://vitejs.cn/vitepress/guide/markdown#github-style-tables)

**输入**

```
| Tables        |      Are      |  Cool |
| ------------- | :-----------: | ----: |
| col 3 is      | right-aligned | $1600 |
| col 2 is      |   centered    |   $12 |
| zebra stripes |   are neat    |    $1 |
```

**输出**

| Tables        | Are           | Cool   |
| ------------- | ------------- | ------ |
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      | $12   |
| zebra stripes | are neat      | $1    |

### Emoji

```
:tada: :100:
```

🎉 💯
[emoji列表](https://github.com/markdown-it/markdown-it-emoji/blob/master/lib/data/full.mjs)

### 目录

\[\[toc]]
可以使用 `markdown.toc` 选项配置 TOC 的呈现效果。

### 自定义容器

```md
::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::
```

此外，可以通过在站点配置中添加以下内容来全局设置自定义标题，如果不是用英语书写，这会很有帮助：

```ts
// config.ts
export default defineConfig({
  // ...
  markdown: {
    container: {
      tipLabel: '提示',
      warningLabel: '警告',
      dangerLabel: '危险',
      infoLabel: '信息',
      detailsLabel: '详细信息'
    }
  }
  // ...
})
```

### `raw`[​](https://vitepress.dev/zh/guide/markdown#raw)

这是一个特殊的容器，可以用来防止与 VitePress 的样式和路由冲突。这在记录组件库时特别有用。可能还想查看 [whyframe](https://whyframe.dev/docs/integrations/vitepress) 以获得更好的隔离。

```
::: raw
Wraps in a <div class="vp-raw">
:::
```

### GitHub 风格的警报

```
> [!NOTE]
> 强调用户在快速浏览文档时也不应忽略的重要信息。

> [!TIP]
> 有助于用户更顺利达成目标的建议性信息。

> [!IMPORTANT]
> 对用户达成目标至关重要的信息。

> [!WARNING]
> 因为可能存在风险，所以需要用户立即关注的关键内容。

> [!CAUTION]
> 行为可能带来的负面影响。
```

### 代码高亮

这里可以配置 高亮主题在主题会详细说

//这里第四行会高亮

```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```

除了单行之外，还可以指定多个单行、多行，或两者均指定：

多行：例如 `{5-8}`、`{3-10}`、`{10-17}`
多个单行：例如 `{4,7,9}`
多行与单行：例如 `{4,7-13,16,23-27,40}`

也可以使用 `// [!code highlight]` 注释实现行高亮。

```js
export default {
  data () {
    return {
      msg: 'Highlighted!' // [!code highlight]
    }
  }
}
```

### 代码聚焦

```js
export default {
  data () {
    return {
      msg: 'Focused!' // [!code focus]
    }
  }
}
```

### 代码块颜色差异

在某一行添加 `// [!code --]` 或 `// [!code ++]` 注释将会为该行创建 diff，同时保留代码块的颜色。

```js
export default {
  data () {
    return {
      msg: 'Removed' // [!code --]
      msg: 'Added' // [!code ++]
    }
  }
}
```

### 高亮“错误”和“警告”[​](https://vitepress.dev/zh/guide/markdown#errors-and-warnings-in-code-blocks)

在某一行添加 `// [!code warning]` 或 `// [!code error]` 注释将会为该行相应的着色。

```js
export default {
  data () {
    return {
      msg: 'Error', // [!code error]
      msg: 'Warning' // [!code warning]
    }
  }
}
```

### 行号

这里可以全局配置

```ts:line-numbers {1}
// 启用行号
const line2 = 'This is line 2'
const line3 = 'This is line 3'
```

### 导入代码片段[​](https://vitepress.dev/zh/guide/markdown#import-code-snippets)

可以通过下面的语法来从现有文件中导入代码片段：

```
<<< @/filepath
```

此语法同时支持[行高亮](https://vitepress.dev/zh/guide/markdown#line-highlighting-in-code-blocks)：
可以像这样在大括号内(`{}`)指定语言：
md

```
<<< @/filepath{highlightLines}
<<< @/snippets/snippet.cs{c#}
```

### 代码组

````md
::: code-group

```js [config.js]
/**
 * @type {import('vitepress').UserConfig}
 */
const config = {
  // ...
}

export default config
````

```ts [config.ts]
import type { UserConfig } from 'vitepress'

const config: UserConfig = {
  // ...
}

export default config
```

:::

````

### 嵌套md
```md
# Docs

## Basics

<!--@include: ./parts/basics.md{3,}-->
````

### 数学公式

现在这是可选的。要启用它，需要安装 `markdown-it-mathjax3`，在配置文件中设置`markdown.math` 为 `true`：

sh

```
npm add -D markdown-it-mathjax3
```

```.vitepress/config.ts ts
export default {
  markdown: {
    math: true
  }
}
```

### 高级配置[​](https://vitepress.dev/zh/guide/markdown#advanced-configuration)

VitePress 使用 [markdown-it](https://github.com/markdown-it/markdown-it) 作为 Markdown 渲染器。上面提到的很多扩展功能都是通过自定义插件实现的。可以使用 `.vitepress/config.js` 中的 `markdown` 选项来进一步自定义 `markdown-it` 实例。

```js
import { defineConfig } from 'vitepress'
import markdownItAnchor from 'markdown-it-anchor'
import markdownItFoo from 'markdown-it-foo'

export default defineConfig({
  markdown: {
    // markdown-it-anchor 的选项
    // https://github.com/valeriangalliat/markdown-it-anchor#usage
    anchor: {
      permalink: markdownItAnchor.permalink.headerLink()
    },
    // @mdit-vue/plugin-toc 的选项
    // https://github.com/mdit-vue/mdit-vue/tree/main/packages/plugin-toc#options
    toc: { level: [1, 2] },
    config: (md) => {
      // 使用更多的 Markdown-it 插件！
      md.use(markdownItFoo)
    }
  }
})
```

# 在md使用vue

## 模板语法

```
{{ 1 + 1 }}
```

## `<script>` 和 `<style>`[​](https://vitepress.dev/zh/guide/using-vue#script-and-style)

Markdown 文件中的根级 `<script>` 和 `<style>` 标签与 Vue SFC 中的一样，包括 `<script setup>`、`<style module>` 等。这里的主要区别是没有 `<template>` 标签：所有其他根级内容都是 Markdown。另请注意，所有标签都应放在 frontmatter **之后**：

```vue

---
hello: world
---

<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>

## Markdown Content

The count is: {{ count }}

<button :class="$style.button" @click="count++">Increment</button>

<style module>
.button {
  color: red;
  font-weight: bold;
}
</style>

```

可以通过使用 `v-pre` 指令将它们包裹在 `<span>` 或其他元素中来转义 Vue 插值

This {{ will be displayed as-is }}

也可以将整个段落包装在 `v-pre` 自定义容器中：

::: v-pre
{{ This will be displayed as-is }}
:::

## 使用 CSS 预处理器

VitePress 内部支持 CSS 预处理器：`.scss`、`.sass`、.`less`、`.styl` 和 `.stylus` 文件。无需为它们安装 Vite 专用插件，但必须安装相应的预处理器

```sh
    npm install -D sass
    npm install -D less
    npm install -D stylus
```

然后可以在 Markdown 和主题组件中使用以下内容：

```vue
    <style lang="sass">
    .title{
      font-size: 20px
    }
    </style>
```

---

---
url: /etc\rollup\src/howWork.md
---
# rollup 插件是怎样工作的

Rollup 的插件机制通过钩子函数（Hooks）实现，插件可以在 Rollup 构建过程的不同阶段注入自定义逻辑。Rollup 提供了丰富的生命周期钩子，插件可以通过实现这些钩子来扩展 Rollup 的功能。

注意

* 如果你需要在 SCSS 文件中使用 `@import` 导入其他 SCSS 文件，确保路径正确。
* 如果你需要处理 CSS 中的图片或字体等资源，可以结合 `rollup-plugin-url` 或 `rollup-plugin-copy` 插件使用。

## 插件的基本结构

一个 Rollup 插件通常是一个 JavaScript 对象，包含一个 `name` 属性和多个钩子函数。例如：

```javascript
  export default function myPlugin() {
    return {
      name: 'my-plugin',
      transform(code, id) {
        // 自定义转换逻辑
        return code.replace(/foo/g, 'bar');
      }
    };
  }
```

## 钩子函数

## 构建阶段钩子 (Build Hooks)

* **`options`**: 这个钩子允许插件在 Rollup 初始化配置时修改或扩展配置选项。例如，可以在这里添加自定义的输入选项或输出选项。
* **`buildStart`**: 当 Rollup 开始构建时，这个钩子会被触发。通常用于初始化一些资源或状态。
* **`resolveId`**: 这个钩子用于解析模块的 ID。插件可以在这里自定义模块的解析逻辑，例如将某些模块重定向到其他路径。
* **`load`**: 这个钩子用于加载模块的内容。插件可以在这里返回模块的源代码，或者从其他地方加载模块内容。
* **`transform`**: 这个钩子用于转换模块的内容。插件可以在这里对模块的源代码进行转换，例如将 TypeScript 转换为 JavaScript。
* **`moduleParsed`**: 当模块解析完成后，这个钩子会被触发。插件可以在这里获取模块的解析结果，并进行进一步处理。
* **`buildEnd`**: 当 Rollup 构建结束时，这个钩子会被触发。通常用于清理资源或生成构建报告。

## 输出生成阶段钩子 (Output Generation Hooks)

* **`outputOptions`**: 这个钩子允许插件在生成输出之前修改或扩展输出配置选项。例如，可以在这里添加自定义的输出格式或文件名。
* **`renderStart`**: 当 Rollup 开始生成输出时，这个钩子会被触发。通常用于初始化一些输出相关的资源。
* **`banner` / `footer`**: 这些钩子允许插件在生成的 bundle 的顶部或底部添加内容。例如，可以在这里添加版权声明或版本信息。
* **`intro` / `outro`**: 这些钩子允许插件在生成的 bundle 的内部添加内容。例如，可以在这里添加一些全局变量或初始化代码。
* **`renderChunk`**: 这个钩子允许插件修改生成的 chunk 内容。例如，可以在这里对 chunk 进行压缩或添加额外的代码。
* **`generateBundle`**: 当 Rollup 生成 bundle 时，这个钩子会被触发。插件可以在这里修改或添加文件到最终的输出中。
* **`writeBundle`**: 当 bundle 写入磁盘之前，这个钩子会被触发。通常用于在文件写入之前进行最后的修改或验证。

## 其他钩子 (Miscellaneous Hooks)

* **`watchChange`**: 在监视模式下，当文件发生变化时，这个钩子会被触发。插件可以在这里响应文件变化，例如重新加载模块。
* **`closeWatcher`**: 当监视模式关闭时，这个钩子会被触发。通常用于清理与监视模式相关的资源。

## 插件间的交互

插件之间可以通过共享上下文（如 `this`）或修改 Rollup 的配置选项进行交互。例如，一个插件可以在 `options` 钩子中修改配置，另一个插件可以在 `buildStart` 钩子中读取这些配置。

---

---
url: /etc\rollup\src/withVue.md
---
# rollup 集成vue

一般没有这么干的

```
npm install rollup rollup-plugin-vue vue-template-compiler -D
```

```vue
<template>
  <div>
    <h1>{{ message }}</h1>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue with Rollup!'
    };
  }
};
</script>
```

---

---
url: /etc\rollup\src/more.md
---
# rollup 优化

### 1. Tree Shaking

Tree Shaking 是 Rollup 的核心特性之一，它通过静态分析代码，移除未使用的模块和代码片段。确保在项目中启用 Tree Shaking，可以有效减少最终打包文件的体积。

### 2. 代码分割

代码分割可以通过两种方式实现：

* **手动分割**：使用 `output.manualChunks` 配置，将特定模块打包到单独的 chunk 中。
* **动态导入**：使用 `import()` 语法，按需加载模块，减少初始加载时间。

### 3. 使用缓存

`rollup-plugin-cache` 插件可以将构建结果缓存到磁盘，避免在每次构建时重新处理未更改的模块，从而提升构建速度。

### 4. 并行构建

`rollup-plugin-parallel` 插件可以将构建任务分配到多个 CPU 核心上并行执行，显著提升构建速度，尤其是在处理大型项目时。

### 5. 减少插件使用

每个插件都会增加构建过程的复杂度，尤其是那些对构建性能影响较大的插件（如 Babel）。尽量减少插件的使用，或者选择性能更优的替代品。

### 6. 优化 Rollup 配置

通过合理配置 Rollup 的输出选项，可以减少不必要的输出和调试信息。例如，关闭 `sourcemap` 或选择合适的 `output.format`，可以提升构建性能。

### 7. 使用更快的插件替代品

`esbuild` 是一个极快的 JavaScript 打包工具，可以用它替代 Babel 进行代码转换，显著提升构建速度。

### 8. 减少模块解析时间

通过 `external` 选项将第三方库标记为外部依赖，避免 Rollup 解析这些模块，从而减少构建时间。

### 9. 使用增量构建

在开发环境中，结合 `rollup-plugin-livereload` 或 `rollup-plugin-serve` 实现增量构建，只重新构建更改的部分，减少每次构建的时间。

### 10. 优化依赖管理

使用 `pnpm` 或 `yarn` 的 PnP 模式，可以减少依赖安装和解析时间，从而提升整体构建性能。

---

---
url: /etc\rollup\src/treeshaking.md
---
# treeshaking

* **动态导入**：Rollup 的 Tree Shaking 主要针对静态导入和导出。对于动态导入（如 `import()`），Rollup 无法在打包时确定哪些代码会被使用，因此 Tree Shaking 的效果可能会受到影响。
* **副作用代码**：如果代码中包含副作用（如修改全局变量、执行某些操作等），Rollup 可能会保留这些代码，即使它们看起来没有被使用。开发者可以通过 `/*#__PURE__*/` 注释来标记没有副作用的代码，帮助 Rollup 更好地进行 Tree Shaking。
  Rollup 的 Tree Shaking 依赖于 ES6 模块的静态结构。ES6 模块的导入和导出语句是静态的，这意味着它们在代码执行之前就已经确定了。Rollup 利用这一点，通过解析这些静态语句来构建模块之间的依赖关系图去清除未使用过的代码。

---

---
url: /etc\apiExtractor\src/config.md
---
## 安装[​](https://vitepress.dev/zh/guide/getting-started#installation)

### 前置准备[​](https://vitepress.dev/zh/guide/getting-started#prerequisites)

* [Node.js](https://nodejs.org/) 18 及以上版本。

* 通过命令行界面 (CLI) 访问 VitePress 的终端。

* 支持 [Markdown](https://en.wikipedia.org/wiki/Markdown) 语法的编辑器。

* 推荐 [VSCode](https://code.visualstudio.com/) 及其[官方 Vue 扩展](https://marketplace.visualstudio.com/items?itemName=Vue.volar)。

### 安装并初始化

```
  npm i vitepress
  
  $ npx vitepress init
  将需要回答几个简单的问题：
  
  ┌  Welcome to VitePress!
 │
 ◇  Where should VitePress initialize the config? //VitePress 应该在哪里初始化配置
 │  ./docs
 │
 ◇  Site title: //标题
 │  My Awesome Project
 │
 ◇  Site description: //描述
 │  A VitePress Site
 │
 ◆  Theme: //主题
 │  ● Default Theme (Out of the box, good-looking docs)
 │  ○ Default Theme + Customization
 │  ○ Custom Theme
 └
```

### 文档结构

```tree
├─ docs  
│  ├─ .vitepress  
│  │  └─ config.js  
│  ├─ api-examples.md  
│  ├─ markdown-examples.md  
│  └─ index.md  
└─ package.json

```

---

---
url: /etc\doc/robinson.addclass.md
---
[Home](./index.md) > [robinson](./robinson.md) > [addClass](./robinson.addclass.md)

## addClass() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数将一个类添加到 DOM 元素。

**Signature:**

```typescript
declare function addClass(dom: Element, classNm: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  dom | Element | dom 参数的类型为 Element，表示要添加该类的 DOM 元素。 |
|  classNm | string | classNm 参数是一个字符串，表示要添加到 dom 元素的类的名称。 |

**Returns:**

void

## Example

```JavaScript
   let div= document.createElement('div')
   addClass(div,'aa')
   div.className => "aa"
```

---

---
url: /etc/changelog.md
---
## 1.0.16

## 1.0.15

## 1.0.14

## 1.0.13

## 1.0.12

## 1.0.11

## 1.0.10

## 1.0.9

## 1.0.8

## 1.0.7

## 1.0.6

## 1.0.4

## 1.0.0

---

---
url: /etc\doc/robinson.addnode.md
---
[Home](./index.md) > [robinson](./robinson.md) > [addNode](./robinson.addnode.md)

## addNode() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“addNode”将 DOM 元素或字符串插入到父 DOM 元素的指定位置。

**Signature:**

```typescript
declare function addNode(parentDom: Element, dom: Element | String, position?: position): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  parentDom | Element | parentDom 参数是将新节点插入的 DOM 元素。 |
|  dom | Element | String | “dom”参数可以是“Element”或“String”。它表示需要添加到“parentDom”的元素或 HTML 字符串。 |
|  position | position | *(Optional)* “position”参数是可选的，默认值为“afterbegin”。它指定新节点相对于父节点应插入的位置。 “position。它可以具有以下值之一： beforebegin parentDom元素的前面 afterbegin parentDom元素内部的第一个子节点之前 beforeend parentDom元素内部的最后一个子节点之后 afterend parentDom元素的后面 |

**Returns:**

void

## Example

```JavaScript
 let parent =document.querySelect('#box');
 let newDom =document.createElement('div')
 addNode(parent,newDom,'beforeBegin')
---
  let parent =document.querySelect('#box');
  let str = `<div>123 </div>`
  addNode(parent,str,'beforeBegin')
```

---

---
url: /etc/doc.md
---
[Home](./index.md)

## API Reference

## Packages

|  Package | Description |
|  --- | --- |
|  [robinson](./robinson.md) |  |

---

---
url: /etc\doc/robinson.asigndata.md
---
[Home](./index.md) > [robinson](./robinson.md) > [asignData](./robinson.asigndata.md)

## asignData() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“asignData”将属性从“obj2”复制到“obj1”，并可选择执行附加函数。

**Signature:**

```typescript
declare function asignData(obj1: DAMNU_ENABLE, obj2: DAMNU_ENABLE): DAMNU_ENABLE;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  obj1 | DAMNU\_ENABLE | obj1 是第一个将被分配数据的对象。 |
|  obj2 | DAMNU\_ENABLE | obj2 是一个对象，其中包含将根据匹配键分配给 obj1 的数据。 |

**Returns:**

DAMNU\_ENABLE

{DAMNU\_ENABLE} - 合并后的对象。

## Example

```JavaScript
let o = {
  a: 123,
};
let b = {
  a: 456,
  b: 111,
};
let result = asignData(o, b);
// result: { a: 456 }
```

---

---
url: /etc\doc/robinson.base64toblob.md
---
[Home](./index.md) > [robinson](./robinson.md) > [base64ToBlob](./robinson.base64toblob.md)

## base64ToBlob() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将Base64编码的字符串转换为Blob对象

**Signature:**

```typescript
declare function base64ToBlob(base64: string): Blob;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  base64 | string | Base64编码的字符串 |

**Returns:**

Blob

Blob对象

## Example

const blob = base64ToBlob('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');

---

---
url: /etc\doc/robinson.bind.md
---
[Home](./index.md) > [robinson](./robinson.md) > [bind](./robinson.bind.md)

## bind() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数将事件侦听器绑定到 TypeScript 中的 DOM 元素。

**Signature:**

```typescript
declare function bind(dom: Node, eventType: string, callBack: EventListenerOrEventListenerObject, isCatch?: boolean): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  dom | Node | dom 参数是将事件监听器附加到的 DOM 元素。它可以是任何有效的 DOM 元素 |
|  eventType | string | eventType 参数是一个字符串，指定要侦听的事件类型。事件类型的示例包括“单击”、“按下键”、“鼠标悬停”等。 |
|  callBack | EventListenerOrEventListenerObject | callBack 参数是当 DOM 元素上发生指定事件时将执行的函数。它可以是实现EventListener 或 EventListenerObject 接口的函数或对象。 |
|  isCatch | boolean | *(Optional)* isCatch 参数是一个布尔值，用于确定事件监听器在处理事件时是否应使用捕获阶段（true）或冒泡阶段（false）。默认情况下，它设置为“false”，这意味着事件侦听器将使用冒泡阶段。 |

**Returns:**

void

## Example

```JavaScript
   let btn =document.querySelect('button');
   bind(btn,'clic',()=>{
     console.log('123')
   })
```

---

---
url: /etc\doc/robinson.blobtobase64.md
---
[Home](./index.md) > [robinson](./robinson.md) > [blobToBase64](./robinson.blobtobase64.md)

## blobToBase64() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将Blob对象转换为Base64编码的字符串

**Signature:**

```typescript
declare function blobToBase64(blob: BlobPart, suffix?: string): Promise<unknown>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  blob | BlobPart | Blob对象 |
|  suffix | string | *(Optional)* 文件后缀，默认为'png' |

**Returns:**

Promise\<unknown>

Promise对象，解析为Base64编码的字符串

## Example

blobToBase64(new Blob(\['Hello, world!'], { type: 'text/plain' })) .then(base64 => console.log(base64));

---

---
url: /etc\doc/robinson.calc.md
---
[Home](./index.md) > [robinson](./robinson.md) > [calc](./robinson.calc.md)

## calc() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

数值计算

**Signature:**

```typescript
declare function calc(number1: BigSource, number2: BigSource, operate?: TOperate): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  number1 | BigSource | 第一个数字。 |
|  number2 | BigSource | 第二个数字。 |
|  operate | TOperate | *(Optional)* 操作符，默认为 '+'。 |

**Returns:**

string

{number} - 计算结果。

## Example

```javascript
calc(0.1, 0.2);// 返回 0.3
calc(0.1, 0.2, '-');// 返回 -0.1
calc(0.1, 0.2, '*');// 返回 0.02
calc(0.1, 0.2, '/');// 返回 0.5
```

---

---
url: /etc\doc/robinson.compose.md
---
[Home](./index.md) > [robinson](./robinson.md) > [compose](./robinson.compose.md)

## compose() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

组合函数，将多个函数从右到左依次调用。

**Signature:**

```typescript
declare function compose(...fns: Array<Function>): Function;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fns | Array\<Function> | 要组合的函数。 |

**Returns:**

Function

{Function} - 返回一个组合后的函数。

## Example

```JavaScript
const addOne = x => x + 1;
const double = x => x * 2;
const composed = compose(double, addOne);
composed(2);// 返回 6
```

---

---
url: /etc\doc/robinson.createcache.md
---
[Home](./index.md) > [robinson](./robinson.md) > [createCache](./robinson.createcache.md)

## createCache() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

createCache 函数创建一个缓存对象，该对象可以使用指定的存储机制和编码/解码函数来存储和检索数据。

**Signature:**

```typescript
createCache: (storage: any, parmas?: ParamsInter) => {
    "__#9309@#storage": any;
    "__#9309@#encode": Function;
    "__#9309@#decode": Function;
    setCache(key: string, value: any, expire: number): void;
    getCache(encodeKey: string): any;
    removeCache(key: string): void;
    has(key: string): boolean;
    length(): any;
    clear(): void;
}
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  storage | any | storage 参数是一个可选参数，它指定用于缓存的存储机制。它可以是实现与 localStorage 对象相同接口的任何对象，例如 sessionStorage 或自定义存储实现。如果没有提供存储对象，则localStorage |
|  parmas | ParamsInter | *(Optional)* “parmas”参数是一个包含两个属性的对象：“encode”和“decode”。这些属性是用于在将值存储到缓存之前对值进行编码和解码的函数。 这些函数的默认值是恒等函数，这意味着它们不执行任何编码或解码。 |

**Returns:**

{ "\_\_#9309@#storage": any; "\_\_#9309@#encode": Function; "\_\_#9309@#decode": Function; setCache(key: string, value: any, expire: number): void; getCache(encodeKey: string): any; removeCache(key: string): void; has(key: string): boolean; length(): any; clear(): void; }

函数“createCache”返回“Cache”类的实例。 setCache(key:String,value:Any,expire:超时时间) 设置单个缓存 return undefined getCache(key:String) 根据传入key获取单个缓存 return undefined removeCache(key:String)根据传入KEY删除单个缓存 return undefined has(key:String) 根据传入key 判断是否已经有这个数据了 return Boolean length(), return 缓存总条数 clear() 清空缓存

---

---
url: /etc\doc/robinson.currying.md
---
[Home](./index.md) > [robinson](./robinson.md) > [currying](./robinson.currying.md)

## currying() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

柯里化函数接受一个函数作为输入并返回一个新函数，该函数可以使用多个参数或以柯里化方式调用。

**Signature:**

```typescript
declare function currying(fn: Function): Function;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fn | Function | 参数“fn”是我们要应用柯里化的函数。 |

**Returns:**

Function

{Function} - 正在返回柯里化函数。

## Example

```JavaScript
const add = (a, b) => a + b;
const curriedAdd = currying(add);
curriedAdd(2)(3);// 返回 5
```

---

---
url: /etc\doc/robinson.copytoclipboard.md
---
[Home](./index.md) > [robinson](./robinson.md) > [copyToClipboard](./robinson.copytoclipboard.md)

## copyToClipboard() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将文本复制到剪贴板。

**Signature:**

```typescript
declare function copyToClipboard(text: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  text | string | 要复制到剪贴板的文本内容。 |

**Returns:**

void

---

---
url: /etc\doc/robinson.debounce.md
---
[Home](./index.md) > [robinson](./robinson.md) > [debounce](./robinson.debounce.md)

## debounce() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

防抖函数，限制函数调用的频率。

**Signature:**

```typescript
declare function debounce(fn: Function, delay: number, isLimmediate?: boolean): Function;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fn | Function | “fn”参数是您想要限制的函数。 |
|  delay | number | “delay”参数是函数调用之间的最小时间间隔（以毫秒为单位）。 |
|  isLimmediate | boolean | *(Optional)* “isLimmediate”参数决定该函数是在调用时立即执行还是等待指定的“delay”时间过去后才第一次执行该函数。 |

**Returns:**

Function

{Function} - 返回一个防抖函数。

## Example

```JavaScript
const log = () => console.log('Logged');
const debouncedLog = debounce(log, 1000, true);
debouncedLog(); // 立即执行
debouncedLog(); // 1秒内再次调用不会执行
debouncedLog.cancel(); // 取消执行
```

---

---
url: /etc\doc/robinson.deepclone.md
---
[Home](./index.md) > [robinson](./robinson.md) > [deepClone](./robinson.deepclone.md)

## deepClone() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

“deepClone”函数用于创建对象或数组的深层副本，包括处理复杂类型，例如集合、映射和符号。

**Signature:**

```typescript
declare function deepClone(originalValue: any): any;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  originalValue | any | OriginalValue 参数是您要深度克隆的值。它可以是任何数据类型，包括对象、数组、集合、映射、函数以及字符串或数字等简单值。 |

**Returns:**

any

{any} - 函数“deepClone”返回“originalValue”参数的深度克隆。

## Example

```JavaScript
   let data = {
     a: [1, 2]
   };
   let cloneData = deepClone(data);
```

---

---
url: /etc\doc/robinson.downloadbybase64.md
---
[Home](./index.md) > [robinson](./robinson.md) > [downloadByBase64](./robinson.downloadbybase64.md)

## downloadByBase64() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

通过Base64编码的字符串下载文件

**Signature:**

```typescript
declare function downloadByBase64(buf: string, fileNm: string, suffix: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  buf | string | Base64编码的字符串 |
|  fileNm | string | 下载后的文件名 |
|  suffix | string | 下载后的文件后缀 |

**Returns:**

void

## Example

downloadByBase64('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...', 'example.png', 'png');

---

---
url: /etc\doc/robinson.eventbus._constructor_.md
---
[Home](./index.md) > [robinson](./robinson.md) > [EventBus](./robinson.eventbus.md) > [(constructor)](./robinson.eventbus._constructor_.md)

## EventBus.(constructor)

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

Constructs a new instance of the `EventBus` class

**Signature:**

```typescript
constructor();
```

---

---
url: /etc\doc/robinson.downloadbyurl.md
---
[Home](./index.md) > [robinson](./robinson.md) > [downloadByUrl](./robinson.downloadbyurl.md)

## downloadByUrl() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

通过URL下载图片到本地

**Signature:**

```typescript
declare function downloadByUrl(url: string, filename?: string, type?: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  url | string | 图片路径 |
|  filename | string | *(Optional)* 下载后的文件名 |
|  type | string | *(Optional)* 下载后的文件类型 |

**Returns:**

void

## Example

downloadByUrl('https://example.com/image.png', 'example.png');

---

---
url: /etc\doc/robinson.downloadbyblob.md
---
[Home](./index.md) > [robinson](./robinson.md) > [downloadByBlob](./robinson.downloadbyblob.md)

## downloadByBlob() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

通过Blob对象下载文件

**Signature:**

```typescript
declare function downloadByBlob(blob: BlobPart, fileNm: string, suffix?: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  blob | BlobPart | Blob文件流 |
|  fileNm | string | 下载后的文件名 |
|  suffix | string | *(Optional)* 下载后的文件类型，默认为'txt' |

**Returns:**

void

## Example

downloadByBlob(new Blob(\['Hello, world!'], { type: 'text/plain' }), 'example.txt');

---

---
url: /etc\doc/robinson.eventbus.clear.md
---
[Home](./index.md) > [robinson](./robinson.md) > [EventBus](./robinson.eventbus.md) > [clear](./robinson.eventbus.clear.md)

## EventBus.clear() method

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

clear 函数从 eventObj 对象中删除事件。

**Signature:**

```typescript
clear(eventName: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  eventName | string | eventName 参数是一个字符串，表示要清除的事件的名称。 |

**Returns:**

void

---

---
url: /etc\doc/robinson.eventbus.emit.md
---
[Home](./index.md) > [robinson](./robinson.md) > [EventBus](./robinson.eventbus.md) > [emit](./robinson.eventbus.emit.md)

## EventBus.emit() method

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

“emit”函数触发与特定事件名称关联的所有事件处理程序，并将任何参数传递给它们。

**Signature:**

```typescript
emit(eventName: string, ...Args: any): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  eventName | string | 表示要发出的事件名称的字符串。 |
|  Args | any | Args 是一个剩余参数，允许将无限数量的参数传递给 emit 函数。这些参数可以是任何类型。 |

**Returns:**

void

---

---
url: /etc\doc/robinson.eventbus.md
---
[Home](./index.md) > [robinson](./robinson.md) > [EventBus](./robinson.eventbus.md)

## EventBus class

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“on”将事件侦听器添加到事件对象，将事件函数存储在指定的事件名称下。

**Signature:**

```typescript
declare class EventBus 
```

## Example

const eventBus = new EventBus(); eventBus.on('myEvent', () => { console.log('myEvent triggered'); });

## Constructors

|  Constructor | Modifiers | Description |
|  --- | --- | --- |
|  [(constructor)()](./robinson.eventbus._constructor_.md) |  | ***(BETA)*** Constructs a new instance of the EventBus class |

## Methods

|  Method | Modifiers | Description |
|  --- | --- | --- |
|  [clear(eventName)](./robinson.eventbus.clear.md) |  | ***(BETA)*** clear 函数从 eventObj 对象中删除事件。 |
|  [emit(eventName, Args)](./robinson.eventbus.emit.md) |  | ***(BETA)*** “emit”函数触发与特定事件名称关联的所有事件处理程序，并将任何参数传递给它们。 |
|  [off(eventName, fn)](./robinson.eventbus.off.md) |  | ***(BETA)*** |
|  [on(eventName, eventFn)](./robinson.eventbus.on.md) |  | ***(BETA)*** 函数“on”将事件侦听器添加到事件对象，将事件函数存储在指定的事件名称下。 |

---

---
url: /etc\doc/robinson.eventbus.off.md
---
[Home](./index.md) > [robinson](./robinson.md) > [EventBus](./robinson.eventbus.md) > [off](./robinson.eventbus.off.md)

## EventBus.off() method

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

**Signature:**

```typescript
off(eventName: string, fn: Function): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  eventName | string |  |
|  fn | Function |  |

**Returns:**

void

---

---
url: /etc\doc/robinson.eventbus.on.md
---
[Home](./index.md) > [robinson](./robinson.md) > [EventBus](./robinson.eventbus.md) > [on](./robinson.eventbus.on.md)

## EventBus.on() method

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“on”将事件侦听器添加到事件对象，将事件函数存储在指定的事件名称下。

**Signature:**

```typescript
on(eventName: string, eventFn: Function): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  eventName | string | eventName 是一个字符串参数，表示事件的名称。它用于标识eventObj对象中的事件。 |
|  eventFn | Function | eventFn 参数是当指定事件发生时将执行的函数。 |

**Returns:**

void

---

---
url: /etc\doc/robinson.formatdate.md
---
[Home](./index.md) > [robinson](./robinson.md) > [formatDate](./robinson.formatdate.md)

## formatDate() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

格式化时间。

**Signature:**

```typescript
declare function formatDate(date: Tday, pattern?: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  date | Tday | 输入的日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  pattern | string | *(Optional)* 格式化模式，默认为 'YYYY-MM-DD'。 |

**Returns:**

string

{string} - 返回格式化后的时间字符串。

## Example

```javascript
formatDate(dayjs('2024-03-01 08:00:00'), 'YYYY年MM月DD日') // '2024年03月01日'
```

---

---
url: /etc\doc/robinson.getafterdate.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getAfterDate](./robinson.getafterdate.md)

## getAfterDate() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

计算给定日期之后的日期，并返回格式化后的结果。

**Signature:**

```typescript
declare function getAfterDate(date: Tday, option: IOptions): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  date | Tday | 起始日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  option | IOptions | 操作选项。 |

**Returns:**

string

{string} - 返回格式化后的日期字符串。

## Example

```javascript
getAfterDate(dayjs('2024-03-02 08:00:00'), { pattern: 'YYYY年MM月DD日' }) // '2024年03月03日'
getAfterDate(dayjs('2024-03-02 08:00:00'),
{ unitType: 'M', pattern: 'YYYY年MM月DD日' }) // '2024年04月02日'
```

---

---
url: /etc\doc/robinson.getbeforedate.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getBeforeDate](./robinson.getbeforedate.md)

## getBeforeDate() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

计算给定日期之前的日期，并返回格式化后的结果。

**Signature:**

```typescript
declare function getBeforeDate(date: Tday, option: IOptions): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  date | Tday | 起始日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  option | IOptions | 操作选项。 |

**Returns:**

string

{string} - 返回格式化后的日期字符串。

## Example

```javascript
getBeforeDate(dayjs('2024-03-02 08:00:00'), { pattern: 'YYYY年MM月DD日' }) // '2024年03月01日'
getBeforeDate(dayjs('2024-03-02 08:00:00'),
{ unitType: 'M', pattern: 'YYYY年MM月DD日' }) // '2024年02月02日'
```

---

---
url: /etc\doc/robinson.getchunkarray.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getChunkArray](./robinson.getchunkarray.md)

## getChunkArray() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

`chunkArray` 函数接受一个数组和一个大小参数，并返回一个新数组，其中原始数组被分割成指定大小的较小数组。

**Signature:**

```typescript
declare function getChunkArray(array: Array<any>, size?: number): Array<Array<any>>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  array | Array\<any> |  |
|  size | number | *(Optional)* “size”参数指定数组每个块中应包含的元素数量。默认情况下，它设置为 1，这意味着每个元素将位于其自己的单独块中。 |

**Returns:**

Array\<Array\<any>>

{\[Array]} 数组的数组。每个内部数组都包含原始数组中的一块元素。每个块的大小由“size”参数确定。

## Example

```JavaScript
let a=[1,2,3,4,5,6]
 getChunkArray(a,2) // [[1,2],[3,4],[5,6]]
let a=[1,2,3,4,5,6]
 getChunkArray(a,3) // [[1,2,3],[4,5,6]]
let a={}
 getChunkArray(a,3) // params is not a array
```

---

---
url: /etc\doc/robinson.getdiff.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getDiff](./robinson.getdiff.md)

## getDiff() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

计算两个日期之间的差值。

**Signature:**

```typescript
declare function getDiff(start: Tday, end: Tday, unitType: dayjs.OpUnitType, float?: boolean): number;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  start | Tday | 开始日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  end | Tday | 结束日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  unitType | dayjs.OpUnitType | 时间单位类型。 |
|  float | boolean | *(Optional)* 是否返回浮点数，默认为 false。 |

**Returns:**

number

{number} - 返回两个日期之间的差值。

## Example

```javascript
getDiff(dayjs('2024-03-02 08:00:00'), dayjs('2024-03-03 08:00:00'), 'd') // 1
getDiff(dayjs('2024-03-02 08:00:00'), dayjs('2024-04-03 08:00:00'), 'd') // 32
```

---

---
url: /etc\doc/robinson.getetc.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getEtc](./robinson.getetc.md)

## getEtc() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“getEtc”接受一个字符串值并返回指定长度的子字符串，并在末尾附加一个可选的“etcStr”。

**Signature:**

```typescript
declare function getEtc(value: string, len: number, etcStr?: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | string | value 参数是一个字符串，表示需要截断的输入值。 |
|  len | number | “len”参数是要从“value”参数中提取的字符串的长度。 |
|  etcStr | string | *(Optional)* etcStr 参数是一个字符串，表示如果长度超过指定的 len 参数，则要在切片字符串末尾附加的字符。默认情况下，它设置为“...”。 |

**Returns:**

string

{string} - 一个字符串。

## Example

```JavaScript
 let str = '123456'; getEtc(str, 3) // '123...'
 let str = '123456'; getEtc(str, 3, 'etc') // '123etc'
```

---

---
url: /etc\doc/robinson.getfilechunk.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getFileChunk](./robinson.getfilechunk.md)

## getFileChunk() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

生成文件切片数组

**Signature:**

```typescript
declare function getFileChunk(file: File, chunkSize?: number): Array<{
    index: number;
    file: Blob;
}>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  file | File | 文件对象 |
|  chunkSize | number | *(Optional)* 每个切片的大小（字节），默认为1MB |

**Returns:**

Array<{ index: number; file: Blob; }>

切片数组，每个元素包含索引和Blob对象

## Example

getFileChunk(fileInput.files\[0], 1024 \* 1024).forEach(chunk => console.log(chunk));

---

---
url: /etc\doc/robinson.getfilesize.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getFileSize](./robinson.getfilesize.md)

## getFileSize() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

获取文件大小

**Signature:**

```typescript
declare function getFileSize(file: File, unit?: string): number;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  file | File | 源文件 |
|  unit | string | *(Optional)* 单位（'b', 'kb', 'm', 'g'），默认为'b' |

**Returns:**

number

文件大小（指定单位）

## Example

getFileSize(fileInput.files\[0], 'kb'); // 返回文件大小（KB）

---

---
url: /etc\doc/robinson.getfiletype.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getFileType](./robinson.getfiletype.md)

## getFileType() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

获取文件后缀名

**Signature:**

```typescript
declare function getFileType(file: File): string | undefined;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  file | File | 源文件 |

**Returns:**

string | undefined

文件后缀名

## Example

getFileType(fileInput.files\[0]); // 返回文件后缀名（如 'jpg'）

---

---
url: /etc\doc/robinson.getmimetype.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getMimeType](./robinson.getmimetype.md)

## getMimeType() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

获取文件的MIME类型

**Signature:**

```typescript
declare function getMimeType(suffix: String): "" | "audio/aac" | "application/x-abiword" | "image/apng" | "application/x-freearc" | "image/avif" | "video/x-msvideo" | "application/vnd.amazon.ebook" | "application/octet-stream" | "image/bmp" | "application/x-bzip" | "application/x-bzip2" | "application/x-cdf" | "application/x-csh" | "text/css" | "text/csv" | "application/msword" | "application/vnd.openxmlformats-officedocument.wordprocessingml.document" | "application/vnd.ms-fontobject" | "application/epub+zip" | "application/gzip" | "image/gif" | "text/html" | "image/x-icon" | "text/calendar" | "application/java-archive" | "image/jpeg" | "text/javascript" | "application/json" | "application/ld+json" | "audio/midi" | "audio/mpeg" | "video/mp4" | "video/mpeg" | "application/vnd.apple.installer+xml" | "application/vnd.oasis.opendocument.presentation" | "application/vnd.oasis.opendocument.spreadsheet" | "application/vnd.oasis.opendocument.text" | "audio/ogg" | "video/ogg" | "application/ogg" | "audio/opus" | "font/otf" | "image/png" | "application/x-httpd-php" | "application/pdf" | "application/vnd.ms-powerpoint" | "application/vnd.openxmlformats-officedocument.presentationml.presentation" | "application/vnd.rar" | "application/rtf" | "application/x-sh" | "image/svg+xml" | "application/x-shockwave-flash" | "application/x-tar" | "image/tiff" | "video/mp2t" | "application/x-font-ttf" | "text/plain" | "application/vnd.visio" | "audio/wav" | "audio/webm" | "video/webm" | "image/webp" | "font/woff" | "font/woff2" | "application/xhtml+xml" | "application/vnd.ms-excel" | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" | "application/xml" | "application/vnd.mozilla.xul+xml" | "application/zip" | "video/3gpp" | "video/32" | "application/x-7z-compressed";
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  suffix | String | 文件扩展名 |

**Returns:**

"" | "audio/aac" | "application/x-abiword" | "image/apng" | "application/x-freearc" | "image/avif" | "video/x-msvideo" | "application/vnd.amazon.ebook" | "application/octet-stream" | "image/bmp" | "application/x-bzip" | "application/x-bzip2" | "application/x-cdf" | "application/x-csh" | "text/css" | "text/csv" | "application/msword" | "application/vnd.openxmlformats-officedocument.wordprocessingml.document" | "application/vnd.ms-fontobject" | "application/epub+zip" | "application/gzip" | "image/gif" | "text/html" | "image/x-icon" | "text/calendar" | "application/java-archive" | "image/jpeg" | "text/javascript" | "application/json" | "application/ld+json" | "audio/midi" | "audio/mpeg" | "video/mp4" | "video/mpeg" | "application/vnd.apple.installer+xml" | "application/vnd.oasis.opendocument.presentation" | "application/vnd.oasis.opendocument.spreadsheet" | "application/vnd.oasis.opendocument.text" | "audio/ogg" | "video/ogg" | "application/ogg" | "audio/opus" | "font/otf" | "image/png" | "application/x-httpd-php" | "application/pdf" | "application/vnd.ms-powerpoint" | "application/vnd.openxmlformats-officedocument.presentationml.presentation" | "application/vnd.rar" | "application/rtf" | "application/x-sh" | "image/svg+xml" | "application/x-shockwave-flash" | "application/x-tar" | "image/tiff" | "video/mp2t" | "application/x-font-ttf" | "text/plain" | "application/vnd.visio" | "audio/wav" | "audio/webm" | "video/webm" | "image/webp" | "font/woff" | "font/woff2" | "application/xhtml+xml" | "application/vnd.ms-excel" | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" | "application/xml" | "application/vnd.mozilla.xul+xml" | "application/zip" | "video/3gpp" | "video/32" | "application/x-7z-compressed"

对应的MIME类型字符串

## Example

getMimeType('jpg'); // 返回 'image/jpeg' getMimeType('docx'); //返回'application/vnd.openxmlformats-officedocument.wordprocessingml.document'

---

---
url: /etc\doc/robinson.getnode.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getNode](./robinson.getnode.md)

## getNode() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数 getNode 将 DOM 元素名称作为输入，如果找到则返回相应的元素，否则返回 null。

**Signature:**

```typescript
declare function getNode(domName: string): Element | null;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  domName | string | domName 参数是一个字符串，表示您要选择的 DOM 元素的名称。 |

**Returns:**

Element | null

Element 对象或 null。

## Example

```JavaScript
   getNode('#id') ===document.querySelector('#id');
```

---

---
url: /etc\doc/robinson.getnodes.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getNodes](./robinson.getnodes.md)

## getNodes() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“getNodes”返回与给定选择器匹配的 DOM 节点的 NodeList，如果未找到节点，则返回 null。

**Signature:**

```typescript
declare function getNodes(domName: string): NodeList | null;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  domName | string | domName 参数是一个字符串，表示您要选择的 DOM 元素的名称。 |

**Returns:**

NodeList | null

NodeList 或 null。

## Example

```JavaScript
   let lis =getNodes('li') === document.querySelectorAll('li')
```

---

---
url: /etc\doc/robinson.getrandom.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getRandom](./robinson.getrandom.md)

## getRandom() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数 getRandom 生成指定范围内具有指定小数位数的随机数。

**Signature:**

```typescript
declare function getRandom(min: number, max: number, point?: number): number;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  min | number | 随机数范围的最小值。 |
|  max | number | “max”参数表示您要生成的最大值。 |
|  point | number | *(Optional)* “point”参数是一个可选参数，它指定将随机数舍入到的小数位数。如果没有为“point”提供值，则随机数将以整数形式返回。 |

**Returns:**

number

{number} - 指定最小值和最大值之间的随机数，具有指定的小数位数。

## Example

```JavaScript
   getRandom(1, 5) // 1~5 包含1,5
   getRandom(1, 5, 1) // 1.0~5 包含 1 5
```

---

---
url: /etc\doc/robinson.getrelarray.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getRelArray](./robinson.getrelarray.md)

## getRelArray() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“getRelArray”接受一个数组作为输入，并返回一个包含所有非空元素的新数组。

**Signature:**

```typescript
declare function getRelArray(array: Array<any>): Array<any>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  array | Array\<any> | 参数“array”是任意类型的数组。 |

**Returns:**

Array\<any>

{Array} 过滤掉空数据的新数组。

## Example

```JavaScript
   let arr =[1,2,3,null,undefined,4,[],{},NaN];
   getRelArray(arr) // [1,2,3,4]
```

---

---
url: /etc\doc/robinson.gettimestamp.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getTimestamp](./robinson.gettimestamp.md)

## getTimestamp() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

获取当前日期的时间戳。

**Signature:**

```typescript
declare function getTimestamp(date: Tday): number;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  date | Tday | 输入的日期，可以是 dayjs 对象、Date 对象或字符串。 |

**Returns:**

number

{number} - 返回时间戳（毫秒数）。

## Example

```javascript
getTimestamp(dayjs('2024-03-01 08:00:00')) // 1709251200000
```

---

---
url: /etc\doc/robinson.getuniqueid.md
---
[Home](./index.md) > [robinson](./robinson.md) > [getUniqueId](./robinson.getuniqueid.md)

## getUniqueId() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数使用随机字符串模式生成唯一 ID。

**Signature:**

```typescript
declare function getUniqueId(): string;
```

**Returns:**

string

{string} - 函数“getUniqueId”返回格式为“xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx”的唯一标识符字符串。

## Example

```JavaScript
 getUniqueId() // '627ad809-60fc-47b1-be5d-e0ae1ef903ca'
```

---

---
url: /etc\doc/robinson.hastypein.md
---
[Home](./index.md) > [robinson](./robinson.md) > [hasTypeIn](./robinson.hastypein.md)

## hasTypeIn() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查给定值的类型是否存在于给定类型数组中。

**Signature:**

```typescript
declare function hasTypeIn(value: any, types: Array<string>): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数是您要检查其类型的值。它可以是任何类型，例如数字、字符串、对象等。 |
|  types | Array\<string> | 表示要检查的类型的字符串数组。 |

**Returns:**

boolean

{boolean} 一个布尔值。

## Example

```JavaScript
    let a ="123"; isTypeIn(a,['number','array','string']) // true
    let a ={}; isTypeIn(a,['number','array','string']) // false
```

---

---
url: /etc\doc/robinson.hasclass.md
---
[Home](./index.md) > [robinson](./robinson.md) > [hasClass](./robinson.hasclass.md)

## hasClass() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查元素是否具有特定的类名。

**Signature:**

```typescript
declare function hasClass(dom: Element, classNm: String): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  dom | Element | “dom”参数的类型为“Element”，表示我们要检查其是否存在类的 DOM 元素。 |
|  classNm | String | “classNm”参数是一个字符串，表示您要在“dom”元素中检查的类名。 |

**Returns:**

boolean

一个布尔值，指示给定的 DOM 元素是否具有指定的类名。

## Example

```JavaScript
   let div =document.createElement('div');
   div.classList="a1 a2 a3"
   hasClass(div,'a1')  => true
```

---

---
url: /etc\doc/robinson.hextorgb.md
---
[Home](./index.md) > [robinson](./robinson.md) > [hexToRgb](./robinson.hextorgb.md)

## hexToRgb() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将十六进制颜色字符串转换为rgb颜色字符串

**Signature:**

```typescript
declare function hexToRgb(hex: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  hex | string | 十六进制颜色字符串 |

**Returns:**

string

{string} 转换后的rgb颜色字符串，如果输入无效则返回空字符串

## Example

```javascript
hexToRgb('#FD7086'); // 'rgb(253,112,134)'
hexToRgb('rgb(253,112,134,0.9)'); // ''
```

---

---
url: /etc\doc/robinson.hextorgba.md
---
[Home](./index.md) > [robinson](./robinson.md) > [hexToRgba](./robinson.hextorgba.md)

## hexToRgba() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将十六进制颜色字符串转换为rgba颜色字符串

**Signature:**

```typescript
declare function hexToRgba(hex: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  hex | string | 十六进制颜色字符串 |

**Returns:**

string

{string} 转换后的rgba颜色字符串，如果输入无效则返回空字符串

## Example

```javascript
hexToRgba('#FD7086'); // 'rgba(253,112,134,1)'
hexToRgba('rgba(253,112,134,0.9)'); // ''
```

---

---
url: /etc\doc/robinson.imgcompression.md
---
[Home](./index.md) > [robinson](./robinson.md) > [imgCompression](./robinson.imgcompression.md)

## imgCompression() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

压缩图片文件

**Signature:**

```typescript
declare function imgCompression(file: File, size: number): Promise<unknown>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  file | File | 源文件 |
|  size | number | 指定压缩大小（单位：MB） |

**Returns:**

Promise\<unknown>

Promise对象，解析为压缩后的Base64编码字符串

## Example

imgCompression(fileInput.files\[0], 0.5).then(compressedBase64 => console.log(compressedBase64));

---

---
url: /etc\doc/robinson.insertstr.md
---
[Home](./index.md) > [robinson](./robinson.md) > [insertStr](./robinson.insertstr.md)

## insertStr() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“insertStr”接受一个字符串、一个起始索引和一个字符，并返回一个新字符串，其中在指定索引处插入了该字符。

**Signature:**

```typescript
declare function insertStr(str: string, start: number, char: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  str | string | str 参数是一个字符串，表示将在其中插入字符的原始字符串。 |
|  start | number | start 参数是应在字符串中插入字符的索引。 |
|  char | string | “char”参数是一个字符串，表示要插入到原始字符串中的字符或子字符串。 |

**Returns:**

string

{string} - 在指定索引处插入指定字符的新字符串。

## Example

```JavaScript
 let str = 'Hello'; insertStr(str, 2, 'X') // 'HeXllo'
```

---

---
url: /etc\doc/robinson.is.md
---
[Home](./index.md) > [robinson](./robinson.md) > [is](./robinson.is.md)

## is() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

返回是某个类型的判断结果

**Signature:**

```typescript
declare function is(value: any, type: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 要判断的数据 |
|  type | string | 判断他是这个类型 |

**Returns:**

boolean

{boolean} 布尔值

## Example

```JavaScript
   let a = 1; is(a,'number')// true
   let b = 2; is(a,'Number') // true
   let c ="2"; is(a,'string') // true
```

---

---
url: /etc\doc/robinson.isafter.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isAfter](./robinson.isafter.md)

## isAfter() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断一个日期是否在另一个日期之后。

**Signature:**

```typescript
declare function isAfter(start: dayjs.ConfigType, end: dayjs.ConfigType): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  start | dayjs.ConfigType | 开始日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  end | dayjs.ConfigType | 结束日期，可以是 dayjs 对象、Date 对象或字符串。 |

**Returns:**

boolean

{boolean} - 如果开始日期在结束日期之后返回 true，否则返回 false。

---

---
url: /etc\doc/robinson.isarray.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isArray](./robinson.isarray.md)

## isArray() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

接受一个任意类型判断该类型是否是数组并返回。

**Signature:**

```typescript
declare function isArray(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”的类型为“any”，这意味着它可以接受任何数据类型。 |

**Returns:**

boolean

{boolean} 一个布尔值。

## Example

```javascript
   let a ="789";
   isArray(a) // false
   let n=[]
   isArray(n)   //true
```

---

---
url: /etc\doc/robinson.isbefore.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isBefore](./robinson.isbefore.md)

## isBefore() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断一个日期是否在另一个日期之前。

**Signature:**

```typescript
declare function isBefore(start: dayjs.ConfigType, end: dayjs.ConfigType): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  start | dayjs.ConfigType | 开始日期，可以是 dayjs 对象、Date 对象或字符串。 |
|  end | dayjs.ConfigType | 结束日期，可以是 dayjs 对象、Date 对象或字符串。 |

**Returns:**

boolean

{boolean} - 如果开始日期在结束日期之前返回 true，否则返回 false。

---

---
url: /etc\doc/robinson.isboolean.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isBoolean](./robinson.isboolean.md)

## isBoolean() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“isBoolean”检查值是否为布尔类型。

**Signature:**

```typescript
declare function isBoolean(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”可以是任何数据类型。 |

**Returns:**

boolean

{boolean} 函数 isBoolean 返回一个布尔值。

## Example

```JavaScript
   let boo = true;
   isBoolean(boo) // true
   let str = "true";
   isBoolean(boo) // false
```

---

---
url: /etc\doc/robinson.isdecimal.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isDecimal](./robinson.isdecimal.md)

## isDecimal() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

检查变量是否为实数

**Signature:**

```typescript
declare function isDecimal(s: string | number): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  s | string | number | 要检查的变量 |

**Returns:**

boolean

{boolean} - 检查结果

## Example

```JavaScript
 isDecimal(123)// true
 isDecimal('123.45') // true
 isDecimal('abc') // false
```

---

---
url: /etc\doc/robinson.iselement.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isElement](./robinson.iselement.md)

## isElement() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

是否为DOM元素

**Signature:**

```typescript
declare function isElement(val: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  val | any | 参数“val”的类型为“any”，这意味着它可以是任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let div = document.createElement('div'); isElement(div) // true
 let str = 'not an element'; isElement(str) //false
```

---

---
url: /etc\doc/robinson.isemail.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isEmail](./robinson.isemail.md)

## isEmail() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

检查字符串是否为合法email地址

**Signature:**

```typescript
declare function isEmail(s: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  s | string | 字符串 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let email = 'test@example.com'; isEmail(email) // true
 let email = 'invalid-email'; isEmail(email) // false
```

---

---
url: /etc\doc/robinson.isempty.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isEmpty](./robinson.isempty.md)

## isEmpty() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数通过将 JSON 表示形式与空数组或对象进行比较来检查值是否为空。

**Signature:**

```typescript
declare function isEmpty(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数可以是任何数据类型。这是您要检查它是否为空的值。 |

**Returns:**

boolean

{boolean} 一个布尔值。如果值为空（空数组或空对象）或值为假（例如 null、undefined、false、0 或空字符串）， 则返回 true。否则，返回 false。

## Example

```JavaScript
   let a =null; isEmpty(a) // true
   let a =undefined; isEmpty(a) // true
   let a =''; isEmpty(a) // true
   let a={};  isEmpty(a) // true
   let a=[];  isEmpty(a) // true
```

---

---
url: /etc\doc/robinson.iseqtype.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isEqType](./robinson.iseqtype.md)

## isEqType() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“isEqType”检查两个值的类型是否相等。

**Signature:**

```typescript
declare function isEqType(value: any, value2: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数的类型为“any”，这意味着它可以接受任何类型的值。 |
|  value2 | any | “value2”参数是您要与之比较类型的第二个值。 |

**Returns:**

boolean

{boolean} 一个布尔值。

```JavaScript
let a =1;
let b =new Number();
isEqType(value,value2) // true

let a ='1';
let b =new Number();
isEqType(value,value2) // false

```

---

---
url: /etc\doc/robinson.iseqvalue.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isEqValue](./robinson.iseqvalue.md)

## isEqValue() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“isEqValue”比较两个值，如果它们的值和类型相等则返回 true。

**Signature:**

```typescript
declare function isEqValue(value1: any, value2: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value1 | any | 要比较的第一个值。它可以是任何类型。 |
|  value2 | any | “value2”参数是要与“value1”比较的第二个值。 |

**Returns:**

boolean

{boolean} 一个布尔值。

## Example

```JavaScript
let a =NaN;let b = NaN; isEqValue(a,b) //true
```

---

---
url: /etc\doc/robinson.isexternal.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isExternal](./robinson.isexternal.md)

## isExternal() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断是否为外链

**Signature:**

```typescript
declare function isExternal(path: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  path | any | 路径 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let path = 'https://example.com'; isExternal(path) // true
 let path = '/internal/path'; isExternal(path)// false
```

---

---
url: /etc\doc/robinson.isfunction.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isFunction](./robinson.isfunction.md)

## isFunction() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查给定值是否是函数。

**Signature:**

```typescript
declare function isFunction(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数是我们想要检查它是否是函数的任何值。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

isFunction(() => {}); // 返回 true isFunction(123); // 返回 false

---

---
url: /etc\doc/robinson.isfinite_2.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isFinite\_2](./robinson.isfinite_2.md)

## isFinite\_2() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查一个值是否是有限数,原生的已经很好用了 这里是为了保存api统一。

**Signature:**

```typescript
declare function isFinite(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数可以是您想要检查是否是有限数的任何值。 |

**Returns:**

boolean

{boolean} - 函数 isFinite 返回一个布尔值。

## Example

```JavaScript
 let a = 0.1 + 0.2; isFinite(a)// true
 let n1 = {}; isFinite(n1) // false
```

---

---
url: /etc\doc/robinson.ishex.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isHex](./robinson.ishex.md)

## isHex() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断是否为16进制颜色

**Signature:**

```typescript
declare function isHex(color: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | 需要验证的颜色字符串 |

**Returns:**

boolean

{boolean} 如果是16进制颜色返回true，否则返回false

## Example

```JavaScript
    isHex('#FD7086') //true
    isHex('rgba(253,112,134,0.9)') // false
```

---

---
url: /etc\doc/robinson.isidcard.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isIdCard](./robinson.isidcard.md)

## isIdCard() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

检查是否为有效的身份证号

**Signature:**

```typescript
declare function isIdCard(id: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  id | string | 身份证号 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let id = '11010519491231002X'; isIdCard(id) // true
 let id = '11010519491231002Y'; isIdCard(id) // false
```

---

---
url: /etc\doc/robinson.isie.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isIE](./robinson.isie.md)

## isIE() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断是否是IE浏览器

**Signature:**

```typescript
declare function isIE(win: Iwindow): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  win | Iwindow | 参数“win”是一个包含navigator对象的对象。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let win = { navigator: { userAgent: `Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0;
.NET4.0E; .NET4.0C; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729;
 InfoPath.3; rv:11.0) like Gecko` } };
 isIE(win) //true
 let win = { navigator: { userAgent: `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)
 AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.6.1 Safari/605.1.15` } };
 isIE(win) // false
```

---

---
url: /etc\doc/robinson.isint.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isInt](./robinson.isint.md)

## isInt() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“isInteger”检查给定值是否为整数,原生的判断已经很好用了 es6+。

**Signature:**

```typescript
declare function isInt(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数可以是任何数据类型，例如数字、字符串、布尔值或对象。该函数将检查该值是否为整数，并返回一个布尔值来指示它是否为整数。 |

**Returns:**

boolean

{boolean} - 一个布尔值，指示给定值是否为整数。

## Example

```JavaScript
 let n = '1.1'; isInteger(n) // false
 let n2 = 2; isInteger(n2) // true
```

---

---
url: /etc\doc/robinson.isleapyear.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isLeapYear](./robinson.isleapyear.md)

## isLeapYear() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断给定年份是否为闰年。

**Signature:**

```typescript
declare function isLeapYear(year: string | number): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  year | string | number | 要判断的年份，可以是字符串或数字。 |

**Returns:**

boolean

{boolean} - 如果是闰年返回 true，否则返回 false。

## Example

```javascript
isLeapYear('2024') // true
isLeapYear('2025') // false
```

---

---
url: /etc\doc/robinson.ismobilenum.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isMobileNum](./robinson.ismobilenum.md)

## isMobileNum() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

是否为合法手机号

**Signature:**

```typescript
declare function isMobileNum(s: string | number): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  s | string | number | 手机号 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let phone = '13800138000'; isMobileNum(phone) // true
 let phone = '12345678901'; isMobileNum(phone)// false
```

---

---
url: /etc\doc/robinson.isnan_2.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isNaN\_2](./robinson.isnan_2.md)

## isNaN\_2() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查值是否为 NaN。

**Signature:**

```typescript
declare function isNaN(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | value 参数可以是任何数据类型，例如数字、字符串或对象。 |

**Returns:**

boolean

{boolean} - 一个布尔值，指示给定值是否为 NaN（非数字）。

## Example

```JavaScript
   let str = 'ad1'; isNaN(str) // true
   let n = 1; isNaN(n) // false
```

---

---
url: /etc\doc/robinson.isnode.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isNode](./robinson.isnode.md)

## isNode() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查元素是否是节点。

**Signature:**

```typescript
declare function isNode(el: any): Boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  el | any | el 参数的类型是 Element，它表示 HTML DOM 中的一个元素。 |

**Returns:**

Boolean

一个布尔值。如果给定元素的 nodeType 为 1 (ELEMENT\_NODE)、9 (DOCUMENT\_NODE) 或 11 (DOCUMENT\_FRAGMENT\_NODE)，则返回 true。否则，返回 false。

## Example

```JavaScript
   let div =document.createElement('div');
   isNode(div) =>true
```

---

---
url: /etc\doc/robinson.isnull.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isNull](./robinson.isnull.md)

## isNull() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“isNull”检查给定值是否为空。

**Signature:**

```typescript
declare function isNull(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”的类型为“any”，这意味着它可以接受任何数据类型。 |

**Returns:**

boolean

{boolean} 函数 isNull 返回一个布尔值。

```JavaScript
 let a =null; isNull(a)// true
```

---

---
url: /etc\doc/robinson.isnumber.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isNumber](./robinson.isnumber.md)

## isNumber() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查值是否为数字。

**Signature:**

```typescript
declare function isNumber(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”可以是任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let n = 7; isNumber(n) // true
 let n1 = '8'; isNumber(n1) // false
```

---

---
url: /etc\doc/robinson.isobjectlike.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isObjectLike](./robinson.isobjectlike.md)

## isObjectLike() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查值是否是类对象like 类型。

**Signature:**

```typescript
declare function isObjectLike(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”的类型为“any”，这意味着它可以是任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let a = {}; isObjectLike(a) // true
 let a = null; isObjectLike(a) // false
 let a = new WeakSet(); isObjectLike(a) // true
 let a = []; isObjectLike(a)// true
```

---

---
url: /etc\doc/robinson.isorigindate.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isOriginDate](./robinson.isorigindate.md)

## isOriginDate() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

是否为日期格式

**Signature:**

```typescript
declare function isOriginDate(val: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  val | any | 参数“val”的类型为“any”，这意味着它可以是任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let date = new Date(); isOriginDate(date) // true
 let str = '2023-10-01'; isOriginDate(str) // false
```

---

---
url: /etc\doc/robinson.ispromise.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isPromise](./robinson.ispromise.md)

## isPromise() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

是否为Promise格式

**Signature:**

```typescript
declare function isPromise(val: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  val | any | 参数“val”的类型为“any”，这意味着它可以是任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let promise = new Promise(() => {}); isPromise(promise)// true
 let str = 'not a promise'; isPromise(str)// false
```

---

---
url: /etc\doc/robinson.isrange.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isRange](./robinson.isrange.md)

## isRange() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查给定值是否在指定范围内。

**Signature:**

```typescript
declare function isRange(value: number, min: number, max: number): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | number | value 参数表示要检查的数字是否在某个范围内。 |
|  min | number | “value”参数可以是的最小值。 |
|  max | number | “max”参数表示范围的最大值。 |

**Returns:**

boolean

{boolean} - 一个布尔值，指示给定值是否在指定范围内（包括最小值，不包括最大值）。

## Example

```JavaScript
 let n = 7; isRange(n, 7, 8) // true 包含7 8
 let n = 7; isRange(n, 7, 7) // true 包含7
```

---

---
url: /etc\doc/robinson.isreftype.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isRefType](./robinson.isreftype.md)

## isRefType() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查值是否为引用类型。

**Signature:**

```typescript
declare function isRefType(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数的类型为“any”，这意味着它可以接受任何类型的值。 |

**Returns:**

boolean

{boolean} 一个布尔值。

## Example

```JavaScript
   let num =123; isRefType(num) // true
   let obj ={};  isRefType(obj) // false
```

---

---
url: /etc\doc/robinson.isregexp.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isRegExp](./robinson.isregexp.md)

## isRegExp() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

是否为正则格式

**Signature:**

```typescript
declare function isRegExp(val: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  val | any | 参数“val”的类型为“any”，这意味着它可以是任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let regex = /abc/; isRegExp(regex) // true
 let str = 'abc'; isRegExp(str) // false
```

---

---
url: /etc\doc/robinson.isrgb.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isRgb](./robinson.isrgb.md)

## isRgb() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断是否为rgb颜色

**Signature:**

```typescript
declare function isRgb(color: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | 需要验证的颜色字符串 |

**Returns:**

boolean

{boolean} 如果是rgb颜色返回true，否则返回false

## Example

```JavaScript
    isRgb('#FD7086') //false
    isRgb('rgba(253,112,134,0.9)') //false
    isRgb(null) // false
    isRgb({}) // false
    isRgb('rgb(255,255,255)') // true
    isRgb('rgb(256,256,256)') //false
```

---

---
url: /etc\doc/robinson.isrgba.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isRgba](./robinson.isrgba.md)

## isRgba() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

判断是否为rgba颜色

**Signature:**

```typescript
declare function isRgba(color: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | 需要验证的颜色字符串 |

**Returns:**

boolean

{boolean} 如果是rgba颜色返回true，否则返回false

## Example

```JavaScript
    isRgba('#FD7086') // false
    isRgba('rgba(253,112,134,0.9)') // true
    isRgba('rgba(253,112,134,1.1)')// false
    isRgba(null) // false
    isRgba({}) // false
    isRgba('rgb(255,255,255)') // false
    isRgba('rgb(256,256,256)') // false
```

---

---
url: /etc\doc/robinson.isstring.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isString](./robinson.isstring.md)

## isString() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数isString 检查给定值是否是字符串。

**Signature:**

```typescript
declare function isString(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”的类型为“any”，这意味着它可以接受任何数据类型。 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let str = 'Hello'; isString(str) // true
 let num = 123; isString(num) // false
```

---

---
url: /etc\doc/robinson.issimpletype.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isSimpleType](./robinson.issimpletype.md)

## isSimpleType() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查值是否为简单值（数字、字符串、布尔值、符号、null、undefined 或 bigint）或复杂值（函数、对象、数组、集合、映射）。

**Signature:**

```typescript
declare function isSimpleType(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”的类型为“any”，这意味着它可以接受任何类型的值。 |

**Returns:**

boolean

{boolean} 函数 isSimpleType 返回一个布尔值。

## Example

```JavaScript
   let num =123; isSimpleType(num) // true
   let obj ={};  isSimpleType(obj) // false
```

---

---
url: /etc\doc/robinson.issymbol.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isSymbol](./robinson.issymbol.md)

## isSymbol() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数检查值是否是Symbol 类型的对象。

**Signature:**

```typescript
declare function isSymbol(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | 参数“value”可以是任何数据类型。 |

**Returns:**

boolean

{boolean} 函数 isSymbol 返回一个布尔值。

## Example

```JavaScript
let a =Symbol(); isSymbol(a) // true
```

---

---
url: /etc\doc/robinson.isundefined.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isUndefined](./robinson.isundefined.md)

## isUndefined() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“isUndefined”检查值是否未定义。

**Signature:**

```typescript
declare function isUndefined(value: any): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  value | any | “value”参数的类型为“any”，这意味着它可以接受任何类型的值。 |

**Returns:**

boolean

{boolean} 函数 isUndefined 返回一个布尔值。

## Example

```JavaScript
   let a; isUndefined(a) // true
```

---

---
url: /etc\doc/robinson.isurl.md
---
[Home](./index.md) > [robinson](./robinson.md) > [isUrl](./robinson.isurl.md)

## isUrl() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

检查是否为有效的URL

**Signature:**

```typescript
declare function isUrl(url: string): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  url | string | URL字符串 |

**Returns:**

boolean

{boolean} - 一个布尔值。

## Example

```JavaScript
 let url = 'https://example.com'; isUrl(url) // true
 let url = 'invalid-url'; isUrl(url) // false
```

---

---
url: /etc\doc/robinson.mapping.md
---
[Home](./index.md) > [robinson](./robinson.md) > [mapping](./robinson.mapping.md)

## mapping() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

映射函数可以将数据进行枚举映射。

**Signature:**

```typescript
declare function mapping(enumData: enumData, options: options, expty?: string): result;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  enumData | enumData | 枚举数据，可以是对象或数组。 |
|  options | options | 选项，可以是字符串或对象。 |
|  expty | string | *(Optional)* 如果枚举中寻找不到，返回的默认值，默认为 '--'。 |

**Returns:**

result

{result} - 映射后的结果。

## Example

```JavaScript
let enum1 = [{ value: 'USD', label: '美元' }, { value: 'AUD', label: '澳大利亚元' }];
// 返回 { value: 'USD', label: '美元' }
mapping(enum1, { key: 'value', keyValue: 'USD', label: 'label', type: 'object' });
// 返回 '美元'
mapping(enum1, { key: 'value', keyValue: 'USD', label: 'label', type: 'value' });
let enum2 = { USD: '美元', AUD: '澳大利亚元' };
// 返回 '美元'
mapping(enum2, 'USD');
```

---

---
url: /etc\doc/robinson.md
---
[Home](./index.md) > [robinson](./robinson.md)

## robinson package

## Classes

|  Class | Description |
|  --- | --- |
|  [EventBus](./robinson.eventbus.md) | ***(BETA)***  函数“on”将事件侦听器添加到事件对象，将事件函数存储在指定的事件名称下。 |

## Functions

|  Function | Description |
|  --- | --- |
|  [addClass(dom, classNm)](./robinson.addclass.md) | ***(BETA)***  该函数将一个类添加到 DOM 元素。 |
|  [addNode(parentDom, dom, position)](./robinson.addnode.md) | ***(BETA)***  函数“addNode”将 DOM 元素或字符串插入到父 DOM 元素的指定位置。 |
|  [asignData(obj1, obj2)](./robinson.asigndata.md) | ***(BETA)***  函数“asignData”将属性从“obj2”复制到“obj1”，并可选择执行附加函数。 |
|  [base64ToBlob(base64)](./robinson.base64toblob.md) | ***(BETA)***  将Base64编码的字符串转换为Blob对象 |
|  [bind(dom, eventType, callBack, isCatch)](./robinson.bind.md) | ***(BETA)***  该函数将事件侦听器绑定到 TypeScript 中的 DOM 元素。 |
|  [blobToBase64(blob, suffix)](./robinson.blobtobase64.md) | ***(BETA)***  将Blob对象转换为Base64编码的字符串 |
|  [calc(number1, number2, operate)](./robinson.calc.md) | ***(BETA)***  数值计算 |
|  [compose(fns)](./robinson.compose.md) | ***(BETA)***  组合函数，将多个函数从右到左依次调用。 |
|  [copyToClipboard(text)](./robinson.copytoclipboard.md) | ***(BETA)***  将文本复制到剪贴板。 |
|  [createCache(storage, parmas)](./robinson.createcache.md) | ***(BETA)***  createCache 函数创建一个缓存对象，该对象可以使用指定的存储机制和编码/解码函数来存储和检索数据。 |
|  [currying(fn)](./robinson.currying.md) | ***(BETA)***  柯里化函数接受一个函数作为输入并返回一个新函数，该函数可以使用多个参数或以柯里化方式调用。 |
|  [debounce(fn, delay, isLimmediate)](./robinson.debounce.md) | ***(BETA)***  防抖函数，限制函数调用的频率。 |
|  [deepClone(originalValue)](./robinson.deepclone.md) | ***(BETA)***  “deepClone”函数用于创建对象或数组的深层副本，包括处理复杂类型，例如集合、映射和符号。 |
|  [downloadByBase64(buf, fileNm, suffix)](./robinson.downloadbybase64.md) | ***(BETA)***  通过Base64编码的字符串下载文件 |
|  [downloadByBlob(blob, fileNm, suffix)](./robinson.downloadbyblob.md) | ***(BETA)***  通过Blob对象下载文件 |
|  [downloadByUrl(url, filename, type)](./robinson.downloadbyurl.md) | ***(BETA)***  通过URL下载图片到本地 |
|  [formatDate(date, pattern)](./robinson.formatdate.md) | ***(BETA)***  格式化时间。 |
|  [getAfterDate(date, option)](./robinson.getafterdate.md) | ***(BETA)***  计算给定日期之后的日期，并返回格式化后的结果。 |
|  [getBeforeDate(date, option)](./robinson.getbeforedate.md) | ***(BETA)***  计算给定日期之前的日期，并返回格式化后的结果。 |
|  [getChunkArray(array, size)](./robinson.getchunkarray.md) | ***(BETA)***  chunkArray 函数接受一个数组和一个大小参数，并返回一个新数组，其中原始数组被分割成指定大小的较小数组。 |
|  [getDiff(start, end, unitType, float)](./robinson.getdiff.md) | ***(BETA)***  计算两个日期之间的差值。 |
|  [getEtc(value, len, etcStr)](./robinson.getetc.md) | ***(BETA)***  函数“getEtc”接受一个字符串值并返回指定长度的子字符串，并在末尾附加一个可选的“etcStr”。 |
|  [getFileChunk(file, chunkSize)](./robinson.getfilechunk.md) | ***(BETA)***  生成文件切片数组 |
|  [getFileSize(file, unit)](./robinson.getfilesize.md) | ***(BETA)***  获取文件大小 |
|  [getFileType(file)](./robinson.getfiletype.md) | ***(BETA)***  获取文件后缀名 |
|  [getMimeType(suffix)](./robinson.getmimetype.md) | ***(BETA)***  获取文件的MIME类型 |
|  [getNode(domName)](./robinson.getnode.md) | ***(BETA)***  函数 getNode 将 DOM 元素名称作为输入，如果找到则返回相应的元素，否则返回 null。 |
|  [getNodes(domName)](./robinson.getnodes.md) | ***(BETA)***  函数“getNodes”返回与给定选择器匹配的 DOM 节点的 NodeList，如果未找到节点，则返回 null。 |
|  [getRandom(min, max, point)](./robinson.getrandom.md) | ***(BETA)***  函数 getRandom 生成指定范围内具有指定小数位数的随机数。 |
|  [getRelArray(array)](./robinson.getrelarray.md) | ***(BETA)***  函数“getRelArray”接受一个数组作为输入，并返回一个包含所有非空元素的新数组。 |
|  [getTimestamp(date)](./robinson.gettimestamp.md) | ***(BETA)***  获取当前日期的时间戳。 |
|  [getUniqueId()](./robinson.getuniqueid.md) | ***(BETA)***  该函数使用随机字符串模式生成唯一 ID。 |
|  [hasClass(dom, classNm)](./robinson.hasclass.md) | ***(BETA)***  该函数检查元素是否具有特定的类名。 |
|  [hasTypeIn(value, types)](./robinson.hastypein.md) | ***(BETA)***  该函数检查给定值的类型是否存在于给定类型数组中。 |
|  [hexToRgb(hex)](./robinson.hextorgb.md) | ***(BETA)***  将十六进制颜色字符串转换为rgb颜色字符串 |
|  [hexToRgba(hex)](./robinson.hextorgba.md) | ***(BETA)***  将十六进制颜色字符串转换为rgba颜色字符串 |
|  [imgCompression(file, size)](./robinson.imgcompression.md) | ***(BETA)***  压缩图片文件 |
|  [insertStr(str, start, char)](./robinson.insertstr.md) | ***(BETA)***  函数“insertStr”接受一个字符串、一个起始索引和一个字符，并返回一个新字符串，其中在指定索引处插入了该字符。 |
|  [is(value, type)](./robinson.is.md) | ***(BETA)***  返回是某个类型的判断结果 |
|  [isAfter(start, end)](./robinson.isafter.md) | ***(BETA)***  判断一个日期是否在另一个日期之后。 |
|  [isArray(value)](./robinson.isarray.md) | ***(BETA)***  接受一个任意类型判断该类型是否是数组并返回。 |
|  [isBefore(start, end)](./robinson.isbefore.md) | ***(BETA)***  判断一个日期是否在另一个日期之前。 |
|  [isBoolean(value)](./robinson.isboolean.md) | ***(BETA)***  函数“isBoolean”检查值是否为布尔类型。 |
|  [isDecimal(s)](./robinson.isdecimal.md) | ***(BETA)***  检查变量是否为实数 |
|  [isElement(val)](./robinson.iselement.md) | ***(BETA)***  是否为DOM元素 |
|  [isEmail(s)](./robinson.isemail.md) | ***(BETA)***  检查字符串是否为合法email地址 |
|  [isEmpty(value)](./robinson.isempty.md) | ***(BETA)***  该函数通过将 JSON 表示形式与空数组或对象进行比较来检查值是否为空。 |
|  [isEqType(value, value2)](./robinson.iseqtype.md) | ***(BETA)***  函数“isEqType”检查两个值的类型是否相等。 |
|  [isEqValue(value1, value2)](./robinson.iseqvalue.md) | ***(BETA)***  函数“isEqValue”比较两个值，如果它们的值和类型相等则返回 true。 |
|  [isExternal(path)](./robinson.isexternal.md) | ***(BETA)***  判断是否为外链 |
|  [isFinite\_2(value)](./robinson.isfinite_2.md) | ***(BETA)***  该函数检查一个值是否是有限数,原生的已经很好用了 这里是为了保存api统一。 |
|  [isFunction(value)](./robinson.isfunction.md) | ***(BETA)***  该函数检查给定值是否是函数。 |
|  [isHex(color)](./robinson.ishex.md) | ***(BETA)***  判断是否为16进制颜色 |
|  [isIdCard(id)](./robinson.isidcard.md) | ***(BETA)***  检查是否为有效的身份证号 |
|  [isIE(win)](./robinson.isie.md) | ***(BETA)***  判断是否是IE浏览器 |
|  [isInt(value)](./robinson.isint.md) | ***(BETA)***  函数“isInteger”检查给定值是否为整数,原生的判断已经很好用了 es6+。 |
|  [isLeapYear(year)](./robinson.isleapyear.md) | ***(BETA)***  判断给定年份是否为闰年。 |
|  [isMobileNum(s)](./robinson.ismobilenum.md) | ***(BETA)***  是否为合法手机号 |
|  [isNaN\_2(value)](./robinson.isnan_2.md) | ***(BETA)***  该函数检查值是否为 NaN。 |
|  [isNode(el)](./robinson.isnode.md) | ***(BETA)***  该函数检查元素是否是节点。 |
|  [isNull(value)](./robinson.isnull.md) | ***(BETA)***  函数“isNull”检查给定值是否为空。 |
|  [isNumber(value)](./robinson.isnumber.md) | ***(BETA)***  该函数检查值是否为数字。 |
|  [isObjectLike(value)](./robinson.isobjectlike.md) | ***(BETA)***  该函数检查值是否是类对象like 类型。 |
|  [isOriginDate(val)](./robinson.isorigindate.md) | ***(BETA)***  是否为日期格式 |
|  [isPromise(val)](./robinson.ispromise.md) | ***(BETA)***  是否为Promise格式 |
|  [isRange(value, min, max)](./robinson.isrange.md) | ***(BETA)***  该函数检查给定值是否在指定范围内。 |
|  [isRefType(value)](./robinson.isreftype.md) | ***(BETA)***  该函数检查值是否为引用类型。 |
|  [isRegExp(val)](./robinson.isregexp.md) | ***(BETA)***  是否为正则格式 |
|  [isRgb(color)](./robinson.isrgb.md) | ***(BETA)***  判断是否为rgb颜色 |
|  [isRgba(color)](./robinson.isrgba.md) | ***(BETA)***  判断是否为rgba颜色 |
|  [isSimpleType(value)](./robinson.issimpletype.md) | ***(BETA)***  该函数检查值是否为简单值（数字、字符串、布尔值、符号、null、undefined 或 bigint）或复杂值（函数、对象、数组、集合、映射）。 |
|  [isString(value)](./robinson.isstring.md) | ***(BETA)***  函数isString 检查给定值是否是字符串。 |
|  [isSymbol(value)](./robinson.issymbol.md) | ***(BETA)***  该函数检查值是否是Symbol 类型的对象。 |
|  [isUndefined(value)](./robinson.isundefined.md) | ***(BETA)***  函数“isUndefined”检查值是否未定义。 |
|  [isUrl(url)](./robinson.isurl.md) | ***(BETA)***  检查是否为有效的URL |
|  [mapping(enumData, options, expty)](./robinson.mapping.md) | ***(BETA)***  映射函数可以将数据进行枚举映射。 |
|  [nodeToString(node)](./robinson.nodetostring.md) | ***(BETA)***  函数 nodeToString 接受一个 HTML 元素并返回它的字符串表示形式。 |
|  [parseColorString(color)](./robinson.parsecolorstring.md) | ***(BETA)***  解析颜色字符串为颜色对象该函数可以解析十六进制颜色字符串或rgba颜色字符串为颜色对象 |
|  [parseHexColor(color)](./robinson.parsehexcolor.md) | ***(BETA)***  解析十六进制颜色字符串为RGBA对象该函数接受一个十六进制颜色字符串（例如 "#RRGGBB" 或 "#RGB"）， 并将其解析为一个包含红（r）、绿（g）、蓝（b）和透明度（a）分量的对象 |
|  [parseRgbaColor(color)](./robinson.parsergbacolor.md) | ***(BETA)***  解析rgba颜色字符串为颜色对象 |
|  [pipe(fns)](./robinson.pipe.md) | ***(BETA)***  从左向右执行函数。 |
|  [preventDefault(event)](./robinson.preventdefault.md) | 该函数可防止事件的默认行为。 |
|  [printByBlob(blob, type)](./robinson.printbyblob.md) | ***(BETA)***  通过Blob对象打印内容 |
|  [printByDom(el, custStyle)](./robinson.printbydom.md) | ***(BETA)***  通过DOM元素打印内容 |
|  [removeClass(dom, classNm)](./robinson.removeclass.md) | ***(BETA)***  该函数从给定的 DOM 元素中删除指定的类名。 |
|  [removeNode(parentNode, dom)](./robinson.removenode.md) | ***(BETA)***  该函数从其父节点中删除指定的 DOM 元素。 |
|  [renderTmp(selecter, data)](./robinson.rendertmp.md) | ***(BETA)***  该函数获取元素的InnerHtml字符串模板,填写好内容并返回 |
|  [replaceClass(dom, newClass, oldClass)](./robinson.replaceclass.md) | 该函数将给定 DOM 元素上的旧类替换为新类。 |
|  [replaceNode(parentNode, newDom, oldDom)](./robinson.replacenode.md) | ***(BETA)***  函数“replaceNode”用新的 DOM 元素或给定父元素中的字符串替换旧的 DOM 元素。 |
|  [rgbaToHex(color)](./robinson.rgbatohex.md) | ***(BETA)***  将rgba颜色字符串转换为十六进制颜色字符串 |
|  [rgbToHex(color)](./robinson.rgbtohex.md) | ***(BETA)***  将rgb颜色字符串转换为十六进制颜色字符串 |
|  [stopPropagation(event)](./robinson.stoppropagation.md) | ***(BETA)***  函数 stopPropagation 阻止事件在事件链中向上冒泡。 |
|  [stringToNode(str)](./robinson.stringtonode.md) | ***(BETA)***  该函数接受一个字符串并返回新创建的 div 元素的第一个子节点，并将该字符串作为其innerHTML。 |
|  [throttle(fn, immediate, leading, trailing)](./robinson.throttle.md) | ***(BETA)***  节流函数，限制函数调用的频率。 |
|  [toRgbaString(colorObj, n)](./robinson.torgbastring.md) | ***(BETA)***  将颜色对象转换为rgba颜色字符串 |
|  [transHightLight(str, keyWords, color)](./robinson.transhightlight.md) | ***(BETA)***  将字符串中的关键词高亮显示。 |
|  [unBind(dom, eventType, fnName)](./robinson.unbind.md) | ***(BETA)***  函数 unBind 从 DOM 元素中删除事件侦听器。 |
|  [urlToBase64(url, suffix)](./robinson.urltobase64.md) | ***(BETA)***  将图片URL转换为Base64编码的字符串 |

---

---
url: /etc\doc/robinson.nodetostring.md
---
[Home](./index.md) > [robinson](./robinson.md) > [nodeToString](./robinson.nodetostring.md)

## nodeToString() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数 `nodeToString` 接受一个 HTML 元素并返回它的字符串表示形式。

**Signature:**

```typescript
declare function nodeToString(node: Element): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  node | Element | node 参数的类型为 Element，它表示 DOM（文档对象模型）中的 HTML 元素。它可以是任何 HTML元素 |

**Returns:**

string

所提供的 HTML 元素的字符串表示形式。

## Example

```JavaScript
   let div =document.createElement('div');
   nodeToString(div) => '<div></div>'
```

---

---
url: /etc\doc/robinson.parsecolorstring.md
---
[Home](./index.md) > [robinson](./robinson.md) > [parseColorString](./robinson.parsecolorstring.md)

## parseColorString() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

解析颜色字符串为颜色对象

该函数可以解析十六进制颜色字符串或rgba颜色字符串为颜色对象

**Signature:**

```typescript
parseColorString: (color: string) => IRgba | string
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | 颜色字符串 |

**Returns:**

IRgba | string

{string} 包含RGBA分量的对象，如果无法解析则返回空字符串

## Example

```javascript
parseColorString('#FF0000');         // { r: 255, g: 0, b: 0, a: 1 }
parseColorString('rgba(255, 0, 0, 0.5)'); // { r: 255, g: 0, b: 0, a: 0.5 }
```

---

---
url: /etc\doc/robinson.parsehexcolor.md
---
[Home](./index.md) > [robinson](./robinson.md) > [parseHexColor](./robinson.parsehexcolor.md)

## parseHexColor() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

解析十六进制颜色字符串为RGBA对象

该函数接受一个十六进制颜色字符串（例如 "#RRGGBB" 或 "#RGB"）， 并将其解析为一个包含红（r）、绿（g）、蓝（b）和透明度（a）分量的对象

**Signature:**

```typescript
parseHexColor: (color: string) => IRgba
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | 十六进制颜色字符串 |

**Returns:**

IRgba

{{r:"",g:"",b:"",a:""}} 包含RGBA分量的对象

## Example

```javascript
parseHexColor('#FF0000'); // { r: 255, g: 0, b: 0, a: 1 }
parseHexColor('#F00');    // { r: 255, g: 0, b: 0, a: 1 }
parseHexColor('#FF0000FF'); // { r: 255, g: 0, b: 0, a: 1 }
```

---

---
url: /etc\doc/robinson.parsergbacolor.md
---
[Home](./index.md) > [robinson](./robinson.md) > [parseRgbaColor](./robinson.parsergbacolor.md)

## parseRgbaColor() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

解析rgba颜色字符串为颜色对象

**Signature:**

```typescript
parseRgbaColor: (color: string) => IRgba
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | rgba颜色字符串 |

**Returns:**

IRgba

{ r: 255, g: 0, b: 0, a: 0.5} 包含RGBA分量的对象

## Example

```javascript
parseRgbaColor('rgba(255, 0, 0, 0.5)'); // { r: 255, g: 0, b: 0, a: 0.5 }
```

---

---
url: /etc\doc/robinson.pipe.md
---
[Home](./index.md) > [robinson](./robinson.md) > [pipe](./robinson.pipe.md)

## pipe() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

从左向右执行函数。

**Signature:**

```typescript
declare function pipe(...fns: Array<Function>): Function;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fns | Array\<Function> | 要组合的函数。 |

**Returns:**

Function

{Function} - 返回一个组合后的函数。

## Example

```JavaScript
const addOne = x => x + 1;
const double = x => x * 2;
const piped = pipe(addOne, double);
piped(2);// 返回 6
```

---

---
url: /etc\doc/robinson.preventdefault.md
---
[Home](./index.md) > [robinson](./robinson.md) > [preventDefault](./robinson.preventdefault.md)

## preventDefault() function

该函数可防止事件的默认行为。

**Signature:**

```typescript
declare function preventDefault(event: Event): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  event | Event | “event”参数是一个对象，表示已发生的事件，例如鼠标单击或按键。 它包含有关事件的信息，例如事件类型、触发事件的目标元素以及与事件关联的任何其他数据。 |

**Returns:**

void

---

---
url: /etc\doc/robinson.printbyblob.md
---
[Home](./index.md) > [robinson](./robinson.md) > [printByBlob](./robinson.printbyblob.md)

## printByBlob() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

通过Blob对象打印内容

**Signature:**

```typescript
declare function printByBlob(blob: Blob, type?: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  blob | Blob | Blob对象 |
|  type | string | *(Optional)* MIME类型，默认为'application/pdf' |

**Returns:**

void

## Example

printByBlob(new Blob(\['Hello, world!'], { type: 'text/plain' }));

---

---
url: /etc\doc/robinson.printbydom.md
---
[Home](./index.md) > [robinson](./robinson.md) > [printByDom](./robinson.printbydom.md)

## printByDom() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

通过DOM元素打印内容

**Signature:**

```typescript
declare function printByDom(el: HTMLElement, custStyle?: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  el | HTMLElement | 要打印的DOM元素 |
|  custStyle | string | *(Optional)* 自定义CSS样式 |

**Returns:**

void

## Example

printByDom(document.getElementById('print-content'), 'body { font-size: 12px; }');

---

---
url: /etc\doc/robinson.removenode.md
---
[Home](./index.md) > [robinson](./robinson.md) > [removeNode](./robinson.removenode.md)

## removeNode() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数从其父节点中删除指定的 DOM 元素。

**Signature:**

```typescript
declare function removeNode(parentNode: Element, dom: Element): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  parentNode | Element | parentNode 参数是包含 dom 元素的元素。它是您要从中删除“dom”元素的元素。 |
|  dom | Element | dom 参数是要从其父节点中删除的元素。 |

**Returns:**

void

## Example

```JavaScript
   let div =document.createElement('div');
   document.body.appendChild(div)
   removeNode(document.body,div)
```

---

---
url: /etc\doc/robinson.removeclass.md
---
[Home](./index.md) > [robinson](./robinson.md) > [removeClass](./robinson.removeclass.md)

## removeClass() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数从给定的 DOM 元素中删除指定的类名。

**Signature:**

```typescript
declare function removeClass(dom: Element, classNm: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  dom | Element | “dom”参数的类型为“Element”，表示要从中删除类的 DOM 元素。 |
|  classNm | string | “classNm”参数是一个字符串，表示要从“dom”元素中删除的类的名称。 |

**Returns:**

void

## Example

```JavaScript
   let div =document.createElement('div');
   div.className ='a1 a2 a3'
   removeClass(div,'a1')
```

---

---
url: /etc\doc/robinson.rendertmp.md
---
[Home](./index.md) > [robinson](./robinson.md) > [renderTmp](./robinson.rendertmp.md)

## renderTmp() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数获取元素的InnerHtml字符串模板,填写好内容并返回

**Signature:**

```typescript
declare function renderTmp(selecter: string, data: any): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  selecter | string | css 选择器 |
|  data | any | dom 模板需要的数据 |

**Returns:**

string

## Example

```JavaScript
      html:
      <div id='user-box'> </div>
      <script type="text/html" id="tpl-user">
          <div>姓名:{{name}}</div>
          <div>年龄:{{  age  }}</div>
          <div>性别:{{  gender}}</div>
          <div>住址:{{address  }}</div>
      </script>
      JavaScript:
      let data ={name:"张三",age:28,gender:"男",address:"北京顺路"}
      //调用模板引擎
      let htmlStr=renderTmp('tpl-user',data)
      //操作dom渲染html结构
      document.getElementById('user-box').innerHTML=htmlStr
      resule
      <div id='user-box'>
          <div>姓名:{{ 张三 }}</div>
          <div>年龄:{{ 28 }}</div>
          <div>性别:{{ 男 }}</div>
          <div>住址:{{ 北京顺路 }}</div>
      </div>
```

---

---
url: /etc\doc/robinson.replaceclass.md
---
[Home](./index.md) > [robinson](./robinson.md) > [replaceClass](./robinson.replaceclass.md)

## replaceClass() function

该函数将给定 DOM 元素上的旧类替换为新类。

**Signature:**

```typescript
declare function replaceClass(dom: Element, newClass: string, oldClass: string): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  dom | Element | dom 参数的类型为 Node，表示将执行类替换的 DOM 元素。 |
|  newClass | string | 要添加到 DOM 元素的新 CSS 类。 |
|  oldClass | string | oldClass 参数是一个字符串，表示要替换的类名。 |

**Returns:**

void

## Example

```JavaScript
 let div = document.creatElement('div');
 div.className = 'a11'
 replaceClass(div,'a22','a11')
```

---

---
url: /etc\doc/robinson.replacenode.md
---
[Home](./index.md) > [robinson](./robinson.md) > [replaceNode](./robinson.replacenode.md)

## replaceNode() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数“replaceNode”用新的 DOM 元素或给定父元素中的字符串替换旧的 DOM 元素。

**Signature:**

```typescript
declare function replaceNode(parentNode: Element, newDom: string | Node, oldDom: Element): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  parentNode | Element | ParentNode 参数是包含 oldDom 元素的元素。它是发生替换的父元素。 |
|  newDom | string | Node | newDom 参数可以是字符串或 Node。如果它是一个字符串， 则它表示将使用“stringToNode”函数转换为节点的 HTML 标记。如果已经是一个Node，则代表新的Node将取代旧的Node |
|  oldDom | Element | oldDom 参数是要替换为 newDom 的元素。 |

**Returns:**

void

## Example

```JavaScript
   let div = document.createElement('div')
   div.id = 'aa6'
   let body = docuement.body
   body.appendChild(div);

   let span =document.createElement('span');
   replaceNode(body,span,div);
```

---

---
url: /etc\doc/robinson.rgbatohex.md
---
[Home](./index.md) > [robinson](./robinson.md) > [rgbaToHex](./robinson.rgbatohex.md)

## rgbaToHex() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将rgba颜色字符串转换为十六进制颜色字符串

**Signature:**

```typescript
declare function rgbaToHex(color: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | rgba颜色字符串 |

**Returns:**

string

{string} 转换后的十六进制颜色字符串，如果输入无效则返回空字符串

## Example

```javascript
rgbaToHex('rgba(0,0,0,1)'); // '#000000'
rgbaToHex('#000000'); // ''
```

---

---
url: /etc\doc/robinson.rgbtohex.md
---
[Home](./index.md) > [robinson](./robinson.md) > [rgbToHex](./robinson.rgbtohex.md)

## rgbToHex() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将rgb颜色字符串转换为十六进制颜色字符串

**Signature:**

```typescript
declare function rgbToHex(color: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  color | string | rgb颜色字符串 |

**Returns:**

string

{string} 转换后的十六进制颜色字符串，如果输入无效则返回空字符串

## Example

```javascript
rgbToHex('rgb(0,0,0)'); // '#000000'
rgbToHex('#000000'); // ''
```

---

---
url: /etc\doc/robinson.stringtonode.md
---
[Home](./index.md) > [robinson](./robinson.md) > [stringToNode](./robinson.stringtonode.md)

## stringToNode() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

该函数接受一个字符串并返回新创建的 div 元素的第一个子节点，并将该字符串作为其innerHTML。

**Signature:**

```typescript
declare function stringToNode(str: string): Node | null;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  str | string | str 参数是一个字符串，表示一个 HTML 元素或一组 HTML 元素。 |

**Returns:**

Node | null

创建的 div 元素的第一个子节点。

## Example

```JavaScript
   let str ='<div>123</div>'
   document.body.append(stringToNode(str))
```

---

---
url: /etc\doc/robinson.stoppropagation.md
---
[Home](./index.md) > [robinson](./robinson.md) > [stopPropagation](./robinson.stoppropagation.md)

## stopPropagation() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数 stopPropagation 阻止事件在事件链中向上冒泡。

**Signature:**

```typescript
declare function stopPropagation(event: Event): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  event | Event | 事件参数是一个表示发生的事件的对象。它包含有关事件的信息，例如事件类型、目标元素以及与事件关联的任何其他数据。在这种情况下，事件参数的类型为Event，它是一个通用事件对象，可以 |

**Returns:**

void

---

---
url: /etc\doc/robinson.throttle.md
---
[Home](./index.md) > [robinson](./robinson.md) > [throttle](./robinson.throttle.md)

## throttle() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

节流函数，限制函数调用的频率。

**Signature:**

```typescript
declare function throttle(fn: Function, immediate: number, leading?: boolean, trailing?: boolean): Function;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  fn | Function | “fn”参数是您想要限制的函数。 |
|  immediate | number | “immediate”参数是函数调用之间的最小时间间隔（以毫秒为单位）。 |
|  leading | boolean | *(Optional)* “leading”参数决定该函数是在调用时立即执行还是等待指定的“immediate”时间过去后才第一次执行该函数。 |
|  trailing | boolean | *(Optional)* “trailing”参数决定是否应在上次调用后立即调用节流函数，即使指定的时间间隔（“immediate”）尚未过去。 |

**Returns:**

Function

{Function} - 返回一个节流函数。

## Example

```JavaScript
const log = () => console.log('Logged');
const throttledLog = throttle(log, 1000, true, false);
throttledLog(); // 立即执行
throttledLog(); // 1秒内再次调用不会执行
throttledLog.cancel(); // 取消执行
```

---

---
url: /etc\doc/robinson.transhightlight.md
---
[Home](./index.md) > [robinson](./robinson.md) > [transHightLight](./robinson.transhightlight.md)

## transHightLight() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将字符串中的关键词高亮显示。

**Signature:**

```typescript
declare function transHightLight(str: string, keyWords: string | Array<string>, color?: string): string;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  str | string | 要进行高亮处理的原始字符串。 |
|  keyWords | string | Array\<string> | 要高亮的关键字，多个关键字之间可以不使用分隔符。 |
|  color | string | *(Optional)* 高亮显示的颜色，默认为 '#0053db'。 |

**Returns:**

string

返回一个新的字符串，其中关键字被包裹在带有指定颜色样式的 span 标签中。

---

---
url: /etc\doc/robinson.torgbastring.md
---
[Home](./index.md) > [robinson](./robinson.md) > [toRgbaString](./robinson.torgbastring.md)

## toRgbaString() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将颜色对象转换为rgba颜色字符串

**Signature:**

```typescript
toRgbaString: (colorObj: IRgba, n?: number) => string
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  colorObj | IRgba | 颜色对象，包含r、g、b分量，可选a分量 |
|  n | number | *(Optional)* |

**Returns:**

string

{string} 返回一个rgba格式的字符串

## Example

```javascript
let obj = { r: 255, g: 255, b: 255 };
toRgbaString(obj); // "rgba(255,255,255,1)"
```

---

---
url: /etc\doc/robinson.unbind.md
---
[Home](./index.md) > [robinson](./robinson.md) > [unBind](./robinson.unbind.md)

## unBind() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

函数 unBind 从 DOM 元素中删除事件侦听器。

**Signature:**

```typescript
declare function unBind(dom: Node, eventType: string, fnName: EventListenerOrEventListenerObject): void;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  dom | Node | dom 参数是事件监听器所附加的 DOM 元素。 |
|  eventType | string | eventType 参数是一个字符串，指定要删除的事件的类型。事件类型的示例包括“单击”、“按下键”、“鼠标悬停”等。 |
|  fnName | EventListenerOrEventListenerObject | fnName 参数是要从指定 DOM 元素中删除的事件侦听器函数或事件侦听器对象的名称。 |

**Returns:**

void

## Example

```JavaScript
   let div = document.querySelect('#btn');
   div.onclik =()=>{
     console.log('11')
   }
   unBind(div,'click')
```

---

---
url: /etc\doc/robinson.urltobase64.md
---
[Home](./index.md) > [robinson](./robinson.md) > [urlToBase64](./robinson.urltobase64.md)

## urlToBase64() function

> This API is provided as a preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.

将图片URL转换为Base64编码的字符串

**Signature:**

```typescript
declare function urlToBase64(url: string, suffix?: string): Promise<string>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  url | string | 图片URL |
|  suffix | string | *(Optional)* 文件后缀，默认为'image/png' |

**Returns:**

Promise\<string>

Promise对象，解析为Base64编码的字符串

## Example

urlToBase64('https://example.com/image.png').then(base64 => console.log(base64));

---

---
url: /etc\jest\src/average.md
---
## 五、断言与匹配器

### 5.1 常用断言方法

* **toBe**：判断两个值是否严格相等（使用===）。

```
test('two plus two is four', () => {
    expect(2 + 2).toBe(4);
});
```

* **toEqual**：用于比较对象或数组的内容是否相等。

```
test('objects are equal', () => {
    const obj1 = { a: 1 };
    const obj2 = { a: 1 };
    expect(obj1).toEqual(obj2);
});
```

* **toBeTruthy**：判断值是否为真。

```
test('true is truthy', () => {
    expect(true).toBeTruthy();
});
```

* **toBeFalsy**：判断值是否为假。

```
test('false is falsy', () => {
    expect(false).toBeFalsy();
});
```

* **toBeGreaterThan**：判断值是否大于某个值。

```
test('5 is greater than 3', () => {
    expect(5).toBeGreaterThan(3);
});
```

* **toBeLessThan**：判断值是否小于某个值。

```
test('3 is less than 5', () => {
    expect(3).toBeLessThan(5);
});
```

### 5.2 高级断言技巧

* **嵌套断言**：可以在一个断言中嵌套多个断言，以更细粒度地验证复杂数据结构。

```
test('nested objects are equal', () => {
    const obj1 = { a: { b: 1 } };
    const obj2 = { a: { b: 1 } };
    expect(obj1).toEqual({
        a: expect.objectContaining({
            b: expect.any(Number)
        })
    });
});
```

* **自定义匹配器**：Jest 允许开发者自定义匹配器，以满足特定的测试需求。

```
expect.extend({
    toBeEven: (received) => {
        const pass = received % 2 === 0;
        if (pass) {
            return {
                message: () => `expected ${received} not to be even`,
                pass: true
            };
        } else {
            return {
                message: () => `expected ${received} to be even`,
                pass: false
            };
        }
    }
});
test('2 is even', () => {
    expect(2).toBeEven();
});
```

---

---
url: /etc\jest\src/introduce.md
---
## 二、Jest 简介

### 2.1 定义与功能概述

Jest 是一个 JavaScript 测试框架，它提供了一系列工具和功能，帮助开发者编写和运行测试用例。Jest 的核心功能包括简单易用的断言库、自动模拟机制、快照测试、测试覆盖率报告生成等。通过这些功能，Jest 能够让测试过程变得更加简单、高效，同时提高测试的准确性和可靠性。

### 2.2 特点与优势

* **简洁易用**：Jest 的语法简洁明了，易于上手。开发者可以通过简单的 API 编写测试用例，减少学习成本。

- **自动模拟**：Jest 能够自动模拟模块和函数，大大简化了测试过程中对依赖项的处理。

* **快照测试**：快照测试功能可以方便地对比代码输出的变化，确保代码的行为符合预期。

- **快速高效**：Jest 采用了并行测试和缓存机制，能够显著提高测试的执行速度。

* **丰富的插件生态**：Jest 拥有丰富的插件和扩展，开发者可以根据项目需求进行定制化配置。

### 2.3 与其他测试框架的对比

在 JavaScript 测试领域，除了 Jest，还有 Mocha、Jasmine 等知名测试框架。与 Mocha 相比，Jest 具有更简洁的语法和更强大的自动模拟功能，无需额外配置复杂的断言库和模拟工具。与 Jasmine 相比，Jest 在性能和功能上更具优势，尤其是在处理大型项目和复杂测试场景时表现更为出色。

---

---
url: /etc\jest\src/introduction.md
---
![image.png](/assets/jest.png)

## 一、引言

### 1.1 软件测试的重要性

在软件开发的生命周期中，软件测试是确保软件质量、稳定性和可靠性的关键环节。通过有效的测试，可以发现代码中的潜在缺陷、错误和逻辑漏洞，避免在生产环境中出现严重问题，降低维护成本，提高用户满意度。软件测试不仅有助于提升产品质量，还能增强团队的信心，促进项目的顺利推进。

### 1.2 Jest 的诞生背景与发展历程

Jest 由 Facebook 开发并开源，旨在解决 JavaScript 项目在测试过程中面临的各种挑战。随着 JavaScript 在前端和后端开发中的广泛应用，对高效、易用的测试框架的需求日益增长。Jest 应运而生，它凭借其简洁的语法、强大的功能和良好的性能，迅速在 JavaScript 开发者社区中获得了广泛的认可和使用。自发布以来，Jest 不断更新迭代，添加了许多新特性和功能，逐渐成为 JavaScript 测试领域的主流框架之一。

---

---
url: /etc\jest\src/mockFun.md
---
## 七、模拟函数（Mock Functions）

### 7.1 创建模拟函数

* **jest.fn()** ：使用jest.fn()创建一个模拟函数，模拟函数可以记录调用次数、参数等信息。

```javascript
const mockFunction = jest.fn();
mockFunction();
expect(mockFunction).toHaveBeenCalled();
```

* **自定义返回值**：可以通过mockReturnValue或mockResolvedValue（用于异步函数）来设置模拟函数的返回值。

```javascript
const mockFunction = jest.fn().mockReturnValue(42);
const result = mockFunction();
expect(result).toBe(42);
```

### 7.2 模拟模块

* **jest.mock()** ：使用jest.mock()来自动模拟一个模块，Jest 会自动生成一个模拟模块，其中所有导出的函数都被替换为模拟函数。

```javascript
// module.js
export function originalFunction() {
    return 'original';
}
// test.js
jest.mock('./module');
const { originalFunction } = require('./module');
test('mocked function', () => {
    originalFunction.mockReturnValue('mocked');
    expect(originalFunction()).toBe('mocked');
});
```

* **手动模拟模块**：除了自动模拟，也可以手动创建一个模拟模块，然后通过jest.mock()指定使用该模拟模块。

```javascript
// __mocks__/module.js
export function originalFunction() {
    return'mocked';
}
// test.js
jest.mock('./module');
const { originalFunction } = require('./module');
test('manually mocked function', () => {
    expect(originalFunction()).toBe('mocked');
});
```

### 7.3 模拟函数的使用场景

* **隔离测试**：通过模拟依赖项，将测试对象与外部依赖隔离开来，确保测试的独立性和准确性。

- **测试异步操作**：模拟异步操作的结果，以便在测试中控制和验证异步行为。

* **测试边缘情况**：通过模拟不同的输入和返回值，测试函数在各种边缘情况下的表现。

---

---
url: /etc\jest\src/quick.md
---
## 八、快照测试

### 8.1 基本原理与使用方法

* **原理**：快照测试通过生成一个包含代码输出的快照文件，在后续测试中对比实际输出与快照文件的内容，从而判断代码的行为是否发生变化。

- **使用方法**：使用toMatchSnapshot()匹配器来进行快照测试。

```javascript
function formatUser(user) {
    return `Name: ${user.name}, Age: ${user.age}`;
}
test('format user snapshot', () => {
    const user = { name: 'John', age: 30 };
    expect(formatUser(user)).toMatchSnapshot();
});
```

### 8.2 快照文件管理

* **生成快照文件**：首次运行快照测试时，Jest 会在\_\_snapshots\_\_目录下生成一个快照文件，文件名与测试文件相对应。

- **更新快照文件**：当代码发生变化，需要更新快照文件时，可以使用jest --updateSnapshot命令或在测试运行时按下u键。

* **删除快照文件**：如果不再需要某个快照文件，可以手动删除\_\_snapshots\_\_目录下对应的文件。

### 8.3 快照测试的应用场景

* **UI 组件测试**：在测试 React、Vue 等前端框架的组件时，快照测试可以方便地验证组件的渲染结果是否符合预期。

- **数据格式化测试**：对于数据格式化函数，快照测试可以确保数据格式化的结果在代码修改后保持一致。

* **API 响应测试**：在测试 API 调用时，快照测试可以验证 API 响应的结构和内容是否发生变化。

---

---
url: /etc\jest\src/testAsync.md
---
## 六、测试异步代码

### 6.1 异步函数返回 Promise

* **使用 async/await**：通过async/await语法可以方便地测试返回 Promise 的异步函数。

```javascript
function asyncAdd(a, b) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(a + b);
        }, 1000);
    });
}
test('async add works', async () => {
    const result = await asyncAdd(1, 2);
    expect(result).toBe(3);
});
```

* **使用.then ()** ：也可以使用.then()方法来处理 Promise。

```javascript
test('async add works with then', () => {
    return asyncAdd(1, 2).then((result) => {
        expect(result).toBe(3);
    });
});
```

### 6.2 使用回调函数

* **使用 done ()** ：在测试使用回调函数的异步代码时，需要调用done()方法来通知 Jest 测试完成。

```javascript
function addWithCallback(a, b, callback) {
    setTimeout(() => {
        callback(a + b);
    }, 1000);
}
test('add with callback works', (done) => {
    addWithCallback(1, 2, (result) => {
        expect(result).toBe(3);
        done();
    });
});
```

### 6.3 处理异步错误

* **使用 try/catch**：在async/await中，可以使用try/catch来捕获异步错误。

```javascript
test('async function throws error', async () => {
    async function asyncError() {
        throw new Error('Async error');
    }
    try {
        await asyncError();
    } catch (error) {
        expect(error.message).toBe('Async error');
    }
});
```

* **使用.rejectWith ()** ：在使用.then()时，可以使用.rejectWith()来处理 Promise 被拒绝的情况。

```javascript
test('async function throws error with then', () => {
    async function asyncError() {
        throw new Error('Async error');
    }
    return asyncError().catch((error) => {
        expect(error.message).toBe('Async error');
    });
});
```

---

---
url: /etc\jest\src/use.md
---
## 十、Jest 在不同场景下的应用

### 10.1 前端开发中的应用

* **React 组件测试**：使用 Jest 结合 React Testing Library 或 Enzyme，可以方便地测试 React 组件的渲染、交互和状态变化。

```javascript
import React from'react';
import { render, fireEvent } from '@testing-library/react';
import MyComponent from './MyComponent';
test('renders MyComponent and clicks button', () => {
    const { getByText } = render(<MyComponent />);
    const button = getByText('Click me');
    fireEvent.click(button);
    // 断言组件状态变化
});
```

* **Vue 组件测试**：对于 Vue 组件，可以使用 Jest 结合 Vue Test Utils 进行测试。

```javascript
import { mount } from '@vue/test-utils';
import MyVueComponent from './MyVueComponent.vue';
test('renders Vue component and updates data', () => {
    const wrapper = mount(MyVueComponent);
    wrapper.find('button').trigger('click');
    // 断言组件数据变化
});
```

### 10.2 后端开发中的应用

* **Node.js 应用测试**：在 Node.js 应用开发中，Jest 可以用于测试路由、中间件、数据库操作等功能。

```javascript
const request = require('supertest');
const app = require('./app');
test('GET / returns 200', async () => {
    const response = await request(app).get('/
```

### 10.2 后端开发中的应用（续）

* **Node.js 应用测试**：

- - **路由测试**：在测试路由时，除了验证响应状态码，还可以检查响应体的内容。例如，假设我们有一个简单的 Express 应用，包含一个返回用户列表的路由。

```javascript
const express = require('express');
const app = express();
const users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' }
];
app.get('/users', (req, res) => {
    res.json(users);
});
const request = require('supertest');
test('GET /users returns users list', async () => {
    const response = await request(app).get('/users');
    expect(response.status).toBe(200);
    expect(response.body).toEqual(users);
});
```

* **中间件测试**：中间件在 Node.js 应用中起着至关重要的作用，比如验证用户身份、记录日志等。以一个简单的身份验证中间件为例，使用 Jest 测试它是否能正确拦截未授权的请求。

```javascript
const express = require('express');
const app = express();
// 模拟身份验证中间件
const authMiddleware = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.split(' ')[1];
        // 这里简单模拟token验证
        if (token === 'validToken') {
            return next();
        }
    }
    res.status(401).send('Unauthorized');
};
app.get('/protected', authMiddleware, (req, res) => {
    res.send('Protected resource');
});
const request = require('supertest');
test('GET /protected rejects unauthenticated requests', async () => {
    const response = await request(app).get('/protected');
    expect(response.status).toBe(401);
    expect(response.text).toBe('Unauthorized');
});
test('GET /protected allows authenticated requests', async () => {
    const response = await request(app)
     .get('/protected')
     .set('Authorization', 'Bearer validToken');
    expect(response.status).toBe(200);
    expect(response.text).toBe('Protected resource');
});
```

* **数据库操作测试**：对于涉及数据库操作的函数，利用 Jest 的模拟函数来隔离测试。以使用mysql模块进行数据库查询为例。

```javascript
const mysql = require('mysql');
// 模拟数据库连接池
const pool = mysql.createPool({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'testdb'
});
// 假设一个获取用户信息的函数
function getUserById(id, callback) {
    const query = 'SELECT * FROM users WHERE id =?';
    pool.query(query, [id], (error, results) => {
        if (error) {
            return callback(error);
        }
        callback(null, results[0]);
    });
}
// 测试文件
const { getUserById } = require('./userService');
const mysql = require('mysql');
jest.mock('mysql');
test('getUserById retrieves user from database', (done) => {
    const mockResults = [{ id: 1, name: 'Alice' }];
    const mockQuery = jest.fn((sql, values, cb) => {
        cb(null, mockResults);
    });
    mysql.createPool.mockReturnValue({
        query: mockQuery
    });
    getUserById(1, (error, user) => {
        expect(error).toBe(null);
        expect(user).toEqual(mockResults[0]);
        done();
    });
});
```

### 10.3 测试 GraphQL API

随着 GraphQL 在前后端开发中的广泛应用，使用 Jest 测试 GraphQL API 也变得越来越重要。以express - graphql为例，展示如何使用 Jest 测试 GraphQL 的查询和变更。

```javascript
const express = require('express');
const { buildSchema } = require('graphql');
const { graphqlHTTP } = require('express - graphql');
// 构建GraphQL schema
const schema = buildSchema(`
    type Query {
        hello: String
    }
`);
// 定义解析器
const root = {
    hello: () => 'Hello world!'
};
const app = express();
app.use('/graphql', graphqlHTTP({
    schema: schema,
    rootValue: root,
    graphiql: true // 开启GraphiQL调试工具
}));
const request = require('supertest');
test('GraphQL query hello returns "Hello world!"', async () => {
    const response = await request(app)
     .post('/graphql')
     .send({ query: '{ hello }' });
    expect(response.status).toBe(200);
    expect(response.body.data.hello).toBe('Hello world!');
});
```

### 10.4 测试工具与库的结合使用

在实际项目中，Jest 常常与其他工具和库结合使用，以提高测试效率和质量。

* **Sinon.js**：Sinon.js 是一个功能强大的 JavaScript 测试库，提供了丰富的模拟、桩（stub）和间谍（spy）功能。与 Jest 结合使用，可以更灵活地控制测试环境。例如，在测试一个依赖外部 API 的函数时，使用 Sinon 的stub来模拟 API 调用，而不是实际发送请求。

```javascript
const sinon = require('sinon');
const axios = require('axios');
const myFunction = require('./myFunction');
test('myFunction calls external API correctly', async () => {
    const mockResponse = { data: { message: 'Mocked response' } };
    const stub = sinon.stub(axios, 'get').resolves(mockResponse);
    const result = await myFunction();
    expect(result).toEqual(mockResponse.data);
    stub.restore();
});
```

* **Cypress**：Cypress 是一个用于前端自动化测试的工具，专注于浏览器端的交互测试。虽然 Jest 主要用于单元测试，但在一些场景下，结合 Cypress 可以实现更全面的测试覆盖。例如，使用 Jest 进行组件的单元测试，使用 Cypress 进行端到端的集成测试，确保整个应用在浏览器环境中的行为符合预期。

### 10.5 持续集成中的 Jest

在持续集成（CI）环境中，Jest 扮演着关键角色，确保每次代码提交都经过充分的测试。以 GitHub Actions 为例，展示如何在 CI 环境中配置 Jest 测试。

```
name: Jest Tests
on:
  push:
    branches:
      - main
jobs:
  build:
    runs - on: ubuntu - latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup - node@v2
        with:
          node - version: '14'
      - name: Install dependencies
        run: npm install
      - name: Run Jest tests
        run: npm test -- --coverage
```

通过上述配置，每次代码推送到main分支时，GitHub Actions 会自动拉取代码，安装依赖，然后运行 Jest 测试，并生成测试覆盖率报告。这有助于及时发现代码中的问题，保证项目的稳定性和质量。

### 10.6 Jest 在微服务架构中的应用

在微服务架构中，各个服务相互独立又协同工作。Jest 可以用于对每个微服务进行单元测试和集成测试，确保服务的可靠性和稳定性。

#### 10.6.1 服务接口测试

每个微服务都会暴露一些接口供其他服务调用。使用 Jest 结合supertest等库，可以测试这些接口的正确性。例如，假设我们有一个用户管理微服务，提供了获取用户信息的接口。

```javascript
const express = require('express');
const app = express();
const users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' }
];
app.get('/users/:id', (req, res) => {
    const userId = parseInt(req.params.id);
    const user = users.find(u => u.id === userId);
    if (user) {
        res.json(user);
    } else {
        res.status(404).send('User not found');
    }
});
const request = require('supertest');
test('GET /users/:id returns correct user', async () => {
    const response = await request(app).get('/users/1');
    expect(response.status).toBe(200);
    expect(response.body).toEqual(users[0]);
});
test('GET /users/:id returns 404 for non - existent user', async () => {
    const response = await request(app).get('/users/3');
    expect(response.status).toBe(404);
    expect(response.text).toBe('User not found');
});
```

#### 10.6.2 服务间通信测试

微服务之间通常通过 HTTP、消息队列等方式进行通信。在测试时，可以使用 Jest 模拟其他服务的响应，测试当前服务在不同通信场景下的行为。例如，使用nock库来模拟 HTTP 请求的响应，测试一个依赖其他服务获取数据的微服务。

```javascript
const axios = require('axios');
const nock = require('nock');
const myService = require('./myService');
test('myService calls other service and processes response', async () => {
    const mockData = { message: 'Mocked data from other service' };
    nock('http://other - service.com')
     .get('/data')
     .reply(200, mockData);
    const result = await myService.fetchData();
    expect(result).toEqual(mockData);
});
```

### 10.7 Jest 与测试报告工具的整合

为了更直观地展示测试结果，Jest 可以与一些测试报告工具进行整合。

#### 10.7.1 Jest 与 Allure 的整合

Allure 是一个功能强大的测试报告工具，它可以生成美观、详细的测试报告。通过jest - allure - reporter插件，可以将 Jest 的测试结果集成到 Allure 报告中。

1. 安装插件：

```sh
npm install --save - dev jest - allure - reporter
```

2. 在jest.config.js中配置：

```javascript
module.exports = {
    // 其他配置项
    reporters: [
        'default',
        'jest - allure - reporter'
    ]
};
```

3. 运行测试后，在项目根目录下会生成allure - results目录，使用 Allure 命令行工具可以生成报告：

```sh
allure serve allure - results
```

生成的报告中会包含每个测试用例的详细信息，如执行时间、状态、断言结果等，方便团队成员查看和分析测试结果。

#### 10.7.2 Jest 与 Cucumber 的整合（BDD 风格测试）

Cucumber 是一个支持行为驱动开发（BDD）的工具，它使用自然语言描述测试场景。通过cucumber - jest库，可以将 Jest 与 Cucumber 结合，实现 BDD 风格的测试。

1. 安装依赖：

```
npm install --save - dev cucumber - jest cucumber
```

2. 创建features目录，在其中编写 Cucumber 的特性文件（.feature），例如login.feature：

```javascript
Feature: User Login
  As a user
  I want to log in to the application
  So that I can access my account
  Scenario: Successful login
    Given I am on the login page
    When I enter my username "testuser" and password "testpass"
    And I click the login button
    Then I should be redirected to my account page
```

3. 创建相应的步骤定义文件（.js），在其中使用 Jest 的断言实现每个步骤的逻辑：

```javascript
const { Given, When, Then } = require('cucumber - jest');
const { render, fireEvent } = require('@testing - library/react');
const LoginPage = require('./LoginPage');
Given('I am on the login page', () => {
    // 渲染登录页面组件
    const { container } = render(<LoginPage />);
    // 可以进行一些初始化操作，如保存页面容器
});
When('I enter my username "testuser" and password "testpass"', () => {
    // 找到用户名和密码输入框，模拟输入
    const usernameInput = document.getElementsByName('username')[0];
    const passwordInput = document.getElementsByName('password')[0];
    fireEvent.change(usernameInput, { target: { value: 'testuser' } });
    fireEvent.change(passwordInput, { target: { value: 'testpass' } });
});
When('I click the login button', () => {
    // 找到登录按钮，模拟点击
    const loginButton = document.querySelector('button[type="submit"]');
    fireEvent.click(loginButton);
});
Then('I should be redirected to my account page', () => {
    // 断言页面是否重定向到正确的URL
    expect(window.location.href).toContain('/account');
});
```

通过这种方式，可以将业务逻辑以自然语言的形式描述出来，使非技术人员也能理解测试的目的和场景，同时利用 Jest 强大的断言和测试功能实现具体的测试逻辑。

---

---
url: /etc\vitepress\src/install.md
---
## 安装[​](https://vitepress.dev/zh/guide/getting-started#installation)

### 前置准备[​](https://vitepress.dev/zh/guide/getting-started#prerequisites)

* [Node.js](https://nodejs.org/) 18 及以上版本。

* 通过命令行界面 (CLI) 访问 VitePress 的终端。

* 支持 [Markdown](https://en.wikipedia.org/wiki/Markdown) 语法的编辑器。

* 推荐 [VSCode](https://code.visualstudio.com/) 及其[官方 Vue 扩展](https://marketplace.visualstudio.com/items?itemName=Vue.volar)。

### 安装并初始化

```
  npm i vitepress
  
  $ npx vitepress init
  将需要回答几个简单的问题：
  
  ┌  Welcome to VitePress!
 │
 ◇  Where should VitePress initialize the config? //VitePress 应该在哪里初始化配置
 │  ./docs
 │
 ◇  Site title: //标题
 │  My Awesome Project
 │
 ◇  Site description: //描述
 │  A VitePress Site
 │
 ◆  Theme: //主题
 │  ● Default Theme (Out of the box, good-looking docs)
 │  ○ Default Theme + Customization
 │  ○ Custom Theme
 └
```

### 文档结构

```tree
├─ docs  
│  ├─ .vitepress  
│  │  └─ config.js  
│  ├─ api-examples.md  
│  ├─ markdown-examples.md  
│  └─ index.md  
└─ package.json

```

---

---
url: /index.md
---


---

---
url: /temp/robinson.api.md
---
## API Report File for "robinson"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BigSource } from 'big.js';
import dayjs from 'dayjs';

// @beta
export function addClass(dom: Element, classNm: string): void;

// Warning: (ae-forgotten-export) The symbol "position" needs to be exported by the entry point index.d.ts
//
// @beta
export function addNode(parentDom: Element, dom: Element | String, position?: position): void;

// Warning: (ae-forgotten-export) The symbol "DAMNU_ENABLE" needs to be exported by the entry point index.d.ts
//
// @beta
export function asignData(obj1: DAMNU_ENABLE, obj2: DAMNU_ENABLE): DAMNU_ENABLE;

// @beta
export function base64ToBlob(base64: string): Blob;

// @beta
export function bind(dom: Node, eventType: string, callBack: EventListenerOrEventListenerObject, isCatch?: boolean): void;

// @beta
export function blobToBase64(blob: BlobPart, suffix?: string): Promise<unknown>;

// Warning: (ae-forgotten-export) The symbol "TOperate" needs to be exported by the entry point index.d.ts
//
// @beta
export function calc(number1: BigSource, number2: BigSource, operate?: TOperate): string;

// @beta
export function compose(...fns: Array<Function>): Function;

// @beta
export function copyToClipboard(text: string): void;

// Warning: (ae-forgotten-export) The symbol "ParamsInter" needs to be exported by the entry point index.d.ts
//
// @beta
export const createCache: (storage: any, parmas?: ParamsInter) => {
    "__#9309@#storage": any;
    "__#9309@#encode": Function;
    "__#9309@#decode": Function;
    setCache(key: string, value: any, expire: number): void;
    getCache(encodeKey: string): any;
    removeCache(key: string): void;
    has(key: string): boolean;
    length(): any;
    clear(): void;
};

// @beta
export function currying(fn: Function): Function;

// @beta
export function debounce(fn: Function, delay: number, isLimmediate?: boolean): Function;

// @beta
export function deepClone(originalValue: any): any;

// @beta
export function downloadByBase64(buf: string, fileNm: string, suffix: string): void;

// @beta
export function downloadByBlob(blob: BlobPart, fileNm: string, suffix?: string): void;

// @beta
export function downloadByUrl(url: string, filename?: string, type?: string): void;

// @beta
export class EventBus {
    constructor();
    clear(eventName: string): void;
    emit(eventName: string, ...Args: any): void;
    // (undocumented)
    off(eventName: string, fn: Function): void;
    on(eventName: string, eventFn: Function): void;
}

// Warning: (ae-forgotten-export) The symbol "Tday" needs to be exported by the entry point index.d.ts
//
// @beta
export function formatDate(date: Tday, pattern?: string): string;

// Warning: (ae-forgotten-export) The symbol "IOptions" needs to be exported by the entry point index.d.ts
//
// @beta
export function getAfterDate(date: Tday, option: IOptions): string;

// @beta
export function getBeforeDate(date: Tday, option: IOptions): string;

// @beta
export function getChunkArray(array: Array<any>, size?: number): Array<Array<any>>;

// @beta
export function getDiff(start: Tday, end: Tday, unitType: dayjs.OpUnitType, float?: boolean): number;

// @beta
export function getEtc(value: string, len: number, etcStr?: string): string;

// @beta
export function getFileChunk(file: File, chunkSize?: number): Array<{
    index: number;
    file: Blob;
}>;

// @beta
export function getFileSize(file: File, unit?: string): number;

// @beta
export function getFileType(file: File): string | undefined;

// @beta
export function getMimeType(suffix: String): "" | "audio/aac" | "application/x-abiword" | "image/apng" | "application/x-freearc" | "image/avif" | "video/x-msvideo" | "application/vnd.amazon.ebook" | "application/octet-stream" | "image/bmp" | "application/x-bzip" | "application/x-bzip2" | "application/x-cdf" | "application/x-csh" | "text/css" | "text/csv" | "application/msword" | "application/vnd.openxmlformats-officedocument.wordprocessingml.document" | "application/vnd.ms-fontobject" | "application/epub+zip" | "application/gzip" | "image/gif" | "text/html" | "image/x-icon" | "text/calendar" | "application/java-archive" | "image/jpeg" | "text/javascript" | "application/json" | "application/ld+json" | "audio/midi" | "audio/mpeg" | "video/mp4" | "video/mpeg" | "application/vnd.apple.installer+xml" | "application/vnd.oasis.opendocument.presentation" | "application/vnd.oasis.opendocument.spreadsheet" | "application/vnd.oasis.opendocument.text" | "audio/ogg" | "video/ogg" | "application/ogg" | "audio/opus" | "font/otf" | "image/png" | "application/x-httpd-php" | "application/pdf" | "application/vnd.ms-powerpoint" | "application/vnd.openxmlformats-officedocument.presentationml.presentation" | "application/vnd.rar" | "application/rtf" | "application/x-sh" | "image/svg+xml" | "application/x-shockwave-flash" | "application/x-tar" | "image/tiff" | "video/mp2t" | "application/x-font-ttf" | "text/plain" | "application/vnd.visio" | "audio/wav" | "audio/webm" | "video/webm" | "image/webp" | "font/woff" | "font/woff2" | "application/xhtml+xml" | "application/vnd.ms-excel" | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" | "application/xml" | "application/vnd.mozilla.xul+xml" | "application/zip" | "video/3gpp" | "video/32" | "application/x-7z-compressed";

// @beta
export function getNode(domName: string): Element | null;

// @beta
export function getNodes(domName: string): NodeList | null;

// @beta
export function getRandom(min: number, max: number, point?: number): number;

// @beta
export function getRelArray(array: Array<any>): Array<any>;

// @beta
export function getTimestamp(date: Tday): number;

// @beta
export function getUniqueId(): string;

// @beta
export function hasClass(dom: Element, classNm: String): boolean;

// @beta
export function hasTypeIn(value: any, types: Array<string>): boolean;

// @beta
export function hexToRgb(hex: string): string;

// @beta
export function hexToRgba(hex: string): string;

// @beta
export function imgCompression(file: File, size: number): Promise<unknown>;

// @beta
export function insertStr(str: string, start: number, char: string): string;

// @beta
export function is(value: any, type: string): boolean;

// @beta
export function isAfter(start: dayjs.ConfigType, end: dayjs.ConfigType): boolean;

// @beta
export function isArray(value: any): boolean;

// @beta
export function isBefore(start: dayjs.ConfigType, end: dayjs.ConfigType): boolean;

// @beta
export function isBoolean(value: any): boolean;

// @beta
export function isDecimal(s: string | number): boolean;

// @beta
export function isElement(val: any): boolean;

// @beta
export function isEmail(s: string): boolean;

// @beta
export function isEmpty(value: any): boolean;

// @beta
export function isEqType(value: any, value2: any): boolean;

// @beta
export function isEqValue(value1: any, value2: any): boolean;

// @beta
export function isExternal(path: any): boolean;

// @beta
function isFinite_2(value: any): boolean;
export { isFinite_2 as isFinite }

// @beta
export function isFunction(value: any): boolean;

// @beta
export function isHex(color: string): boolean;

// @beta
export function isIdCard(id: string): boolean;

// Warning: (ae-forgotten-export) The symbol "Iwindow" needs to be exported by the entry point index.d.ts
//
// @beta
export function isIE(win: Iwindow): boolean;

// @beta
export function isInt(value: any): boolean;

// @beta
export function isLeapYear(year: string | number): boolean;

// @beta
export function isMobileNum(s: string | number): boolean;

// @beta
function isNaN_2(value: any): boolean;
export { isNaN_2 as isNaN }

// @beta
export function isNode(el: any): Boolean;

// @beta
export function isNull(value: any): boolean;

// @beta
export function isNumber(value: any): boolean;

// @beta
export function isObjectLike(value: any): boolean;

// @beta
export function isOriginDate(val: any): boolean;

// @beta
export function isPromise(val: any): boolean;

// @beta
export function isRange(value: number, min: number, max: number): boolean;

// @beta
export function isRefType(value: any): boolean;

// @beta
export function isRegExp(val: any): boolean;

// @beta
export function isRgb(color: string): boolean;

// @beta
export function isRgba(color: string): boolean;

// @beta
export function isSimpleType(value: any): boolean;

// @beta
export function isString(value: any): boolean;

// @beta
export function isSymbol(value: any): boolean;

// @beta
export function isUndefined(value: any): boolean;

// @beta
export function isUrl(url: string): boolean;

// Warning: (ae-forgotten-export) The symbol "enumData" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "options" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "result" needs to be exported by the entry point index.d.ts
//
// @beta
export function mapping(enumData: enumData, options: options, expty?: string): result;

// @beta
export function nodeToString(node: Element): string;

// Warning: (ae-forgotten-export) The symbol "IRgba" needs to be exported by the entry point index.d.ts
//
// @beta
export const parseColorString: (color: string) => IRgba | string;

// @beta
export const parseHexColor: (color: string) => IRgba;

// @beta
export const parseRgbaColor: (color: string) => IRgba;

// @beta
export function pipe(...fns: Array<Function>): Function;

// @public
export function preventDefault(event: Event): void;

// @beta
export function printByBlob(blob: Blob, type?: string): void;

// @beta
export function printByDom(el: HTMLElement, custStyle?: string): void;

// @beta
export function removeClass(dom: Element, classNm: string): void;

// @beta
export function removeNode(parentNode: Element, dom: Element): void;

// @beta
export function renderTmp(selecter: string, data: any): string;

// @public
export function replaceClass(dom: Element, newClass: string, oldClass: string): void;

// @beta
export function replaceNode(parentNode: Element, newDom: string | Node, oldDom: Element): void;

// @beta
export function rgbaToHex(color: string): string;

// @beta
export function rgbToHex(color: string): string;

// @beta
export function stopPropagation(event: Event): void;

// @beta
export function stringToNode(str: string): Node | null;

// @beta
export function throttle(fn: Function, immediate: number, leading?: boolean, trailing?: boolean): Function;

// @beta
export const toRgbaString: (colorObj: IRgba, n?: number) => string;

// @beta
export function transHightLight(str: string, keyWords: string | Array<string>, color?: string): string;

// @beta
export function unBind(dom: Node, eventType: string, fnName: EventListenerOrEventListenerObject): void;

// @beta
export function urlToBase64(url: string, suffix?: string): Promise<string>;

// (No @packageDocumentation comment for this package)

```
